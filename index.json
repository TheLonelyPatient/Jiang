[{"content":"关于定时器(Timer) 定时器（Timer）是一种配置元件，它可在测试计划中的各个请求（Sampler）之间添加延迟或等待时间。可以模拟用户在操作过程中的自然停顿，以及控制请求的发送频率。\n以下是JMeter中几种常用的定时器类型：\n固定定时器(Constant Timer)\n统一随机定时器(Uniform Random Timer)\n常数吞吐量定时器(Constant Throughput Timer)\n准确的吞吐量定时器(Precise Throughput Timer)-暂不讲\nJSR223定时器(JSR223 Timer)\n同步定时器(Synchronizing Timer)\n泊松随机定时器(Poisson Random Timer)\n高斯随机定时器(Gaussian Random Timer)\nBeanShall定时器(BeanShell Timer)\n使用示例脚本，需下载示例接口源码并运行。\r固定定时器 它的作用是添加固定的时间间隔，可添加在测试计划、线程组、取样器下，使其作用域下的所有请求取样器延迟执行，时间单位为毫秒。\n示例Jmeter脚本\n测试计划下添加两个线程组、固定定时器、用表格查看结果\n测试计划面板中勾选独立运行每个线程组\n固定定时器的线程延迟设置为3000\n两个线程组下分别添加三个HTTP请求取样器\n请求地址皆为：HTTP://127.0.0.1:5000/GetList/\n请求方式皆为：GET\n运行结果\n测试计划中勾选了独立运行每个线程组，所以6个请求顺序执行。固定定时器的作用域是整个测试计划，会导致每个请求取样器延迟3秒执行。\n此示例中，固定定时器的作用域是测试计划，所以会使测试计划下的所有请求取样器延迟3秒执行。若固定定时器的作用域是线程组，那会使线程组下的所有请求取样器延迟3秒执行。固定定时器的作用域是请求取样器，就只会使该请求取样器延迟3秒执行。\n统一随机定时器 它的作用是添加一个随机的时间间隔+一个固定的时间间隔，随机的时间间隔在用户0-值之间随机获取，固定的时间间隔可以看作最小时间，时间单位为毫秒。总的延时 = 固定延迟时间 + 随机生成的延时。\n作用域的逻辑与固定定时器一致。\n示例Jmeter脚本\n测试计划下添加两个线程组、用表格查看结果\n线程组中循环次数配置为：2\n线程组下添加三个HTTP请求取样器\n名称分别为：HTTP请求-1-1、HTTP请求-1-2、HTTP请求-1-3\n请求地址皆为：HTTP://127.0.0.1:5000/GetList/\n请求方式皆为：GET\nHTTP请求-1-2下添加统一随机定时器\n统一随机定时器中配置Random Delay Maximum(随机延迟):3000、Constant Delay Offset(固定延迟):3000\n运行结果\n线程组执行了2次，则HTTP请求-1-2也执行了2次。HTTP请求-1-2的两次执行前延迟是不一致的，第一次是3秒，第二次是4秒，原因就是Random Delay Maximum(随机延迟)导致的。\n同步定时器 它的作用是请求数达到阈值时，同步释放请求，保证取样器在同一时刻向服务器发起负载测试。可以设置模拟用户组的数量、超出时间，对并发量及等待时间进行控制，如果线程未达到模拟用户组的数量，它就会一致等待，此时就可以配置超出时间，等待超出时间后，将线程同步释放。\n但是请注意，释放请求时可能会因为主机的性能限制不能同时释放，事实上导致释放时间不一致。解决办法就是购置高性能主机或布置多个从机。\n不配置同步定时器 示例Jmeter脚本\n测试计划下添加线程组、用表格查看结果\n线程组中线程数配置为：100\n线程组下添加HTTP请求取样器\n请求地址为：HTTP://127.0.0.1:5000/GetList/\n请求方式为：GET\n运行结果\n第1个线程请求与第100个线程请求的执行时间相差1秒左右，线程数越大，则误差越大。\n配置同步定时器 示例Jmeter脚本\n测试计划下添加线程组、用表格查看结果、同步定时器\n同步定时器的模拟用户组数量为：100\n线程组中线程数配置为：100\n线程组下添加HTTP请求取样器\n请求地址为：HTTP://127.0.0.1:5000/GetList/\n请求方式为：GET\n运行结果\n可以看出第1个线程请求与第100个线程请求的执行时间相差几毫秒左右。\n超出时间 示例Jmeter脚本\n测试计划下添加线程组、用表格查看结果、同步定时器\n同步定时器的模拟用户组数量为：9、超出时间为3000\n线程组中线程数配置为：10\n线程组下添加HTTP请求取样器\n请求地址为：HTTP://127.0.0.1:5000/GetList/\n请求方式为：GET\n运行结果\n10个线程，同步定时器在线程数达到9(模拟用户组数量)时，释放这9个请求。剩下的1个，由于达不到9个线程(模拟用户组数量)的要求，只能延迟3秒(超出时间)释放。\n常数吞吐量定时器 此计时器引入了可变暂停，经过计算以使总吞吐量（以每分钟样本数计算）尽可能接近给定数字。当然，如果服务器无法处理，或者其他计时器或耗时的测试元素阻止了吞吐量，则吞吐量会更低。\n目标吞吐量（每分钟的样本量）：单位分钟。比如样本量3000，则吞吐量为500/sec。\n只有此线程 每个线程独立计算吞吐量，比如目标吞吐量：3000样本/分钟，线程数：5，则每个线程将独立尝试保持3000样本/分钟，总吞吐量 = 3000 * 5 = 15000样本/分钟。\n配置示例Jmeter脚本\n测试计划下添加聚合报告、常数吞吐定时器、线程组\n常数吞吐定时器的基于计算吞吐量配置为：此线程、目标吞吐量配置为：60.0\n线程组下添加20个相同的HTTP请求取样器\n线程组的线程数配置为：100\nHTTP请求取样器配置请求地址为：HTTP://127.0.0.1:5000/GetList/\nHTTP请求取样器配置请求方式为：GET\n运行结果\n总的吞吐量=基于吞吐量×线程数，基于吞吐量为每分钟60个-即每秒1个。\n则此次测试的总吞吐量为1×100=100/sec，实际结果与其一致。\n当前线程组中的所有活动线程 线程组内的所有线程共同计算吞吐量，每个线程的吞吐量将基于它上次运行的时间，根据需要延迟调整。\n如果配置为目标吞吐量：3000样本/分钟，线程组的线程数：10，这10个线程将共同实现3000样本/分钟的吞吐量，分配吞吐量并根据每个线程上次运行的时间进行延迟调整。\n配置示例Jmeter脚本\n测试计划下添加聚合报告、常数吞吐定时器、线程组\n常数吞吐定时器的基于计算吞吐量配置为：当前线程组中的所有活动线程、目标吞吐量配置为：60.0\n线程组下添加20个相同的HTTP请求取样器\n线程组的线程数配置为：100\nHTTP请求取样器配置请求地址为：HTTP://127.0.0.1:5000/GetList/\nHTTP请求取样器配置请求方式为：GET\n运行结果\n","permalink":"http://192.168.9.98/posts/technology/jmeter/timer/","summary":"关于定时器(Timer) 定时器（Timer）是一种配置元件，它可在测试计划中的各个请求（Sampler）之间添加延迟或等待时间。可以模拟用户在操作过程中的自然停顿，以及控制请求的发送频率。 以下是JMeter中几种常用的定时器类型： 固定定时器(Constant Timer) 统一随机定时器(Un","title":"Jmeter-定时器"},{"content":"关于定时器(Timer) 定时器（Timer）是一种配置元件，它可在测试计划中的各个请求（Sampler）之间添加延迟或等待时间。可以模拟用户在操作过程中的自然停顿，以及控制请求的发送频率。\n以下是JMeter中几种常用的定时器类型：\n固定定时器(Constant Timer)\n统一随机定时器(Uniform Random Timer)\n常数吞吐量定时器(Constant Throughput Timer)\n准确的吞吐量定时器(Precise Throughput Timer)-暂不讲\nJSR223定时器(JSR223 Timer)\n同步定时器(Synchronizing Timer)\n泊松随机定时器(Poisson Random Timer)\n高斯随机定时器(Gaussian Random Timer)\nBeanShall定时器(BeanShell Timer)\n使用示例脚本，需下载示例接口源码并运行。\r固定定时器 它的作用是添加固定的时间间隔，可添加在测试计划、线程组、取样器下，使其作用域下的所有请求取样器延迟执行，时间单位为毫秒。\n示例Jmeter脚本\n测试计划下添加两个线程组、固定定时器、用表格查看结果\n测试计划面板中勾选独立运行每个线程组\n固定定时器的线程延迟设置为3000\n两个线程组下分别添加三个HTTP请求取样器\n请求地址皆为：HTTP://127.0.0.1:5000/GetList/\n请求方式皆为：GET\n运行结果\n测试计划中勾选了独立运行每个线程组，所以6个请求顺序执行。固定定时器的作用域是整个测试计划，会导致每个请求取样器延迟3秒执行。\n此示例中，固定定时器的作用域是测试计划，所以会使测试计划下的所有请求取样器延迟3秒执行。若固定定时器的作用域是线程组，那会使线程组下的所有请求取样器延迟3秒执行。固定定时器的作用域是请求取样器，就只会使该请求取样器延迟3秒执行。\n统一随机定时器 它的作用是添加一个随机的时间间隔+一个固定的时间间隔，随机的时间间隔在用户0-值之间随机获取，固定的时间间隔可以看作最小时间，时间单位为毫秒。总的延时 = 固定延迟时间 + 随机生成的延时。\n作用域的逻辑与固定定时器一致。\n示例Jmeter脚本\n测试计划下添加两个线程组、用表格查看结果\n线程组中循环次数配置为：2\n线程组下添加三个HTTP请求取样器\n名称分别为：HTTP请求-1-1、HTTP请求-1-2、HTTP请求-1-3\n请求地址皆为：HTTP://127.0.0.1:5000/GetList/\n请求方式皆为：GET\nHTTP请求-1-2下添加统一随机定时器\n统一随机定时器中配置Random Delay Maximum(随机延迟):3000、Constant Delay Offset(固定延迟):3000\n运行结果\n线程组执行了2次，则HTTP请求-1-2也执行了2次。HTTP请求-1-2的两次执行前延迟是不一致的，第一次是3秒，第二次是4秒，原因就是Random Delay Maximum(随机延迟)导致的。\n同步定时器 它的作用是请求数达到阈值时，同步释放请求，保证取样器在同一时刻向服务器发起负载测试。可以设置模拟用户组的数量、超出时间，对并发量及等待时间进行控制，如果线程未达到模拟用户组的数量，它就会一致等待，此时就可以配置超出时间，等待超出时间后，将线程同步释放。\n但是请注意，释放请求时可能会因为主机的性能限制不能同时释放，事实上导致释放时间不一致。解决办法就是购置高性能主机或布置多个从机。\n不配置同步定时器 示例Jmeter脚本\n测试计划下添加线程组、用表格查看结果\n线程组中线程数配置为：100\n线程组下添加HTTP请求取样器\n请求地址为：HTTP://127.0.0.1:5000/GetList/\n请求方式为：GET\n运行结果\n第1个线程请求与第100个线程请求的执行时间相差1秒左右，线程数越大，则误差越大。\n配置同步定时器 示例Jmeter脚本\n测试计划下添加线程组、用表格查看结果、同步定时器\n同步定时器的模拟用户组数量为：100\n线程组中线程数配置为：100\n线程组下添加HTTP请求取样器\n请求地址为：HTTP://127.0.0.1:5000/GetList/\n请求方式为：GET\n运行结果\n可以看出第1个线程请求与第100个线程请求的执行时间相差几毫秒左右。\n超出时间 示例Jmeter脚本\n测试计划下添加线程组、用表格查看结果、同步定时器\n同步定时器的模拟用户组数量为：9、超出时间为3000\n线程组中线程数配置为：10\n线程组下添加HTTP请求取样器\n请求地址为：HTTP://127.0.0.1:5000/GetList/\n请求方式为：GET\n运行结果\n10个线程，同步定时器在线程数达到9(模拟用户组数量)时，释放这9个请求。剩下的1个，由于达不到9个线程(模拟用户组数量)的要求，只能延迟3秒(超出时间)释放。\n常数吞吐量定时器 此计时器引入了可变暂停，经过计算以使总吞吐量（以每分钟样本数计算）尽可能接近给定数字。当然，如果服务器无法处理，或者其他计时器或耗时的测试元素阻止了吞吐量，则吞吐量会更低。\n目标吞吐量（每分钟的样本量）：单位分钟。比如样本量3000，则吞吐量为500/sec。\n只有此线程 每个线程独立计算吞吐量，比如目标吞吐量：3000样本/分钟，线程数：5，则每个线程将独立尝试保持3000样本/分钟，总吞吐量 = 3000 * 5 = 15000样本/分钟。\n配置示例Jmeter脚本\n测试计划下添加聚合报告、常数吞吐定时器、线程组\n常数吞吐定时器的基于计算吞吐量配置为：此线程、目标吞吐量配置为：60.0\n线程组下添加20个相同的HTTP请求取样器\n线程组的线程数配置为：100\nHTTP请求取样器配置请求地址为：HTTP://127.0.0.1:5000/GetList/\nHTTP请求取样器配置请求方式为：GET\n运行结果\n总的吞吐量=基于吞吐量×线程数，基于吞吐量为每分钟60个-即每秒1个。\n则此次测试的总吞吐量为1×100=100/sec，实际结果与其一致。\n当前线程组中的所有活动线程 线程组内的所有线程共同计算吞吐量，每个线程的吞吐量将基于它上次运行的时间，根据需要延迟调整。\n如果配置为目标吞吐量：3000样本/分钟，线程组的线程数：10，这10个线程将共同实现3000样本/分钟的吞吐量，分配吞吐量并根据每个线程上次运行的时间进行延迟调整。\n配置示例Jmeter脚本\n测试计划下添加聚合报告、常数吞吐定时器、线程组\n常数吞吐定时器的基于计算吞吐量配置为：当前线程组中的所有活动线程、目标吞吐量配置为：60.0\n线程组下添加20个相同的HTTP请求取样器\n线程组的线程数配置为：100\nHTTP请求取样器配置请求地址为：HTTP://127.0.0.1:5000/GetList/\nHTTP请求取样器配置请求方式为：GET\n运行结果\n常数吞吐定时器的基于计算吞吐量配置为：当前线程组中的所有活动线程、目标吞吐量配置为：600(10/sec)\n总的吞吐量=基于吞吐量，基于吞吐量为每分钟60个-即每秒1个。则此次测试的总吞吐量为1×100=100/sec。图中为10.5/sec，好像与图中几乎一致。\n但是请注意，其中是有问题的。\n用表格查看结果表示。好家伙！在48分28秒时，竟然偷偷完成了72个请求的吞吐。在48分29秒时，偷偷完成了43个请求的吞吐。\n后续的吞吐量貌似正常了，其实有很多时间每秒只有7/sec、8/sec或9/sec的吞吐量来补偿前面的72/sec、43/sec。可恶啊！可恶。\n用表格查看结果温馨提示，请谨慎使用当前线程组中的所有活动线程。\n2. 所有活动线程：\r- 目标吞吐量：3000样本/分钟\r- 线程组数：3，每组10个线程\r- 结果：所有30个线程将共同实现3000样本/分钟的吞吐量，每个线程的吞吐量将基于它上次运行的时间，根据需要延迟调整。\r- 注意：每个线程组都需要一个具有相同设置的常数吞吐量定时器。\r3. 所有活动线程（共享）：\r- 目标吞吐量：3000样本/分钟\r- 线程组数：3，每组10个线程\r- 结果：所有30个线程将共同实现3000样本/分钟的吞吐量，每个线程的吞吐量将根据任何线程上次运行的时间而延迟。\r- 注意：每个线程组都需要一个具有相同设置的常数吞吐量定时器。\r4. 当前线程组中的所有活动线程：\r- 目标吞吐量：3000样本/分钟\r- 当前线程组：10个线程\r- 结果：\r5. 当前线程组中的所有活动线程（共享）：\r- 目标吞吐量：3000样本/分钟\r- 当前线程组：10个线程\r- 结果：这10个线程将共同实现3000样本/分钟的吞吐量，分配吞吐量并根据当前线程组中任何线程上次运行的时间进行延迟调整。\r常数吞吐定时器的基于计算吞吐量配置为：当前线程组中的所有活动线程（共享）、目标吞吐量配置为：600(10/sec)\n嗯！很完美的10/sec。\n但有上面的问题吗？\n用表格查看结果表示。呵！一丘之貉。只不过有比当前线程组中的所有活动线程更快、更激烈的补偿，使之不符合目标吞吐量的时间较之大大缩短。\n常数吞吐定时器的基于计算吞吐量配置为：所有活动线程与所有活动线程（共享）用于多线程组。也有着当前线程组中的所有活动线程的问题，就不贴上来了。\n未完待续\n","permalink":"http://192.168.9.98/posts/technology/jmeter/timer1/","summary":"关于定时器(Timer) 定时器（Timer）是一种配置元件，它可在测试计划中的各个请求（Sampler）之间添加延迟或等待时间。可以模拟用户在操作过程中的自然停顿，以及控制请求的发送频率。 以下是JMeter中几种常用的定时器类型： 固定定时器(Constant Timer) 统一随机定时器(Un","title":"Jmeter-定时器"},{"content":"关于监听器 在JMeter中，监听器（Listeners）是用来收集和展示采样器（Samplers）产生的结果数据的元件。它们可以显示测试过程中的响应时间、吞吐量、错误率等信息。JMeter监听器包括：\n查看结果树(View Results Tree)\n汇总报告(Summary Report)\n聚合报告(Aggregate Report)\n后端监听器(Backend Listener)\nJSR223 监听器(JSR223 Listener)\n保存响应到文件(Save Responses to a file)\n响应时间图(Response Time Graph)\n图形结果(Graph Results）\n断言结果(Assertion Results)\n比较断言可视化器(Comparison Assertion Visualizer)\n汇总图(Aggregate Graph)\n生成概要结果(Generate Summary Results)\n用表格查看结果(View Results in Table)\n简单数据写入器(Simple Data Writer)\n邮件观察仪(Mailer Visualizer)\nBeanShell 监听器(BeanShell Listener)\n其实最常用的监听器就是查看结果树、聚合报告、JSR223 监听器，其他监听器特定情况也会用就是了。\n使用示例脚本，需下载示例接口源码并运行。\r查看结果树 该元件显示请求的取样器结果、请求信息、响应信息，可以通过查看结果树中的内容，检查脚本是否有问题，比如IP、端口或者请求数据。还可以检查，响应数据是否正常，常用于接口测试及验证脚本。\n进行性能测试时，它在过程中会消耗大量资源，尽量不要使用。\n结果列表\n绿色代表请求成功，红色代表请求失败(断言未通过也算失败)。\n取样器结果\nThread Name: 执行请求的线程名称，这里是线程组 1-1，表示这是属于线程组1的第1个线程。\nSample Start: 请求开始的时间，格式为年-月-日 时:分:秒，这里是2024-06-14 16:17:12 CST。\nLoad time: 请求的加载时间，包括建立连接、发送请求、接收响应的总时间，这里是2毫秒。\nConnect Time: 建立到服务器的连接所需的时间，这里是1毫秒。\nLatency: 服务器延迟时间，即从发送请求到接收到第一个字节响应的时间，这里是2毫秒。注意这里的延迟时间与连接时间相等，可能是因为这个值已经包含了连接时间。\nSize in bytes: 响应的总字节数，这里是192字节。\nSent bytes: 发送到服务器的请求的字节数，这里是265字节。\nHeaders size in bytes: 响应头的大小，这里是173字节。\nBody size in bytes: 响应体的大小，这里是19字节。\nSample Count: 在这个监听器中捕获的样本数量，这里是1。\nError Count: 遇到的错误数量，这里是0，表示请求成功。\nData type: 响应数据的类型，这里标记为text，表示响应是文本类型。\nResponse code: HTTP响应状态码，200表示请求成功。\nResponse message: HTTP响应消息，OK表示请求被成功处理。\nHTTPSampleResult fields:\nContentType: 响应的MIME类型和字符编码，这里是text/html; charset=utf-8，表示响应是HTML文本，使用UTF-8编码\nDataEncoding: 响应数据的编码，这里也是utf-8。\n请求数据\nConnection: 表示客户端与服务器的连接方式，这里是长连接。\nContent-Length: 表示请求体的长度是15个字节。\nContent-Type: 表示请求体的类型是application/x-www-form-urlencoded，并且使用UTF-8字符编码。\nHost: 指定了请求的目标服务器地址和端口号，这里是本地主机的5000端口。\nUser-Agent: 表示发送请求的客户端软件和版本，这里是Apache HttpClient库，运行在Java环境中。\nPOST http://127.0.0.1:5000/api/QuickUse/: 表示请求方式、URL(包括协议、主机、端口和请求的路径)。\nPOST data:显示请求体中的数据。\n[no cookies]: 这表示请求中没有携带任何Cookie。\n响应数据\nHTTP/1.1 200 OK: 这表示使用的是HTTP协议版本1.1，并且请求成功，状态码200表示服务器成功处理了请求并返回了所请求的资源。\nServer: 这里表明服务器使用的是Werkzeug服务器软件，版本为3.0.1，运行在Python环境下，Python的版本为3.12.3。\nDate: 表示响应的日期和时间，使用GMT（格林尼治标准时间）。\nContent-Type: 这里表示响应的内容类型是HTML，字符编码是UTF-8。\nContent-Length: 表示响应体的字节长度是19字节。\nConnection: close 表示服务器在发送完响应后将关闭连接。这与 Connection: keep-alive 相反，后者表示连接可以保持开启状态以用于发送多个请求。\n请求方式非 GET: 这就是响应体数据。\n所有数据写入一个文件\n建议不要保存文件到C盘，除非以管理员身份运行Jmeter。另外还可以配置日志内容，就请读者自己探究吧。\n这个功能有连个作用：\n配置运行结果保存到那个文件\n通过浏览-打开文件，可以读取文件的数据，在对应的监听器中显示数据。\n所有监听器的所有数据写入一个文件，都是同种作用。\n查找\u0026amp;\u0026amp;结果显示方式\n可以通过查找快速定位请求，支持正则表达式。查找的结果用红色框包裹。\n我自己标记的绿色框，可以选择结果显示方式。还是请读者自己去探究吧。\n汇总报告 可以查看事务或者取样器在某个时间范围内执行的汇总结果，一个取样器或事务占一行。数据包括样本(请求量)、平均值、最小值、最大值、标准偏差、异常%(错误请求)、吞吐量、接受KB/sec、发送KB/sec、平均字节数。\nLable：每个请求的名称。每个 JMeter 的 element(例如 HTTP Request)都有一个 Name 属性，这里显示的就是 Name 属性的值。\n样本（Samples）：取样器请求的数量。\n平均值（Average）：请求（事务）的平均响应时间。\n最小值（Min）：请求的最小响应时间。\n最大值（Max）：请求的最大响应时间。\n标准偏差（Std.Dev）： 响应时间的标准方差。\n异常 %（Error）：请求的错误率 = 错误请求的数量/请求的总数。\n吞吐量（Throughput）：默认情况下表示每秒完成的请求数，一般认为它为TPS。（ 注意单位的变化，如上图中，当TPS很低时，jmeter中默认会统计成每分钟的值，这时我们需要换算成以秒为单位）。当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数。\n接收 KB/sec（Received KB/sec）：每秒接收的千字节数。\n发送 KB/sec（Sent KB/sec）：每秒发送的千字节数。\n平均字节数（Avg.Bytes）：取样结果返回的平均大小。\n还可以保存数据到文件及保存表格数据。\n聚合报告 聚合报告与汇总报告类似，较于汇总报告更占用主机资源。数据包括样本(请求量)、平均值、中位数、90%百分位、95%百分位、99%百分位、最小值、最大值、异常%(错误请求)、吞吐量、接受KB/sec、发送KB/sec。\nLabel：Label：每个请求的名称。每个 JMeter 的 element(例如 HTTP Request)都有一个 Name 属性，这里显示的就是 Name 属性的值\n样本（Samples）：各请求发出的数量。表示你这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100\n平均值（Average：平均响应时间（单位：毫秒）。默认是单个Request的平均响应时间，当使用了Transaction Controller时，也可以以Transaction为单位显示平均响应时间。值 = 总运行时间 / 发送到服务器的总请求数\n中位数（Median）：50%用户的响应时间在小于该值，注意它与average平均响应时间的区别\n90%百分位：90%用户的响应时间小于该值，90%line是性能测试中比较重要的一个衡量指标。\n95%百分位：95%用户的响应时间小于该值\n99%百分位：99%用户的响应时间小于该值\n最小值（Min）：请求的最小响应时间\n最大值（Max）：请求的最大响应时间\n异常 %（Error）：请求的错误率 = 错误请求的数量/请求的总数\n吞吐量（Throughput）：默认情况下表示每秒完成的请求数，一般认为它为TPS。（注意单位的变化，如上图中，当TPS很低时，jmeter中默认会统计成每分钟的值，这时我们需要换算成以秒为单位）。当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数\n接收 KB/sec（Received KB/sec）：每秒接收的千字节数\n发送 KB/sec（Sent KB/sec）：每秒发送的千字节数\n还可以保存数据到文件及保存表格数据。另外可以访问百分位数了解概念。\n后端监听器 在Apache JMeter中，后端监听器（Backend Listener）是用于将测试结果实时发送到外部数据存储或监控系统的一种组件。它常用于将性能测试结果发送到外部系统，如Grafana、InfluxDB、ElasticSearch等数据库，以便实时监控和分析性能测试的结果。\n在“后端监听器”组件中，选择“Backend Listener Implementation”（后端监听器实现）类型。常见的实现有： org.apache.jmeter.visualizers.backend.influxdb.InfluxdbBackendListenerClient：发送数据到InfluxDB。 org.apache.jmeter.visualizers.backend.graphite.GraphiteBackendListenerClient：发送数据到Graphite。\n根据选择的实现类型，填写相应的配置信息，如数据库URL、用户名、密码等。\n比如配置InfluxDB后端监听器：\n选择InfluxdbBackendListenerClient作为实现类。\ninfluxdbMetricsSender: 默认值就行。\ninfluxdbUrl: InfluxDB的URL，例如http://localhost:8086/write?db=jmeter。\napplication: 应用名称，用于区分不同的应用或测试。\nmeasurement: 数据表名。\nsummaryOnly: 是否只发送汇总数据，默认false。\nsamplersRegex: 正则表达式，用于匹配要发送的采样器名称，默认是“.*”表示所有采样器。\npercentiles: 需要记录的百分位数，默认是90,95,99。\n启动InfluxDB和Grafana（如果使用这些工具）：\n确保InfluxDB和Grafana已启动并配置正确。\n在InfluxDB中创建一个数据库，用于存储JMeter发送的数据。\n在Grafana中配置一个数据源，指向InfluxDB数据库，并创建仪表盘用于展示数据。\n运行JMeter测试：\n启动JMeter测试计划。\n在Grafana或其他监控工具中查看实时性能测试结果，分析系统的性能表现。\n可以访问github开源JMeter后端监听器了解并使用更多方便、强大的后端监听器方案。\nJSR223 监听器 它允许用户通过自定义脚本来处理采样器的结果数据，使用的主要目的是数据存储、实时监控和报警。JSR223监听器支持多种脚本语言，如Groovy、JavaScript、BeanShell等，提供了很大的灵活性来执行复杂的数据处理和结果分析任务。\n示例\n选择脚本语言Groovy。\n在“脚本”区域中，编写脚本代码。\nimport org.apache.jmeter.samplers.SampleResult import java.nio.file.Files import java.nio.file.Paths import java.nio.file.StandardOpenOption // 获取当前采样器的结果 SampleResult sampleResult = prev // 获取采样器名称 String samplerName = sampleResult.getSampleLabel() // 获取响应时间 long responseTime = sampleResult.getTime() // 获取响应数据 String responseData = sampleResult.getResponseDataAsString() // 获取响应状态 boolean success = sampleResult.isSuccessful() // 构造日志信息 String logMessage = \u0026#34;Sampler: ${samplerName}, Response Time: ${responseTime}ms, Success: ${success}, Response Data: ${responseData}\\n\u0026#34; // 定义日志文件路径 String logFilePath = \u0026#34;D:\\logfile.log\u0026#34; // 将日志信息写入文件 Files.write(Paths.get(logFilePath), logMessage.getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND) 输出的logfile.log文件\n当然你也可以在脚本中将结果数据传递到数据库或其他服务系统进行处理，或者直接进行处理。不过这会消耗主机资源，需要做好取舍。\n自定义参数\n你可以通过参数，其他元件（比如用户定义的变量、Jmeter-CSV Data Set Config、函数等）传递数据给脚本。\n参数中输入jiang 1（空格分割，值可以是列表、元组等）\n添加用户定义的变量\n修改上述脚本\n// 新增获取自定义参数，自定义参数会保存到args变量(列表)， String name = args[0] String number = args[1] // 构造日志信息,新增name，number, class, random。random是随机函数。 String logMessage = \u0026#34;Sampler: ${samplerName}, Response Time: ${responseTime}ms, Success: ${success}, Response Data: ${responseData}, name: ${name}, number: ${number}, class: ${class}, random: ${__Random(111111,222222,)}\\n\u0026#34; 输出的logfile.log文件\nname，number, class, random的值都被输出到logfile.log文件中了。\n脚本文件（覆盖脚本）\n符合字面意思，引用脚本文件会覆盖脚本内容。\n把示例脚本内容添加到空白的test.groovy文件中\n引用test.groovy`\n删除logfile.log文件\n输出的logfile.log文件\nname，number, class, random的值不再输出，因为执行的是test.groovy脚本。\n你也可以通过脚本实现阈值功能，比如错误率达到一定值时，自动停止测试。不过在这里我就不再过多阐述，读者可以自己探究。\n保存响应到文件 当结果太大，使用结果树监听器影响图形模式时，我们可以采用响应保存监听器来处理，可以将结果树数据保存到文件。\nSave Successful Responses only：仅保存成功响应。\nSave Failed Responses only：仅保存失败响应。\nDon’t save Transaction Controller SampleResult：不保存事务控制器样本结果。\n文件前缀：文件路径 + 文件前缀。\nDon’t add number to prefix：不添加数字到文件前缀。\nDon’t add content type suffix：不添加文件的后缀类型。\nAdd timestamp：添加时间戳到文件前缀。\nMinimum Length of sequence number：设置文件名称最小的序列号；例如4，文件序号为0001…。\n示例Jmeter\n文件前缀：D:\\Results\\Results1\n线程组线程数：200\n请求地址：HTTP://127.0.0.1:5000/GetList/\n请求方式：GET\n运行后结果\n一个请求结果独立一个文件。\n响应时间图 响应时间图是一个直方图，其中 X 轴表示时间，Y 轴表示响应时间。\n响应时间：就是一个请求从发送到接收到响应的总时间。在图中，每个数据点的Y坐标表示请求响应时间。\n时间：测试计划运行的持续时间。在图中，每个数据点的X坐标表示请求开始的时间。\n分布：数据点在图中的分布，可以分析出响应时间的变化。如果数据点在一条线附近，那么响应时间可能比较稳定。如果数据点在图中的分布比较广，那么响应时间可能有比较大的波动。\n趋势：我们也可以通过响应时间图来观察响应时间的趋势。例如，如果数据点从左至右逐渐上升，那么可能表明随着时间的推移，响应时间在增加。\n其余参数\n时间间隔关系X轴的显示。其它参数都是改变显示方式，如字体。读者可自行探究。\n断言结果 文本显示所有请求名称，如果断言失败，名称下方显示失败原因，成功则不显示。消耗资源较多，且我认为意义不大。\n比较断言可视化器 显示请求断言情况，若断言失败，标红。但无法给出断言信息。\n汇总图 较于汇总报告，多了柱形图功能。列可显示平均值、中位数、90%百分位、95%百分位、99%百分位、最小值、最大值。\n生成概要结果 生成概要结果没有配置参数。生成结果需要在Jmeter日志或者Jmeter-cmd窗口查看。\nin：TPS，每秒取样器执行的数量。\nAvg：平均值。平均响应时间，所有请求的平均响应时间，单位是毫秒。\nMin：最小值。请求的最小响应时间。\nMax：最大值。请求的最大响应时间。\nErr：异常百分比。（错误请求的数量/请求的总数)。\n用表格查看结果 与查看结果树不同，此元件将结果写进表格中，可查看数据也不同。不过都能查看各个请求结果状态。\nSample#：请求序号。\nStart Time：请求开始时间。\nThread Name：线程名称。\nLabel：请求的名称（实际请求中可使用参数化对每个请求做区分）。\nSample Time(ms)：请求的响应时间。\nStatus：请求状态，为勾则表示成功，为叉表示失败。\nBytes：响应的字节数及请求的字节数。\nSent Bytes：发送的字节数。\nLatency：延迟时间（单位：毫秒）。\nConnect Time(ms)：连接服务器的时间。（单位：毫秒）。\n样本数目：所有的请求个数。\n平均：所有请求的平均响应时间。（单位：毫秒）。\n最新样本：最新样本响应时间，表示服务器响应最后一个请求的时间。（单位：毫秒）。\n偏离：不知道怎么算的，不发表意见。\n简单数据写入器 使用该元件，需要在所有数据写入一个文件配置文件路径(建议保存到D盘)。运行后，数据就会保存到文件中。然后可以使用查看结果树、聚合报告、图形结果等查看数据。\n邮件观察仪 主要是做提示用。可以自定义请求成功或失败的次数阈值，触发后就会自动发送邮件。\n需要配置发送人、收件人以及SMTP server。\nFrom：发件人邮箱。\nAddressee(s)：收件人邮箱。\nSuccess Subject：成功的请求数达到阈值后，要发送的信息。\nFailure Subject：失败的请求数达到阈值后，要发送的信息。\nSuccess Limit：成功的请求数阈值。如果不想发送，可以将值设未极大，如10000000。\nFailure Limit：失败的请求数阈值。如果不想发送，可以将值设未极大，如10000000。\nHost：SMTP服务器的域名或IP。\nPort：SMTP服务器的端口号。\nLogin：发件人邮箱账号，一般为发件人邮箱。\nPassword：发件人的授权密码。\n163邮箱为例，在设置中获取：\nCommection security：连接协议。一般都是SSl，以SMTP服务器指定协议为准。\n收件人收到的邮件\nBeanShell 监听器 BeanShell 监听器类似JSR223 监听器。只不过BeanShell 监听器只可以使用BeanShell语言。\n如果会使用JSR223 监听器，那么BeanShell 监听器也没问题。本质上都是编写脚本。\n图形结果 这个可以不用了解，消耗资源多且生成的图表质量不高。\n","permalink":"http://192.168.9.98/posts/technology/jmeter/listener/","summary":"关于监听器 在JMeter中，监听器（Listeners）是用来收集和展示采样器（Samplers）产生的结果数据的元件。它们可以显示测试过程中的响应时间、吞吐量、错误率等信息。JMeter监听器包括： 查看结果树(View Results Tree) 汇总报告(Summary Report) 聚合报告(Aggregate Report)","title":"Jmeter-监听器"},{"content":"\r背景 我负责的一个项目经过长时间的开发，终于在客户现场正式运行了。 虽然正式运行前的很长一段时间里我一直在计划进行一次性能测试，但由于各种原因，测试一直没有进行。 我们的运维人员在正式运行前进行了试运行，结果在一定数量的并发下，硬盘顶不住，系统直接卡死了。 我就进行了一次性能测试。\n本文记录了我的大概测试思路及方法。\n影响项目性能的因素分析 这个项目的主要功能是对监控设备的视频流进行切片、存储，然后生成URL供平台调阅。它主要分为两个部分，切片系统、存储系统。项目中，不同存储方式导致项目架构不同。\n项目提供3中存储方式——本地存储、S3接口存储、智能云存储。其中，S3接口存储、智能云存储需额外配置存储服务器，与切片服务器分开，切片视频文件放在存储服务器中； 本地存储则不需额外配置存储服务器，直接把切片视频文件放在切片服务器中。\n进行性能测试，首先要知道影响项目性能的因素有那些。与研发沟通后，确定切片系统需关注cpu使用率、平均负载、内存使用。存储系统需关注存储cpu使用率、内存使用率、平均负载、系统读写带宽信息、硬盘读写带宽信息。 非本地存储时，还需关注切片服务器与存储服务器之间的网络宽带信息。\n策划初步测试方案 首先需要明确，此项目主要功能的流程。\n由此初步策划出两套测试方案\n第一套\n使用Jmeter下发切片指令，切片服务器中使用top命令获取切片服务器切片过程中的cpu、平均负载、内存等信息\n切片完成后。存储服务器中使用top命令获取切片视频存储过程中的cpu、平均负载、内存等信息，使用iostat命令获取切片视频存储过程中存储服务器存储过程中的硬盘信息；切片服务器中使用nload命令获取切片视频存储过程中的网络传输信息\n分析并整理获取到的所有信息\n制作成结果图表\n第二套\n使用Jmeter下发切片指令后，切片服务器中使用top命令获取切片服务器中的cpu、平均负载、内存等信息，使用iostat命令获取切片服务器存储过程中的硬盘信息\n分析并整理获取到的所有信息（分出切片、存储两个时间段）\n制作成结果图表\n搭建测试方案所需环境 以第一套为例：\n准备切片服务器\n服务器系统使用Linux系统\n服务器中部署切片服务\n服务器中安装iostat、nload\n准备存储服务器\n服务器中部署存储服务\n服务器中安装iostat\n编写服务器脚本，获取服务器信息\n服务器中编写所需top、iostat、nload脚本命令\n#!/bin/bash # top脚本，用于切片服务器、存储服务器 # 总循环时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 记录开始时间 start_time=$(date +%s) # 循环直到达到总时间 while true; do # 计算当前时间与开始时间的差值（秒） current_time=$(date +%s) elapsed_time=$((current_time - start_time)) # 如果已经达到或超过总时间，则退出循环 if [ $elapsed_time -ge $total_time ]; then break fi # 执行提供的命令 top -n 1 -b | head -n 6 \u0026gt;\u0026gt; /top.log # 睡眠2秒 sleep 2 done #!/bin/bash # iostat脚本，用于切片服务器、存储服务器 # 总持续时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 记录开始时间 start_time=$(date +%s) # 启动 iostat命令 并将输出重定向到日志文件，同时将其放入后台运行，根据需要写iostat。 (iostat -x -m -t 2 \u0026gt; /iostat.log) \u0026amp; # 保存 nload 的进程ID PID=$! # 等待$1秒 sleep $1 # 终止 iostat 进程 kill $PID #!/bin/bash # nload脚本，用于切片服务器 # 总持续时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 启动 nload 并将输出重定向到日志文件，同时将其放入后台运行 (nload eno1 -u M -m -t 1500 \u0026gt; /nload.log) \u0026amp; # 保存 nload 的进程ID PID=$! # 等待60秒 sleep $1 # 终止 nload 进程 kill $PID 使用python编写服务远程执行top、iostat脚本\n主要为了一键自动化，不需要自己手动执行top、iostat脚本。\n思路是，使用Flask实现一个前置服务，Jmeter下发切片指令前请求前置服务，自动远程执行top、iostat等脚本。\n代码如下：\n# Getdata.py import paramiko import time import threading from flask import Blueprint, jsonify, request GetData = Blueprint(\u0026#39;GetData\u0026#39;, __name__, template_folder=\u0026#39;templates\u0026#39;) def create_ssh_client(hostname, port, username, private_key_path): \u0026#34;\u0026#34;\u0026#34;创建并返回一个SSH客户端的辅助函数。\u0026#34;\u0026#34;\u0026#34; private_key = paramiko.RSAKey.from_private_key_file(private_key_path) client = paramiko.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(hostname, port=port, username=username, pkey=private_key) return client def execute_command_async(client, command): \u0026#34;\u0026#34;\u0026#34;在SSH客户端上执行命令的辅助函数。\u0026#34;\u0026#34;\u0026#34; stdin, stdout, stderr = client.exec_command(command) stdout.channel.recv_exit_status() def fetch_files(ssh_client, remote_path, local_path): \u0026#34;\u0026#34;\u0026#34;从远程服务器拉取文件的辅助函数。\u0026#34;\u0026#34;\u0026#34; try: with ssh_client.open_sftp() as sftp_client: sftp_client.get(remote_path, local_path) print(f\u0026#34;成功获取 {remote_path} 到 {local_path}\u0026#34;) except Exception as e: print(f\u0026#34;获取 {remote_path} 时出错: {e}\u0026#34;) def delete_remote_files(client, filenames): \u0026#34;\u0026#34;\u0026#34;删除远程服务器上的文件的辅助函数。\u0026#34;\u0026#34;\u0026#34; for filename in filenames: client.exec_command(f\u0026#39;rm {filename}\u0026#39;) def test165(long, client, hostname_command): \u0026#34;\u0026#34;\u0026#34;切片快结束时，执行存储服务器上的脚本。\u0026#34;\u0026#34;\u0026#34;\ttime.sleep(long - 10) execute_command_async(client, hostname_command) @GetData.route(\u0026#39;/api/GetTop/\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def gettop(): \u0026#34;\u0026#34;\u0026#34;获取切片时长\u0026#34;\u0026#34;\u0026#34; long = int(request.args.get(\u0026#34;time\u0026#34;)) print(long) \u0026#34;\u0026#34;\u0026#34;定义脚本执行时长\u0026#34;\u0026#34;\u0026#34; shi = 600 def background_task(): \u0026#34;\u0026#34;\u0026#34;定义服务器的信息\u0026#34;\u0026#34;\u0026#34; hostname1 = \u0026#39;192.168.1.111\u0026#39; hostname2 = \u0026#39;192.168.1.112\u0026#39; port = 22 username = \u0026#39;root\u0026#39; private_key_path = r\u0026#34;C:\\Users\\Ethereal Jiang\\.ssh\\id_rsa\u0026#34; \u0026#34;\u0026#34;\u0026#34;实例化ssh客户端并执行脚本命令。使用多线程是两个服务器互不影响。\u0026#34;\u0026#34;\u0026#34; client1 = None client2 = None try: client1 = create_ssh_client(hostname1, port, username, private_key_path) client2 = create_ssh_client(hostname2, port, username, private_key_path) hostname1_command = f\u0026#39;bash /opt/top_start.sh {long + shi} \u0026amp; bash /opt/iostat_start.sh {long + shi}\u0026#39; hostname2_command = f\u0026#39;bash /opt/top_start.sh {shi} \u0026amp; bash /opt/iostat_start.sh {shi}\u0026#39; thread1 = threading.Thread(target=execute_command_async, args=(client1, hostname1_command)) thread2 = threading.Thread(target=test165, args=(long, client2, hostname2_command)) thread1.start() thread2.start() thread1.join() thread2.join() except Exception as e: print(f\u0026#34;An error occurred: {e}\u0026#34;) finally: if not client1: client1 = create_ssh_client(hostname1, port, username, private_key_path) if not client2: client2 = create_ssh_client(hostname1, port, username, private_key_path) fetch_files(client2, \u0026#39;/top.log\u0026#39;, \u0026#39;D:\\\\test\\\\165\\\\top.log\u0026#39;) fetch_files(client2, \u0026#39;/iostat.log\u0026#39;, \u0026#39;D:\\\\test\\\\165\\\\iostat.log\u0026#39;) delete_remote_files(client2, [\u0026#39;/top.log\u0026#39;, \u0026#39;/iostat.log\u0026#39;]) fetch_files(client1, \u0026#39;/top.log\u0026#39;, \u0026#39;D:\\\\test\\\\169\\\\top.log\u0026#39;) fetch_files(client1, \u0026#39;/iostat.log\u0026#39;, \u0026#39;D:\\\\test\\\\169\\\\iostat.log\u0026#39;) delete_remote_files(client1, [\u0026#39;/top.log\u0026#39;, \u0026#39;/iostat.log\u0026#39;]) if client1: client1.close() if client2: client2.close() print(\u0026#39;结束\u0026#39; + str(time.time())) task_thread = threading.Thread(target=background_task) task_thread.start() return jsonify({\u0026#34;status\u0026#34;: \u0026#34;任务已开始在后台处理\u0026#34;}), 202 # app.py from flask import Flask from Getdata import GetData app = Flask(__name__) app.secret_key = \u0026#39;jiang\u0026#39; app.register_blueprint(GetData) if __name__ == \u0026#39;__main__\u0026#39;: app.run() 编写Jmeter脚本，下发切片指令\n运行脚本后，首先会请求前置服务，执行服务器脚本，然后，开始并发切片指令。结束后，前置服务自动拉取信息文件到本地。\n测试结束后后，分析、整理本地数据 每次并发测试三轮，信息文件放在对应的文件夹中。使用Notepad++和WPS表格处理数据。\nNotepad++查询复制数据，WPS表格分列数据\n将分析整理后的数据制作成图表 我使用的是cdn库的Chart.js，还是比较强的，可以访问Chart.js学习使用。示例如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;性能测试\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.net/Chart.js/3.9.1/chart.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { background: #9e9e9e1a; margin: 0; /* 移除默认的外边距 */ } .card { padding: 0 3%; background: #fff; border: 1px solid #dcdee2; border-color: #e8eaec; border-radius: 15px; width: 80%; /* 设置左右边距为自动 */ margin: 2% auto; } .data { margin-top: 2%; margin-bottom: 4%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;data\u0026#34;\u0026gt; \u0026lt;span\u0026gt;5个并发\u0026lt;/span\u0026gt; \u0026lt;canvas id=\u0026#34;c5_169\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;data\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;c5_165\u0026#34; \u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 并发5 const c5_169_Ctx = document.getElementById(\u0026#39;c5_169\u0026#39;); const c5_169_Labels = [\u0026#39;%错误率\u0026#39;, \u0026#39;切片-%CPU最大使用率\u0026#39;, \u0026#39;切片-CPU最大负载(1分钟)\u0026#39;,\u0026#39;切片-内存最大使用-GiB\u0026#39;, \u0026#39;平均宽带速率-MByte/s\u0026#39;, \u0026#39;最小宽带速率-MByte/s\u0026#39;, \u0026#39;最大宽带速率-MByte/s\u0026#39;, \u0026#39;视频总体积-GByte\u0026#39;, \u0026#39;总流程时间(分)\u0026#39;, \u0026#39;存储写入时长(分)\u0026#39;, \u0026#39;存储-%CPU最大使用率\u0026#39;, \u0026#39;存储-CPU最大负载(1分钟)\u0026#39;, \u0026#39;存储-内存最大使用率-GiB\u0026#39; ]; // 设置 X 轴上对应的标签 const c5_169_Data = { labels: c5_169_Labels, datasets: [{ label: \u0026#39;结果\u0026#39;, data: [0, 11.16666667, 0.906666667, 6.707091217, 53.87263617, 8.97, 69.28666667, 1.86, 10.61666667, 0.555555556, 20.66666667, 1.936666667, 24.95719945], backgroundColor: [ \u0026#39;rgba(255, 99, 132, 0.2)\u0026#39;, // 粉色 \u0026#39;rgba(255, 159, 64, 0.2)\u0026#39;, // 橙色 \u0026#39;rgba(255, 205, 86, 0.2)\u0026#39;, // 浅黄色 \u0026#39;rgba(75, 192, 192, 0.2)\u0026#39;, // 青绿色 \u0026#39;rgba(153, 102, 255, 0.2)\u0026#39;, // 紫罗兰 \u0026#39;rgba(255, 206, 86, 0.2)\u0026#39;, // 金色 \u0026#39;rgba(75, 191, 92, 0.2)\u0026#39;, // 橄榄绿 \u0026#39;rgba(120, 75, 192, 0.2)\u0026#39;, // 深紫罗兰 \u0026#39;rgba(255, 92, 159, 0.2)\u0026#39;, // 品红色 \u0026#39;rgba(92, 255, 206, 0.2)\u0026#39;, // 浅绿松石色 \u0026#39;rgba(206, 92, 255, 0.2)\u0026#39;, // 浅洋红色 \u0026#39;rgba(159, 255, 92, 0.2)\u0026#39;, // 浅黄色绿色 \u0026#39;rgba(102, 86, 255, 0.2)\u0026#39; // 浅灰蓝色 ], borderColor: [ \u0026#39;rgb(255, 99, 132)\u0026#39;, // 粉色 \u0026#39;rgb(255, 159, 64)\u0026#39;, // 橙色 \u0026#39;rgb(255, 205, 86)\u0026#39;, // 浅黄色 \u0026#39;rgb(75, 192, 192)\u0026#39;, // 青绿色 \u0026#39;rgb(153, 102, 255)\u0026#39;, // 紫罗兰 \u0026#39;rgb(255, 206, 86)\u0026#39;, // 金色 \u0026#39;rgb(75, 191, 92)\u0026#39;, // 橄榄绿 \u0026#39;rgb(120, 75, 192)\u0026#39;, // 深紫罗兰 \u0026#39;rgb(255, 92, 159)\u0026#39;, // 品红色 \u0026#39;rgb(92, 255, 206)\u0026#39;, // 浅绿松石色 \u0026#39;rgb(206, 92, 255)\u0026#39;, // 浅洋红色 \u0026#39;rgb(159, 255, 92)\u0026#39;, // 浅黄色绿色 \u0026#39;rgb(102, 86, 255)\u0026#39; // 浅灰蓝色 ], borderWidth: 1 // 设置线条宽度 }] }; const c5_169_Config = { type: \u0026#39;bar\u0026#39;, // 设置图表类型 data: c5_169_Data, // 设置数据集 options: { scales: { y: { beginAtZero: true // 设置 y 轴从 0 开始 } }, plugins: { title: { display: true, text: \u0026#39;\u0026#39; // 这里设置图表的标题 }, datalabels: { anchor: \u0026#39;end\u0026#39;, align: \u0026#39;top\u0026#39;, formatter: function(value, context) { return value.toFixed(2); // 设置标签格式 } } } }, plugins: [ChartDataLabels] }; const c5_169_Chart = new Chart(c5_169_Ctx, c5_169_Config); const c5_165_ctx = document.getElementById(\u0026#39;c5_165\u0026#39;); const c5_165_labels = [\u0026#39;avg-wMB/s\u0026#39;, \u0026#39;min-wMB/s\u0026#39;, \u0026#39;max-wMB/s\u0026#39;,\u0026#39;avg-w_await\u0026#39;, \u0026#39;min-w_await\u0026#39;, \u0026#39;max-w_await\u0026#39;, \u0026#39;avg-%util\u0026#39;, \u0026#39;min-%util\u0026#39;, \u0026#39;max-%util\u0026#39;]; // 设置 X 轴上对应的标签 const c5_165_data = { labels: c5_165_labels, datasets: [{ label: \u0026#39;sdb\u0026#39;, data: [52.36925926, 5.89, 83.85, 28.26445534, 8.703333333, 59.62, 89.57178649, 28.28333333, 98.7], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }, { label: \u0026#39;sdc\u0026#39;, data: [52.37021786, 6.886666667, 83.69333333, 26.18413943, 7.443333333, 60.51333333, 87.21247277, 23.35, 97.43333333], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }, { label: \u0026#39;sdd\u0026#39;, data: [52.37001089, 6.553333333, 83.18666667, 26.98811547, 8.673333333, 56.51, 89.42472767, 26.16666667, 98.3], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }] }; const c5_165_config = { type: \u0026#39;bar\u0026#39;, // 设置图表类型 data: c5_165_data, // 设置数据集 options: { scales: { y: { beginAtZero: true // 设置 y 轴从 0 开始 } }, plugins: { title: { display: true, text: \u0026#39;存储-硬盘信息\u0026#39; // 这里设置图表的标题 }, datalabels: { anchor: \u0026#39;end\u0026#39;, align: \u0026#39;top\u0026#39;, formatter: function(value, context) { return value.toFixed(2); // 设置标签格式 } } } }, plugins: [ChartDataLabels] }; const c5_165_Chart = new Chart(c5_165_ctx, c5_165_config); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果还是挺好的。\n","permalink":"http://192.168.9.98/posts/technology/essays/performance/","summary":"背景 我负责的一个项目经过长时间的开发，终于在客户现场正式运行了。 虽然正式运行前的很长一段时间里我一直在计划进行一次性能测试，但由于各种原因，测试一直没有进行。 我们的运维人员在正式运行前进行了试运行，结果在一定数量的并发下，硬盘顶不住，系统直接卡死了。 我就进行了一次性能测试。 本文记","title":"记一次性能测试"},{"content":"关于CSV Data Set Config 它允许你从CSV、TXT文件中读取数据，在测试计划的运行过程中将这些数据作为变量使用。这在进行性能测试时非常有用，尤其是当你需要模拟大量用户使用不同的输入数据时。\n通过右键-添加-配置元件-CSV Data Set Config添加，可以添加在测试计划、线程组、取样器下，作用域也随之变化。\n参数包括：\n文件名\n文件编码\n变量名称\n忽略首行\n分隔符\n是否允许带引号？\n遇到文件结束符再次循环\n遇到文件结束符停止线程\n线程共享模式\n使用示例脚本，需下载示例接口源码并运行。 文件名 需输入数据文件的路径，运行时Jmeter会按路径查找数据文件。如果路径错误，Jmeter会报错。\nJMeter提示试图读取一个名为test.txt的文件，但是这个文件不存在或者JMeter没有读取它的权限。\n文件编码 编码是计算机用于表示字符的数字或二进制值。以下是一些常见的编码系统及其特点：\nASCII (American Standard Code for Information Interchange)\n编码范围：0-127 字符集：基本的英文字符、数字、标点符号和控制字符 Extended ASCII\n编码范围：128-255 字符集：在ASCII基础上扩展，包含其他语言的字符 ISO 8859-1 (Latin-1 Character Set)\n编码范围：0-255 字符集：扩展了ASCII，包括西欧语言的特殊字符 UTF-8 (Unicode Transformation Format - 8-bit)\n编码范围：1-4字节 字符集：支持全球几乎所有语言的字符，包括表情符号等 UTF-16 (Unicode Transformation Format - 16-bit)\n编码范围：2字节（BMP）或4字节（辅助平面） 字符集：同UTF-8，但使用固定长度的字节对 UTF-32 (Unicode Transformation Format - 32-bit)\n编码范围：固定4字节 字符集：同UTF-8和UTF-16，但每个字符固定占用4字节 GBK (Chinese Internal Code Specification)\n编码范围：双字节 字符集：主要用于简体中文 GB2312\n编码范围：单字节和双字节 字符集：主要用于简体中文，是GBK的前身 Big5\n编码范围：双字节 字符集：主要用于繁体中文 Shift_JIS (Shifting Japanese Industrial Standards)\n编码范围：单字节和双字节 字符集：主要用于日文 EUC-JP (Extended Unix Code - Japanese)\n编码范围：多字节 字符集：主要用于日文 KOI8-R (KOI8 Russian)\n编码范围：单字节 字符集：主要用于俄文 这些编码系统各有特点，适用于不同的语言和场景。随着全球化的发展，UTF-8因其兼容性和效率成为了最广泛使用的编码方式。\n推荐使用UTF-8编码，因为它可以表示任何语言的字符，并且是Web标准。几乎所有的现代文本编辑器、浏览器和编程语言都支持UTF-8。如遇到一些UTF-8无法兼容的语言，可以选择或编辑添加其他编码。\n变量名称 数据文件中，1列对应1个变量，从左依次对应。变量名称不应多于列数。每次读取1行。以TXT文件为例：\n111,222,333,444,555,666,777 aaa,bbb,ccc,ddd,eee,fff,ggg 数据文件中有5列，代表有7个变量。\n变量名称可以输入a1,a2,a3,a4,a5,a6,a7，a1获取第1列数据，a7获取第7列数据。a1第1次获取111，a1第2次获取aaa。\n忽略首行 如果数据文件的第一行包含列标题，可以使用此选项跳过第一行，只读取数据。以csv文件为例：\n第1行只是标题，实际上并不需要标题数据。这种情况下可以选择True，不获取第1行。\n分隔符 不建议更改，使用,(英文符)即可。\nTXT文件中列于列之间要用,分隔。\n是否允许带引号 以TXT文件为例：\n\u0026#34;444\u0026#34; 选择True，引用变量时，获取的值会是444。\n选择False，引用变量时，获取的值会是\u0026quot;444\u0026quot;。\n遇到文件结束符再次循环 文件结束符（End Of File，简称EOF）是一个用于表示文件内容结束的信号，在txt、csv等文件的未尾以\u0026lt;EOF\u0026gt;结束。当程序读取文件时，以\u0026lt;EOF\u0026gt;来确定是否已经到达文件的末尾。\n当读取到文件的结束符，线程或循环还没结束时。选择True，接下来的线程或循环会继续从文件的首行开始（可能忽略首行）。选择False，接下来的线程或循环会一直获取文件的结束符\u0026lt;EOF\u0026gt;。\n遇到文件结束符停止线程 当读取到文件的结束符，线程或循环还没结束时。选择True，接下来的线程或循环不会再继续。选择False，不会影响到线程或循环的继续。\n线程共享模式 其提供了多种模式来指定如何使用数据文件，模式共有：\n所有线程\n当前线程组\n当前线程\n我们可以使用txt文件作为数据文件，文件内容如下：\n111,222,333,444 aaa,bbb,ccc,ddd 888,999,1010,2020 fff,iii,jjj,kkk 6060,7070,8080,9090 000,ppp,qqq,rrr 所有线程 默认的共享模式，所有线程共享同一个CSV文件，所有线程将按照执行顺序依次读取CSV文件中每一行的数据(一个线程一行数据)，直到文件结束。\n示例Jmeter脚本\n测试计划下添加查看结果树、CSV 数据文件设置、线程组1、线程组2\nCSV 数据文件设置中配置参数\n文件名：txt文件的路径\n文件编码：UTF-8\n变量名称：a,b,c,d\n线程共享模式：所有线程\n线程组1下添加HTTP请求-1、HTTP请求-2\n线程组2下添加HTTP请求-3、HTTP请求-4\n所有取样器的请求地址：HTTP://127.0.0.1:5000/GetList/\n所有取样器的请求方式：GET\nHTTP请求-1中添加参数。名称1：a值1：${a}；名称2：b，值2：${b}\nHTTP请求-2中添加参数。名称1：c值1：${c}；名称2：d，值2：${d}\nHTTP请求-3中添加参数。名称1：a值1：${a}；名称2：b，值2：${b}\nHTTP请求-4中添加参数。名称1：c值1：${c}；名称2：d，值2：${d}\n线程组下的请求同属一个线程(比如请求1、请求2同属一个线程)，从CSV Data Set Config中所获取的数据是一样的。\n运行结果\n线程：线程组1 1-1的执行时间比线程：线程组2 2-1早，所以线程：线程组1 1-1会获取txt文件第一行的数据，即HTTP请求-1获取111、222；HTTP请求-2获取333、444。\n则HTTP请求-3获取aaa、bbb；HTTP请求-4获取ccc、ddd，获取第二行数据。\n若这两个线程组分别有多个线程，而且文件中的数据足够多，所有的线程按照执行顺序依次获取每行数据。\n当前线程组 该模式下，只有同一个线程组内的线程会共享CSV文件。比如数据文件有10行数据，并且有10个线程在同一个线程组中，每个线程将分别读取一行数据。不同的线程组分别独立从CSV Data Set Config获取数据。\n示例Jmeter脚本\n测试计划下添加查看结果树、CSV 数据文件设置、线程组1、线程组2\nCSV 数据文件设置中配置参数\n文件名：txt文件的路径\n文件编码：UTF-8\n变量名称：a,b,c,d\n线程共享模式：所有线程\n线程组1、线程组2的线程数配置为：2\n线程组1下添加HTTP请求-1、HTTP请求-2\n线程组2下添加HTTP请求-3、HTTP请求-4\n所有取样器的请求地址：HTTP://127.0.0.1:5000/GetList/\n所有取样器的请求方式：GET\nHTTP请求-1中添加参数。名称1：a值1：${a}；名称2：b，值2：${b}\nHTTP请求-2中添加参数。名称1：c值1：${c}；名称2：d，值2：${d}\nHTTP请求-3中添加参数。名称1：a值1：${a}；名称2：b，值2：${b}\nHTTP请求-4中添加参数。名称1：c值1：${c}；名称2：d，值2：${d}\n运行结果\n同线程组的两个线程，分别获取文件中第一行、第二行的数据。线程：线程组1 1-1获取第一行数据，线程：线程组1 1-2获取第二行数据。\n不同线程组之间互相独立。线程：线程组1 1-1获取第一行数据，线程：线程组2 2-1都获取第一行数据。\n当前线程 该模式下，各个线程相互独立，分别独立从CSV Data Set Config获取数据。\n示例Jmeter脚本\n测试计划下添加查看结果树、CSV 数据文件设置、线程组1、线程组2\nCSV 数据文件设置中配置参数\n文件名：txt文件的路径\n文件编码：UTF-8\n变量名称：a,b,c,d\n线程共享模式：当前线程\n线程组1、线程组2的线程数配置为：2\n线程组1下添加HTTP请求-1\n线程组2下添加HTTP请求-2\n所有取样器的请求地址：HTTP://127.0.0.1:5000/GetList/\n所有取样器的请求方式：GET\nHTTP请求-1中添加参数。名称1：a值1：${a}；名称2：b，值2：${b}\nHTTP请求-2中添加参数。名称1：a值1：${a}；名称2：b，值2：${b}\n运行结果\n所有线程都获取第一行数据了。\n循环 另外在使用CSV Data Set Config时，还需注意循环次数。\n配置所有线程，如果有2个线程组、这两个线程组都是2个线程，线程组(A)有3次循环\n执行时，首先两个线程组共四个线程获取文件的前四行数据，然后线程组(A)第二次循环获取第五、六行数据，线程组(A)第三次循环获取第七、八行数据后结束。\n配置当前线程组，如果有2个线程组、这两个线程组都是2个线程，线程组(A)有3次循环\n执行时，首先线程组相互独立，两个线程组的两个线程都从数据文件中获取前两行数据，然后线程组(A)第二次循环获取第三、四行数据，线程组(A)第三次循环获取第五、六行数据后结束。\n配置当前线程，如果有2个线程组、这两个线程组都是2个线程，线程组(A)有3次循环\n执行时，首先各个线程相互独立，两个线程组共四个线程都从数据文件中获取第一行数据，然后线程组(A)第二次循环的两个线程都获取第二行数据，线程组(A)第三次循环的两个线程都获取第三行数据。\n编辑 其中忽略首行、是否允许带引号、遇到文件结束符再次循环、遇到文件结束符停止线程、线程共享模式的选项中还有编辑选项，因未使用过，我并不知怎样使用，读者们可以去探究一番。\n","permalink":"http://192.168.9.98/posts/technology/jmeter/csvdatasetconfig/","summary":"关于CSV Data Set Config 它允许你从CSV、TXT文件中读取数据，在测试计划的运行过程中将这些数据作为变量使用。这在进行性能测试时非常有用，尤其是当你需要模拟大量用户使用不同的输入数据时。 通过右键-添加-配置元件-CSV Data Set Config添加，可以添加在测试计划、线程组、取样器下，作用域也随","title":"Jmeter-CSV Data Set Config"},{"content":"\r背景 咱们有时不得不自己去搭建一个测试环境，保证自己的测试可以顺畅进行。测试环境可以运行在物理机或者虚拟机上。测试环境在物理机上无疑更真实、准确，但物理机价格、便捷方面都不如虚拟机，而且虚拟机通过精心搭配，真实、准确方面也不容小觑。\n现在市面上的虚拟机软件不少。如Vmware、VirtualBox、QEMU、Parallels Desktop、Microsoft Hyper-V等。那为什么推荐VMware呢？因为只用过它😅。无论如何，开始我们的VMware之旅吧。\n准备VMware 下载VMware\n官网下载地址，需账号登录\n根据自己的系统去下载对应版本\n请注意这里下载的是Pro版本，是收费的。你也可以去下载免费版本，或者去搜激活码来进行激活。不过你懂的，我不提供方法。\n安装VMware\n下载成功后，双击安装后一直下一步就行。然后界面如下：\n我这里已经搭建了2个虚拟机了，你们刚进去的时候，是没有这两个虚拟机的。\n新建虚拟机 此时一个虚拟机就搭建好了。图中的测试安装centos 7\n设置虚拟机 后面还需对虚拟机进行一些设置，才能达成目的。\n有关网络连接的知识可以访问使用 VMware Workstation Pro进行了解。\n运行虚拟机 点击运行虚拟机后，VMware开始运行ISO镜像文件。然后就是各个系统经典的初始化界面。我这里以centos 7 为例。\n以上示例的是centos7。需要知道的是，每个系统的初始化界面可能有区别。比如windows一定与centos 7不同。\n网络配置 此时安装好的centos 7还不能访问inter网、局域网，甚至主机。要访问其他网络，需要进行一些配置。我们以桥接模式为例。\nVMware上进行设置\ncentos 7上进行配置\n查看网口信息\n# 查看网口信息 ip link # 示例centos 7，输出信息如下： 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: ens33: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:0c:29:cf:f0:d8 brd ff:ff:ff:ff:ff:ff 输出的网口信息有lo、ens33.\nlo 是本地回环接口，通常用于本地主机上的网络服务。它总是激活的，并且可以用于本地主机上的网络请求。\nens33 是一个以太网接口。这个接口是连接到物理网络的，但是当前的输出并没有显示IP地址分配情况。\n编辑网络配置文件。\n# 编辑ens33的配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置网络接口\n# 只需要自动分配IP就行。修改以下配置。 BOOTPROTO=dhcp ONBOOT=yes 重启网络服务：\n# 保存并关闭配置文件，然后重启网络服务以应用更改 sudo systemctl restart network 验证网络配置\n# 使用ping命令测试网络连接 ping -c 4 8.8.8.8 # 使用ip addr 检查IP地址 ip addr 远程连接\n使用MobaXterm远程。\n如果远程失败，可以使用systemctl stop firewalld关闭防火墙，再远程。\n","permalink":"http://192.168.9.98/posts/technology/essays/vmware/","summary":"背景 咱们有时不得不自己去搭建一个测试环境，保证自己的测试可以顺畅进行。测试环境可以运行在物理机或者虚拟机上。测试环境在物理机上无疑更真实、准确，但物理机价格、便捷方面都不如虚拟机，而且虚拟机通过精心搭配，真实、准确方面也不容小觑。 现在市面上的虚拟机软件不少。如Vmware、Vir","title":"使用VMware搭建测试环境"},{"content":"关于HTTP请求取样器 JMeter提供多种取样器，HTTP取样器（HTTP Sampler）无疑是最核心的一个。HTTP取样器是用来模拟客户端和服务器之间HTTP请求和接收响应的工具，可以发送各种类型的HTTP请求，如GET、POST、PUT、DELETE等。\nHTTP取样器控制面板中包含元素：\n名称、注释\nweb服务器\nHTTP请求\n参数\n消息体数据\n文件上传\n客户端实现\n超时\n从HTML文件获取所有内含的资源\n源地址\n代理服务器\n其他任务\n使用示例脚本，需下载示例接口源码并运行。 web服务器 确保IP/域名、端口协议正确无误。\nHTTP请求 确保请求方式、路径正确无误。内容编码最好输入UTF-8(基本兼容全部语言)，防止接口解析时乱码。\n跟随重定向 HTTP请求取样器的默认选择。Jmeter会对状态码302、30X的响应，重定向新的地址，勾选跟随重定向时，Jmeter会记录重定向过程内容（可在查看结果树中查看）。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTPS://www.zhihu.com\n取样器的请求方式：GET\n运行结果\nHTTP请求从开始到结束，有两步。第一步是请求HTTPS://www.zhihu.com，知乎响应一个重定向链接：//www.zhihu.com/signin?next=%2F。第二步就是重定向至链接。Jmeter会记录重定向过程内容。\n自动重定向 勾选自动重定向时，Jmeter不会记录重定向过程内容。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\nHTTP请求取样器中勾选自动重定向\n取样器的请求地址：HTTPS://www.zhihu.com\n取样器的请求方式：GET\n运行结果\n这次就没有记录重定向过程内容了。\n使用KeepAlive 选中该选项，JMeter和目标服务器之间使用Keep-Alive方式进行HTTP通信，默认选中。keep-alive属性，用于建立长连接，可以避免连接频繁建立和释放的开销。有兴趣的可以搜索HTTP的Keep-Alive模式，详细了解。\n与浏览器兼容的头 没有发现有什么作用。希望有知道的读者可以评论。\nGET请求 GET请求，请求参数一般都直接跟在url后面，没有参数类型。当然也可以请求参数不跟在url后面，不过比较少见。\n路径传参 示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/GET/?data=请求地址传参\n取样器的请求方式：GET\n运行结果\n请求数据中标红部分-GET http://127.0.0.1:5000/GET/?data=请求地址传参中的data=请求地址传参就是传的参数。\n参数传参 示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：`HTTP://127.0.0.1:5000/GET/\n取样器的请求方式：GET\n取样器下的参数中添加参数，名称为：data，值为：请求地址传参\n运行结果\n结果与使用路径传参时一样。\n消息体传参 示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/GET_DATA/\n取样器的请求方式：GET\n取样器下的消息体中添加参数：消息体传参\n运行结果\n请求数据中标红部分-GET data中的数据代表我们成功传参消息体参数，Jmeter还自动指定了参数类型为：text/plain（Jmeter会默认文本）。\n不仅文本，还可以传参json、xml、html等格式内容，但需要使用消息头管理器指定对应参数类型。\n文件上传 GET请求本身不支持文件上传，但可以使用 BeanShell 脚本处理文件下载和上传。比如下面的脚本：\nimport java.nio.file.Files; import java.nio.file.Paths; import java.util.Base64; // 处理文件 String filePath = \u0026#34;文件路径\u0026#34;; byte[] fileContent = Files.readAllBytes(Paths.get(filePath)); String encodedFile = Base64.getEncoder().encodeToString(fileContent); // 将编码后的文件内容作为参数添加 sampler.getArguments().addArgument(\u0026#34;fileContent\u0026#34;, encodedFile); 基本上没有GET请求上传文件的场景，这里就不演示了。\nPOST请求 POST请求，请求数据不会显示在url中，可以使用多种类型的参数传递数据到服务器。\n常见的POST请求参数类型包括：\n表单数据：\nContent-Type: application/x-www-form-urlencoded\n数据格式类似于URL查询参数（key1=value1\u0026amp;key2=value2）\n多部分表单数据：\nContent-Type: multipart/form-data\n通常用于文件上传，可以包含多个字段和文件。每个部分都有自己的Content-Type和Content-Disposition。\n原始数据(raw)：\n可以是任意格式的数据，例如JSON、XML、纯文本等。 Content-Type:application/json（JSON数据）、application/xml（XML数据）、text/plain（纯文本）、其他根据需要的类型\napplication/x-www-form-urlencoded application/x-www-from-urlencoded会将表单内的数据转换为键值对，比如name=JZY\u0026amp;age = 18。\nPOST请求且以参数传参时，Jmeter会自动指定Content-Type为：application/x-www-form-urlencoded。如想指定其他类型，需使用请求头管理器。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/POST_FROM/\n取样器的请求方式：POST\n取样器的参数中添加参数。名称1为：data，值1为：JZY；名称2为：data1，值2为：姜振园\n运行结果\nContent-Type为：application/x-www-form-urlencoded; charset=UTF-8。\nPOST data是键值对形式：data=jzy\u0026amp;data1=%E5%A7%9C%E6%8C%AF%E5%9B%AD（中文只能这样显示）\nPOST\u0026amp;multipart/form-data multipart/form-data会将表单的数据处理为一条消息，以标签为单元，用分隔符分开，可以包含文件。就像这样：\nPOST /profile HTTP/1.1 HOST: example.com Content-Type: multipart/form-data; boundary=example-part-boundary # multipart/form-data; boundary=example-part-boundary表示这个请求的的消息类型是 # multipart-form-data，每个 part 之间的边界为 example-part-boundary。 # example-part-boundary是一段很长的字符串，如bqtFfLzQXUbOvsHrs8eOO9kIlZ30hA。 --bqtFfLzQXUbOvsHrs8eOO9kIlZ30hA Content-Disposition: form-data; name=\u0026#34;username\u0026#34; Content-Type: text/plain Nicholas # 第一个 part 的类型为 text/plain，它在表单上对应的 key 为 username，value 为 Nicholas --bqtFfLzQXUbOvsHrs8eOO9kIlZ30hA Content-Disposition: form-data; name=\u0026#34;address\u0026#34; Content-Type: application/json { \u0026#34;country\u0026#34;: \u0026#34;China\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Beijing\u0026#34; } # 第二个 part 的类型为 application/json，它在表单上对应的 key 为 address。 --bqtFfLzQXUbOvsHrs8eOO9kIlZ30hA Content-Disposition: form-data; name=\u0026#34;avatar\u0026#34;; filename=\u0026#34;my_avatar.jpeg\u0026#34; Content-Type: image/jpeg \u0026lt;binary-image data\u0026gt; # 第三个 part 的数据类型为 image/jpeg，它在表单上对应的 key 为 avatar， # 并且 part 的头部还附加了文件名相关的元数据 filename=\u0026#34;my_avatar.jpeg。 --bqtFfLzQXUbOvsHrs8eOO9kIlZ30hA-- # 最后面的 --example-part-boundary-- 表示整个 multipart 消息的结束。 这种方式可以将数据分为很多部分，它既可以上传键值对，也可以上传文件，甚至多个文件。当上传的字段是文件时，会有Content-Type来说明文件类型：Content-disposition，用来说明字段的一些信息。\n每部分都是以-boundary开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容(字段、文本或二进制等)。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以-boundary-标示结束。\nPOST请求且请求参数包含一般参数\u0026amp;文件时，Jmeter会自动指定参数类型为multipart/form-data。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/POST_FROM_DATA/\n取样器的请求方式：POST\n取样器的参数中添加参数,名称1为：username，值1为：JZY；名称2为：address，值2为：{\u0026quot;country\u0026quot;: \u0026quot;中国\u0026quot;,\u0026quot;city\u0026quot;: \u0026quot;杭州\u0026quot; }，内容类型为：application/json\n取样器的参数中添加文件上传。文件名称为：正确的文件路径（如图片路径），参数名称为：image\n运行结果\nContent-Type为：\nContent-Type: multipart/form-data; boundary=qGB9gYtq24YAGWpEpIW_3-nzAAvClSvDznH66fco; charset=UTF-8，其中boundary是边界字符串。请求参数也是典型的FromData。\n另外可去C:\\image下查看刚上传的图片或文件。\n也可使用消息体添加请求参数(可以添加 Text、JavaScript、JSON、HTML、XML 等格式文件)\u0026amp;上传文件，读者可以试下。\nPOST请求\u0026amp;\u0026amp;请求参数包含一般参数\u0026amp;\u0026amp;不上传文件，请求参数类型默认application/x-www-form-urlencoded。 这种场景下，如果想要指定请求参数类型为multipart/ form-data，可以勾选对POST使用multipart/ form-data，读者可以试下。\nPOST\u0026amp;text/plain text/plain用于发送纯文本内容，不对特殊字符进行编码。\n消息体中输入相应内容，Jmeter会自动指定参数类型为text/plain。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest2/\n取样器的请求方式：POST\n取样器的消息体中添加数据：作者 JZY\n运行结果\nContent-Type为：text/plain; charset=UTF-8，请求参数就是纯文本：作者 JZY。\napplication/json 发送JSON字符串时，就需要用application/json，也是比较常用的一种方式。\nJmeter中发送JSON字符串，需要消息体中输入JSON格式内容\u0026amp;消息头管理器添加content-type：application/json。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/POST_JSON/\n取样器的请求方式：POST\n取样器的消息体数据：{\u0026quot;爱好\u0026quot;:\u0026quot;电影\u0026quot;}\n取样器下添加HTTP信息请求头管理器(右键-添加-配置元件-HTTP信息请求头管理器)\nHTTP信息请求头管理器中添加信息头，名称为：content-type，值为：application/json\n运行结果\nContent-Type为：application/json，请求参数就是JSON字符串：{\u0026quot;爱好\u0026quot;:\u0026quot;电影\u0026quot;}。\n还可以请求HTML、XML、CSS、JS等内容，上传方法与JSON类似。\n消息体中输入相应格式内容\u0026amp;信息头管理器中添加对应的Content-Type。\nHTMl的请求参数类型是text/html\nXML的请求参数类型是text/XML\nCSS的请求参数类型是text/CSS\nJS的请求参数类型是text/JS\n读者可以尝试一下。\nbinary 如要传二进制文件，可Content-Type：application/octet-stream(binary)\u0026amp;消息体中输入二进制数据。\n文本转二进制工具\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/POST_BINARY/\n取样器的请求方式：POST\n取样器的消息体数据：101110000001111 1000101111110100\n取样器下添加HTTP信息请求头管理器(右键-添加-配置元件-HTTP信息请求头管理器)\nHTTP信息请求头管理器中添加信息头，名称为：content-type，值为：application/octet-stream\n运行结果\nContent-Type为：application/octet-stream，请求参数就是二进制流：101110000001111 1000101111110100。\nHttp请求默认值 Jmeter中提供配置元件HTTP请求默认值，它提供默认能力。比如其指定了IP、端口，其作用域下任何没有指定IP、端口的HTTP取样器都会使用HTTP请求默认值中IP、端口。\n其他参数的逻辑一致。HTTP请求默认值中不能进行文件上传。\n","permalink":"http://192.168.9.98/posts/technology/jmeter/httprequest/","summary":"关于HTTP请求取样器 JMeter提供多种取样器，HTTP取样器（HTTP Sampler）无疑是最核心的一个。HTTP取样器是用来模拟客户端和服务器之间HTTP请求和接收响应的工具，可以发送各种类型的HTTP请求，如GET、POST、PUT、DELETE等。 HTTP取样器控制面板","title":"Jmeter-HTTP请求取样器"},{"content":"关于线程组 线程组定义了将针对您的服务器执行特定测试用例的用户池。在线程组 GUI 中，您可以控制模拟的用户数（线程数）、加速时间（启动所有线程所需的时间）、执行测试的次数，以及可选的启动并停止测试时间。\nApache JMeter中文网\r线程组\r🌐\r线程组是JMeter测试计划的核心组件之一，是整个测试计划的入口，所有的取样器和控制器必须放置在线程组下。\n可以将线程组视为一个虚拟用户池，其中的线程可被理解为虚拟用户，多个线程即多个虚拟用户，它们同时执行相同的一批任务。\n在这个虚拟用户池中，每个线程之间是相互隔离且互不影响的。每个线程的执行过程中，操作的变量不会对其他线程的变量值产生影响。\n线程组可以定义用户的行为，包括设置线程数、循环次数、启动延迟等关键参数。可以通过配置这些参数来模拟现实中用户可能的操作。\n线程组分为四类:\n线程组 setUp线程组 tearDown线程组 开放模型线程组 线程组、setUp线程组、tearDown线程组控制面板中的元素基本一致：\n名称、注释 在取样器错误后执行的动作 线程数 Ramp-Up时间 Same user on each iteration 延迟创建线程直到需要（只有线程组有） 调度器 开放模型线程组控制面板中的元素：\n名称、注释 在取样器错误后执行的动作 调度计划 随机种子 使用示例脚本，需下载示例接口源码并运行。 执行优先级 JMeter中，不同类型的线程组有着不同的优先级。优先级关系可用表达式表示：setUp线程组 \u0026gt; 线程组 = 开放模型线程组 \u0026gt; tearDown线程组。\n这意味着在测试计划执行过程中，setUp线程组将首先执行，其后是线程组和开放模型线程组，最后执行tearDown线程组。\n通常情况下，setUp线程组用于在测试执行之前进行一些初始化工作，而tearDown线程组用于测试执行结束后的清理工作。\n示例Jmeter脚本\n测试计划下添加tearDown线程组、线程组、setUp线程组、固定定时器（作用于测试计划下的所有取样器）\ntearDown线程组排在最前，setUp线程组排在最后\n固定定时器的线程延迟：3000\ntearDown线程组、线程组、setUp线程组下皆添加HTTP请求取样器。名称分别为：tearDown线程组-HTTP请求、线程组-HTTP请求、setUp线程组-HTTP请求\nHTTP请求取样器的请求地址皆为：HTTP://127.0.0.1:5000/GetList/\nHTTP请求取样器的请求方式皆为：GET\n运行结果\nsetUp 线程组-HTTP请求取样器在2024-07-11 17:21:00 CST 时，发送了请求。\n线程组-HTTP请求取样器在2024-07-11 17:21:03 CST 时，发送了请求。\ntearDown线程组-HTTP请求取样器在2024-07-11 17:21:06 CST 时，发送了请求。\n优先级正是：setUp线程组 \u0026gt; 线程组 = 开放模型线程组 \u0026gt; tearDown线程组。\n线程数 线程组中的线程数即是同时运行的虚拟用户数量。可以配置线程数量来模拟多少用户同时访问目标应用程序或服务。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组面板中的线程数配置为：3\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/GetList/\n取样器的请求方式：GET\n运行结果\n结果中有3个请求，Thread Name分别为线程组 1-1、线程组 1-2、线程组 1-3。 这代表Jmeter启功了3个线程，1个线程就代表1个用户，可以说现在是3个用户一起执行线程组。\n循环次数 JMeter中，循环次数是指每个线程（用户）执行测试计划的次数。可以配置循环次数模拟用户访问目标应用程序或服务的次数。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组面板中的循环次数配置为：3\n线程组下添加HTTP请求取样器\n取样器的请求地址：HTTP://127.0.0.1:5000/GetList/\n取样器的请求方式：GET\n运行结果\n结果中有3个请求，Thread Name分别为线程组 1-1、线程组 1-1、线程组 1-1。 这是因为线程（用户）循环执行了3次。\n取样器错误后执行的动作 取样器（Sampler）是用于模拟用户请求发送到目标服务器的组件，例如HTTP请求、FTP请求等。当取样器执行过程中出现错误时，可以通过配置相应的动作来处理这些错误。以下是处理取样器错误时，线程组中常见方式：\n继续\n停止测试\n立即停止测试\n停止线程\n启动下一进程循环\n继续 线程组-取样器错误后执行的动作的默认选项，JMeter将在取样器执行错误时，忽略错误继续执行本线程的后续操作及执行其他线程。\n停止测试\u0026amp;单线程组 任何一个取样器在执行过程中遇到错误时，整个测试计划将会在所有当前正在执行的线程执行完毕后停止。\n取样器也有执行优先级，线程组下的取样器，从上到下顺序执行。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组面板中取样器错误后执行的动作配置为停止测试\n线程组下添加2个HTTP请求取样器，名称分别为错误请求、正确请求\n错误请求排序在上，正确请求排序在下\n错误请求的请求地址：HTTP://127.0.0.1:5000/api/\n正确请求的请求地址：HTTP://127.0.0.1:5000/GetList/\n错误请求和正确请求的请求方式：GET\n运行结果\n停止测试使Jmeter在错误请求发生错误后，等待所有当前正在执行的线程执行完毕后停止测试计划。 正确请求总会在错误请求执行完毕后执行，所以错误发生时，正确请求还没开始执行，此时Jemter已经停止测试计划了。\n我们再仔细想一下，多线程及多循环时，它是怎么运作的。\nJmeter中，线程组配置多线程时，线程之间也有优先级，以线程组 1-1\u0026gt;线程组 1-2\u0026gt;线程组 1-3类推。 当线程组 1-2的某个取样器发生错误时，Jmeter不会执行线程组 1-3。\n多循环时，不用多说，大家都能明白优先级的情况。第二次循环，某个取样器发生错误时，Jmeter不会执行第三次循环。\n停止测试\u0026amp;多线程组 任何一个取样器在执行过程中遇到错误时，整个测试计划将会在所有当前正在执行的线程执行完毕后停止。\n不同线程组下的取样器，以线程组的优先级为准，例如线程组内的取样器执行优先级比tearDown线程组的高。\n示例Jmeter脚本\n测试计划下添加2个线程组,名称分别为：线程组1、线程组2\n测试计划下添加查看结果树\n测试计划面板中不勾选独立运行每个线程组\n线程组1面板中取样器错误后执行的动作配置为停止测试\n线程组1下添加HTTP请求取样器，名称为：错误请求\n错误请求的请求地址：HTTP://127.0.0.1:5000/api/\n线程组1下添加2个HTTP请求取样器，名称分别为：Sleeper接口请求、GetList接口请求\nSleeper接口请求排序在前，GetList接口请求排序在后\nSleeper接口请求的请求地址：HTTP://127.0.0.1:5000/Sleeper/（接口中已设置延迟3秒响应）\nGetList接口请求的请求地址：HTTP://127.0.0.1:5000/GetList/\n三个取样器的请求方式皆配置为：GET\n运行结果\n第一道红线上的信息是错误请求-线程组1 1-1发出请求的时间，为：2024-07-12 16:01:26,761。\n第二道红线上的信息是Sleeper接口请求-线程组2 2-1发出请求的时间，为：2024-07-12 16:01:26,763。\n第三道红线上的信息是错误请求-线程组1-1检测到了一个关闭测试的信号。\n后面的信息就是等待Sleeper接口请求-线程组2 2-1完成，然后关闭测试。\nSleeper接口请求延迟3秒响应导致GetList接口请求会在3秒后执行（执行优先级），所以错误请求发生错误时，GetList接口请求还未执行，那就不会执行GetList接口请求了。\n或许已经有读者在思考测试计划配置独立运行每个线程组时，它应该如何运作。我直接给你答案罢。经过测试，它存在Bug，表现为排序在前的线程组中取样器发生错误，但后面的线程组仍有概率会执行。虽然我们的期望是后面的线程组必然不会执行。\n立即停止测试 任何一个取样器在执行过程中遇到错误时，JMeter会立即停止当前运行的测试，不再执行任何后续的请求或操作。\n单线程组中的取样器有严格的执行优先级，仅单线程组场景下，配置停止测试与配置立即停止测试的作用一致。我们就只探究多线程组场景下，它的作用。\n需要注意，测试计划配置独立运行每个线程组时，会出现与配置停止测试一样的Bug。\n示例Jmeter脚本\n测试计划下添加2个线程组,名称分别为：线程组1、线程组2\n测试计划下添加查看结果树\n测试计划面板中不勾选独立运行每个线程组\n线程组1面板中取样器错误后执行的动作配置为立即停止测试\n线程组1下添加HTTP请求取样器，名称为：错误请求\n错误请求的请求地址：HTTP://127.0.0.1:5000/api/\n线程组1下添加2个HTTP请求取样器，名称分别为：Sleeper接口请求、GetList接口请求\nSleeper接口请求排序在前，GetList接口请求排序在后\nSleeper接口请求的请求地址：HTTP://127.0.0.1:5000/Sleeper/（接口中已设置延迟3秒响应）\nGetList接口请求的请求地址：HTTP://127.0.0.1:5000/GetList/\n三个取样器的请求方式皆配置为：GET\n运行结果\n与配置停止测试不同的是，第三道红线上的信息不再是关闭测试的信号，而是直接关闭测试。导致Sleeper接口请求被强制关闭与服务器端的连接，红框中的响应体信息显示读取数据错误。\n停止线程 任何一个线程（用户）在执行过程中遇到错误时，该线程被停止，不影响其他线程（用户）。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树、用户参数(右键-添加-前置处理器)\n用户参数添加三个变量，名称分别为：name、name1、lujing\n用户参数添加三个用户（可用于参数化，1个线程引用一个用户变量）\n用户_1的name变量值：线程1的错误请求\n用户_2的name变量值：线程2的正确请求\n用户_3的name变量值：线程3的正确请求\n用户_1的name1变量值：线程1的\n用户_2的name1变量值：线程2的\n用户_3的name1变量值：线程3的\n用户_1的lujing变量值：/api/\n用户_2的lujing变量值：/GetList/\n用户_3的lujing变量值：/GetList/\n线程组面板中取样器错误后执行的动作配置为：停止线程，线程数配置为：3，循环次数配置为：2\n线程组下添加2个HTTP请求取样器，名称分别为：${name}、${name1}GetList接口请求\n${name}的请求地址：HTTP://127.0.0.1:5000${lujing}\n${name1}GetList接口请求的请求地址：HTTP://127.0.0.1:5000/GetList/\n两个取样器的请求方式：GET\n运行结果\n线程1的第1取样器-线程1的错误请求发生错误后，线程1后续的取样器及循环不再执行。但不影响其他线程取样器的执行，线程2和线程3正常执行。\n多线程组也是多线程，读者在实际的脚本编写中，需注意每个线程的情况去使用停止线程。\n启动下一进程循环 任何一个线程（用户）在执行过程中遇到错误时，Jmeter会立即停止当前线程的本次执行，并进行当前线程（用户）的下次执行，不影响其他线程，主要应用于线程多次循环时。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树、用户参数\n用户参数添加三个变量，名称分别为：name、name1、lujing\n用户参数添加三个用户\n用户_1的name变量值：线程1的错误请求\n用户_2的name变量值：线程2的正确请求\n用户_3的name变量值：线程3的正确请求\n用户_1的name1变量值：线程1的\n用户_2的name1变量值：线程2的\n用户_3的name1变量值：线程3的\n用户_1的lujing变量值：/api/\n用户_2的lujing变量值：/GetList/\n用户_3的lujing变量值：/GetList/\n线程组面板中取样器错误后执行的动作配置为：启动下一进程循环，线程数配置为：3，循环次数配置为：2\n线程组下添加2个HTTP请求取样器，名称分别为：${name}、${name1}GetList接口请求\n${name}的请求地址：HTTP://127.0.0.1:5000${lujing}\n${name1}GetList接口请求的请求地址：HTTP://127.0.0.1:5000/GetList/\n两个取样器的请求方式：GET\n运行结果\n线程1的第1取样器-线程1的错误请求发生错误后，线程1后续的取样器不再执行，但循环会继续-线程1的错误请求执行第二次。也不影响其他线程取样器的执行，线程2和线程3正常执行。\nramp-up时间 ramp-up时间用于设置启动所有线程所需要的时间。例如：线程数设置为10，ramp-up时间设置为100秒，那么各线程启动间隔为10秒(100/10)，即每个用户将在前一个用户启动后的10秒启动。\n如果ramp-up值设置得很小、线程数又设置得很大，刚开始执行测试时会对服务器产生很大的压力。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组面板中Ramp-Up时间配置为：9，线程数配置为：3\n线程组下添加HTTP请求取样器\nHTTP请求取样器的请求地址：HTTP://127.0.0.1:5000/GetList/\nHTTP请求取样器的请求方式：GET\n运行结果\n各个线程的执行间隔正好是3秒(9/3)。\nsame user on each iteration（在每次迭代中使用相同的用户） 没有研究出来它有什么用。经过我的测试，same user on each iteration（在每次迭代中使用相同的用户）启用与否，作用是一样的。\n如读者有什么见解，欢迎谈论，共同探讨。目前，我十分费解。\n延迟创建线程直到需要 启用延迟创建线程直到需要时，JMeter会根据预设的Ramp-up时间动态地分配线程。假设Ramp-up时间设置为20秒，线程数为10，那么JMeter会在测试启动后立即创建第一个线程并开始请求处理。随后，每隔2秒，JMeter将创建下一个线程，直到所有线程都被启动。\n如果关闭延迟创建线程直到需要选项，JMeter会在测试开始时一次性创建所有线程，然后间隔执行。即在测试一开始，JMeter会立即创建全部的10个线程，然后每个线程将间隔2秒启动。\n这一配置的目的是为了应对测试机性能有限的情况。通过这种方式，可以避免在测试初期就创建所有线程，导致资源过度占用和可能的性能问题。这种方法有助于平滑地增加系统负载，同时防止资源瞬间紧张导致测试无法正常进行。\n调度器 调度器主要控制线程操作时间，包含持续时间、启动延迟两个参数。\n持续时间（值不能为空）可以设置线程组的执行时间上限，达到上限后停止线程组的执行（已执行的不受影响）。\n启动延迟可以为线程组的线程执行添加延迟时间。\n持续时间，启动延迟同时有值时，启动延迟的时间计算到持续时间里。如启动延迟3秒，持续时间20秒，总执行时间为20秒。\n示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n线程组面板中持续时间配置为10，启动延迟配置为：3，循环次数配置为：永远\n线程组下添加HTTP请求取样器、固定定时器\nHTTP请求取样器的请求地址：HTTP://127.0.0.1:5000/GetList/\nHTTP请求取样器的请求方式：GET\n固定定时器的线程延迟配置为：2000（防止请求过多）\n运行结果\n红线第1行的All thread groups have been started 表示所有线程组都已经开始执行。再上面一行表示线程组1已开始执行。时间是2024-07-15 14:03:56,234。\n红线第2行的Thread started: 线程组 1-1表示线程组1中的线程1-1已经开始。时间是2024-07-15 14:03:59,234。\n红线第三行的Notifying test listeners of end of test表示测试结束，正在通知所有测试监听器。时间是2024-07-15 14:04:07,296。\n线程组1和线程组1中的线程1-1的执行间隔就是3秒，再到结束测试的时间间隔为11秒左右（持续时间存有误差）。\n","permalink":"http://192.168.9.98/posts/technology/jmeter/threadgroup/","summary":"关于线程组 线程组定义了将针对您的服务器执行特定测试用例的用户池。在线程组 GUI 中，您可以控制模拟的用户数（线程数）、加速时间（启动所有线程所需的时间）、执行测试的次数，以及可选的启动并停止测试时间。 Apache JMeter中文网 线程组 🌐 线程组是JMeter测试计划的核心组件之一，是整个测试计划","title":"Jmeter-线程组"},{"content":"关于测试计划 测试计划是指定测试的整体设置的地方。\nApache JMeter中文网\r测试计划\r🌐\r测试计划-用于运行测试的JMeter脚本，由测试元素组成。比如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。每个测试计划中至少应有一个线程组。 前言中的快速开始就是一个测试计划。\n测试计划控制面板中的元素：\n名称和注释\n用户定义的变量\n独立运行每个线程组\n主线程结束后运行tearDown线程组\n函数测试模式\n添加目录或jar包到classpath\n使用示例脚本，需下载示例接口源码并运行。\r用户定义的变量 测试计划面板中提供的用户定义的变量，作用域为整个测试计划，可以通过${变量名称}的方式来引用。用户定义的变量用于在不同的请求或操作中使用相同的数值，从而更加方便地维护和修改。\n不建议使用测试计划面板中用户定义的变量，可使用配置元件中用户定义的变量-更灵活。\r示例Jmeter脚本\n测试计划下添加线程组、查看结果树\n测试计划中添加用户定义的变量。变量名：UserDefinedVariables、变量值：姜振园\n线程组下添加HTTP请求\nHTTP请求：GET HTTP://127.0.0.1:5000/UserDefinedVariables/\nHTTP请求参数：变量名：UserDefinedVariables、变量值：${UserDefinedVariables}\n运行结果\n请求体中的?UserDefinedVariables=姜振园表明正确引用了测试计划中用户自定义变量的值姜振园。\nJMeter提供的配置元件中也包含用户定义的变量元件，通过测试计划/线程组/取样器-添加-配置元件-用户定义的变量添加。用法与测试计划面板中的用户定义的变量一致。\n测试计划下添加的用户定义的变量将在整个测试计划中生效，与测试计划面板中的用户定义的变量作用范围一致。如果用户定义的变量位于取样器中，其作用范围将仅限于该特定取样器内。\n独立运行每个线程组 勾选独立运行每个线程组，测试计划下同类型线程组串行（顺序执行）。不勾选独立运行每个线程组，测试计划下同类型线程组并行。\n示例Jmeter脚本\n测试计划下添加两个线程组-名称：线程组1、线程组2\n测试计划下添加查看结果树\n两个线程组下皆添加HTTP请求-名称：HTTP请求1、HTTP请求2\nHTTP请求1、HTTP请求2：GET HTTP://127.0.0.1:5000/GetList/\n线程组1下添加固定定时器-线程延迟：3000（使线程组1中的取样器延迟3秒执行）\n不勾选独立运行每个线程组 测试计划中不勾选独立运行每个线程组，运行\nHTTP请求2排序在前，总用时3秒——右上角红框标记。\nHTTP请求2的Sample Start——请求释放的时间为：2024-06-28 11:40:59 CST，HTTP请求1的Sample Start为：2024-06-28 11:41:02 CST。\n固定定时器使HTTP请求1的释放时间延迟3秒——用时3秒的原因，因两个线程组并发，造成HTTP请求2比HTTP请求1的释放时间早了3秒。\n勾选独立运行每个线程组 测试计划中勾选独立运行每个线程组，运行\nHTTP请求1排序在前，总用时3秒——右上角红框标记。\nHTTP请求1及HTTP请求2的Sample Start均为：2024-06-28 11:51:17 CST。\n固定定时器使HTTP请求1的释放时间延迟3秒——用时3秒的原因，但因两个线程组串发，HTTP请求2在HTTP请求1后释放——日志信息中红色下划线，HTTP请求2的释放时间晚于HTTP请求1的释放时间21毫秒。\n主线程结束后运行tearDown线程组 JMeter 中，线程组的执行优先级大于tearDown 线程组，tearDown 线程组将会等待所有线程组执行完毕后才会执行。\n线程组中的取样器-在取样器错误发生后要执行的动作配置为停止测试或立即停止测试，如果取样器发生错误，tearDown线程组就不会执行。\n这种场景下，如果需要执行tearDown线程组，则可以勾选主线程结束后运行tearDown线程组。它的作用是普通线程由于取样器错误而导致线程结束执行时，Jmeter也会继续执行 tearDown 线程。\n这意味着即使在测试中发生了错误，系统仍会在整个测试结束前执行 tearDown 线程，以确保在测试运行结束时执行一些清理或必要的操作。\n示例Jmeter脚本\n测试计划下添加线程组、tearDown线程组、查看结果树\n线程组面板中的在取样器错误后要执行的动作中勾选停止测试或立即停止测试\n线程组和tearDown线程组下添加http请求取样器\n线程组下取样器名称：线程组-HTTP请求\n线程组-HTTP请求的请求地址：HTTP://1.1.1.1:1111/error/（错误的请求地址，会造成取样器错误）\ntearDown线程组下取样器名称：tearDown线程组-HTTP请求\ntearDown线程组-HTTP请求的请求地址：HTTP://127.0.0.1:5000/GetList/\n线程组-HTTP请求及tearDown线程组-HTTP请求的请求方式：GET\n不勾选主线程结束后运行tearDown线程组 测试计划中不勾选主线程结束后运行tearDown线程组，运行\n执行了线程组-HTTP请求，但没有运行tearDown线程组-HTTP请求。\ntearDown 线程组会在线程组执行完毕后执行，所以tearDown线程组-HTTP请求会在线程组-HTTP请求结束后执行。\n线程组-HTTP请求响应体中的异常信息显示尝试连接到IP地址1.1.1.1上的端口1111时超时，导致取样器发生错误。这是肯定的，因为请求地址就是个错误地址。\n线程组中设置在取样器错误后要执行的动作-停止测试，Jmeter检测到线程组-HTTP请求错误后，不再执行后续取样器请求。\n造成的结果就是tearDown线程组-HTTP请求不会被执行。\n勾选主线程结束后运行tearDown线程组 测试计划中勾选主线程结束后运行tearDown线程组，运行\n这次执行了tearDown线程组-HTTP请求。它的作用就是无论如何都会执行tearDown线程组。\n函数测试模式 若选择了此选项，并且监听组件（比如“查看结果树”）配置了将结果保存到文件中，JMeter会将每次的请求结果记录到文件中。这种做法相对消耗资源，只推荐在平时脚本调试的情况下，启用该选项。\n实际应用场景相对有限，因此在本文中不进行详细演示。\n添加目录或jar包到classpath 添加文件或 JAR 包功能主要用于调用外部的 JAR 包。当脚本需要引用外部的 Java 文件或 JAR 包时，可以通过将 JAR 包的路径添加到此功能中。这样，在 Beanshell 脚本中就可以通过 import 语句导入外部 JAR 包，并直接调用其中的方法。\n在后续的内容中，当涉及到 Beanshell 时，将详细阐述如何使用这一功能。\n","permalink":"http://192.168.9.98/posts/technology/jmeter/testplan/","summary":"关于测试计划 测试计划是指定测试的整体设置的地方。 Apache JMeter中文网 测试计划 🌐 测试计划-用于运行测试的JMeter脚本，由测试元素组成。比如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。每个测试计划中至少应有一个线程组。 前言中的快速开始就是一个测试计划。 测试","title":"Jmeter-测试计划"},{"content":"\nJMeter 环境安装及配置 使用 JMeter 之前，需要配置对应环境-安装JDK和JMeter。\n首先了解一下为什么需要JDK。JMeter使用Java编写，一般来说，只需要安装JRE（Java 运行时环境）就可以运行JMeter，因为JRE包含了运行Java应用程序所需的组件。那么为什么建议安装JDK呢？\n如果想要在JMeter中使用一些插件、进行脚本开发、编译测试计划等高级功能，就需要安装JDK。因为JDK不仅包含了JRE，并且还提供了编译Java代码所需的工具，比如javac。此外，一些场景下-比如进行HTTPS压力测试，还需要使用JDK中的keytool工具。\nJDK的安装及环境配置 下载JDK，注意一定要下载与Jmeter对应的JDK版本-如jmeter-5.6.3与JDK21对应\nJDK下载地址\n安装JDK\n建议提前在D盘或C盘下新建Tools\\JDK文件夹。安装 JDK 时，修改安装目录为Tools\\JDK文件夹。这样做的好处在于方便管理和配置环境变量。\n后面一直下一步就行。\n配置JDK系统变量、环境变量\n系统变量和环境变量是计算机系统中的两个重要概念，它们用于存储和管理系统或应用程序运行过程中需要使用的信息。\n系统变量是指在操作系统级别上设置的一些全局信息，用于控制整个计算机系统的行为。 这些变量通常由操作系统或系统管理员配置，用于存储系统范围的配置参数和信息。\n系统变量可以影响所有用户和应用程序的行为。 如PATH是一个常见的系统变量，它存储了操作系统中可执行文件的路径信息，操作系统会通过PATH查找可执行文件并运行。\n环境变量是在操作系统或应用程序运行过程中设置的一些动态变量，用于影响当前进程的行为。 环境变量提供了一种将信息传递给正在运行的程序的方法，以便程序根据这些变量的值来调整其行为。 如PATH变量中的值就是执行文件的环境变量。\n不要随意改动环境变量，否则可能造成系统死机。\r配置JDK系统变量\n右键此电脑-属性-高级系统设置-环境变量\n系统变量-点击新建\n变量名：JDK\n变量值：JDK安装目录(进入JDK目录，复制文件地址栏中的值)或者浏览目录进行选择（Windows11）\n配置JDK的环境环境\n系统变量中找到Path，选中后点击编辑\n新建环境变量：%JDK%\\bin;\n新建环境变量：%JDK%\\jre\\bin;\nJmeter的安装及配置 JMeter是一个独立的Java应用程序，它不依赖于系统注册表或其他系统级配置，它能够在不同操作系统上运行而无需进行安装。 只需要下载完成后，将ZIP文件解压缩到指定的目录。 然后在目录中找到JMeter启动脚本（windows的jmeter.bat 或 Linux的jmeter.sh），运行启动JMeter。\n下载JmeterZIP包,注意一定要下载与JDK对应的Jmeter版本-如jmeter-5.6.3与JDK21对应\n历史版本Jmeter下载地址。\n最新版本Jmeter下载地址。\n解压到目录\n建议解压到D:\\Tools目录下，方便管理。\n汉化Jmeter界面\n编辑Jmeter/bin/jmeter.properties\n40行增加language=zh_CN，然后保存\n发送启动文件到桌面快捷方式\n右键Jmeter.bat-发送到-桌面快捷方式\n启动Jmeter\n双击桌面上的 JMeter 快捷方式，等待脚本运行\n快速使用 可以使用最简单的JMeter脚本，快速进行一次接口请求。这个脚本包括测试计划、线程组、取样器（Sampler）及查看结果器（View Results Tree）。\n在测试计划中，定义整个测试的基本设置。线程组用于模拟用户，而取样器代表了具体的请求,查看结果器则用于查看请求的详细结果。\n通过这个简单的脚本，能够迅速进行一次接口请求测试。\n使用示例脚本，需下载示例接口源码并运行。\r示例Jmeter脚本\n测试计划下添加线程组（右键测试计划-线程-线程组）、查看结果树（右键测试计划-监听器-查看结果树）\n线程组下添加HTTP请求（右键线程组-取样器-HTTP请求）\nHTTP请求中配置\n协议为：HTTP、IP为：127.0.0.1\n端口号为：5000\nHTTP请求（请求方式）为：GET\n路径为：/api/GetList/（即请求：GET HTTP://127.0.0.1:5000/api/GetList/）\n点击工具栏-绿色三角运行，查看结果树中查看结果\n显示请求是否成功（绿色-成功，红色-失败）\n取样器结果（显示线程名称、请求执行的时间、响应状态等）\n请求数据（请求头、请求体）\n响应数据（响应头、响应体）\n","permalink":"http://192.168.9.98/posts/technology/jmeter/envconfig/","summary":"JMeter 环境安装及配置 使用 JMeter 之前，需要配置对应环境-安装JDK和JMeter。 首先了解一下为什么需要JDK。JMeter使用Java编写，一般来说，只需要安装JRE（Java 运行时环境）就可以运行JMeter，因为JRE包含了运行Java应用程序所需的组件。那么为什么建议安装JDK呢？","title":"Jmeter-环境配置"},{"content":"关于Jmeter JMeter是Apache组织开发的基于Java的开源压力测试工具。最初，它被设计用于Web应用测试，但后来扩展到其他测试领域。它可以用于测试静态和动态资源，例如静态文件、Java小服务程序、CGI脚本、Java对象、数据库、FTP服务器等。JMeter可以模拟巨大的负载，测试服务器、网络或对象在不同压力条件下的强度和性能。\nJMeter的优点包括：\n开源免费：基于Java编写，具有很高的可扩展性，可以集成到其他系统中并扩展各种功能插件。\n多种测试功能：支持接口测试、压力测试等，且支持录制回放，入门简单。\n友好的用户界面：相较于自己编写框架或其他开源工具，JMeter具有较为完善的UI界面，便于接口调试。\n多平台支持：可在Linux、Windows、Mac等操作系统上运行。\n功能/回归测试：通过创建带有断言的脚本来验证程序返回的结果是否符合预期。JMeter允许使用正则表达式创建断言，提供了极大的灵活性。\n主要组件介绍 测试计划(Test Plan)\n是使用JMeter进行测试的起点，它是其它JMeter测试元件的容器。\n线程组(Thread Group)\n代表一定数量的并发用户，它可以用来模拟并发用户发送请求。\n取样器(sampler)\n定义实际的请求内容，被线程组包含，我们主要用HTTP请求。\n监听器(Listener)\n负责收集测试结果，同时也被告知了结果显示的方式。我们常用的包括：聚合报告、察看结果树、用表格查看结果，都支持将结果数据写入文件。其他的添加上去看看就行。\n逻辑控制器(Logic Controller)\n可以自定义JMeter发送请求的行为逻辑，它与Sampler结合使用可以模拟复杂的请求序列。\n其分为循环控制器和事务控制器。\n断言(Assertions)\n可以用来判断请求响应的结果是否如用户所期望的。它可以用来隔离问题域，即在确保功能正确的前提下执行压力测试。这个限制对于有效的测试是非常有用的。\n配置元件(Config Element)\n维护Sampler需要的配置信息，并根据实际的需要会修改请求的内容。我们主要在参数化中用到CSV Data Set Config。\n前置处理器(Pre Processors)和后置处理器(Post Processors)\n负责在生成请求之前和之后完成工作。前置处理器常常用来修改请求的设置，后置处理器则常常用来处理响应的数据。我们主要在动态关联中用到后置处理器的正则表达式提取器。\n定时器(Timer)\n负责定义请求之间的延迟间隔。\n执行顺序(Execution sequence)\n配置元件、前置处理器、定时器、取样器、后置处理器、断言、监听器\n工作流程 JMeter通过模拟一组用户将请求发送到目标服务器。 随后，收集数据以通过各种格式计算目标服务器的统计和显示性能度量。\n说明 本文基于JDK21、Jmeter-5.6.3测试编写，可能不适用于历史版本及未来版本。如果Jmeter在后续的新版本中有所变化，或者文中有错漏的地方，请联系我或评论。\nApache JMeter中文网-本系列教程中部分介绍文本引用于此\n本系列文章中所有示例接口皆由python编写，python版本为3.12.1，如要使用示例接口请安装python3.12.1与pycharm。压缩包内包含源码和使用说明，可点击下载示例代码\n","permalink":"http://192.168.9.98/posts/technology/jmeter/preface/","summary":"关于Jmeter JMeter是Apache组织开发的基于Java的开源压力测试工具。最初，它被设计用于Web应用测试，但后来扩展到其他测试领域。它可以用于测试静态和动态资源，例如静态文件、Java小服务程序、CGI脚本、Java对象、数据库、FTP服务器等。JMeter可以模拟巨","title":"Jmeter-前言"},{"content":"","permalink":"http://192.168.9.98/posts/wj/read/","summary":"","title":"Read"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r👉友链格式\r名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求\r秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群\r787018782\n","permalink":"http://192.168.9.98/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\n姓名: 姜振园\n就职: 就职于锐菲网络-氛围很好的公司，测试工程师\n爱好: 小说、运动、电影、美食\n关于本博客\n为什么要写博客呢？\n学习\n编辑即是温故。我希望通过编辑达到学习的目的。\n分享知识\n知识具有强大力量，而这种力量应该共享。我愿意将知识体系分享出来。\n交友\n希望我的文章能够被你们认可，也希望可以与大家一起讨论更多的事情。\n留下痕迹\n时光如流水，涓流不止。人的一生就是一个水圈，能流多久呢？\n水流尽后，既然什么都带不走，那就多留点东西吧。哪怕只有痕迹能让他人看到。\n博客的内容板块\n技术: 一些关于测试工具、测试方法、Python等，可用于测试的内容\n周记: 一些我认为值得记录的内容\n更新\n不定时更新。如果你喜欢其中的文章，欢迎给我留言\n","permalink":"http://192.168.9.98/about/","summary":"关于我 姓名: 姜振园 就职: 就职于锐菲网络-氛围很好的公司，测试工程师 爱好: 小说、运动、电影、美食 关于本博客 为什么要写博客呢？ 学习 编辑即是温故。我希望通过编辑达到学习的目的。 分享知识 知识具有强大力量，而这种力量应该共享。我愿意将知识体系分享出来。 交友 希望我的文章能够被你们认可，也希望","title":"关于"}]