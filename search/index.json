[{"content":"Part1.背景 我负责的一个项目经过长时间的开发，终于在客户现场正式运行了。虽然在正式运行前很长一段时间里我一直计划进行一次性能测试，但由于各种原因，测试一直没有进行。我们的运维人员在正式运行前进行了试运行，结果在一定数量的并发下，由于硬盘顶不住，系统直接卡死了。好吧！\nPart2.影响项目性能的因素分析 我负责的这个项目的主要功能就是对监控设备的视频流进行切片、存储，然后生成URL供平台调阅。它主要分为两个部分，切片、存储。这个项目中，不同存储方式导致项目架构不同。\n存储方面，提供3中存储方式——本地存储、S3接口存储、智能云存储。S3接口存储、智能云存储需额外配置存储服务器，与切片服务器分开，切片视频文件放在存储服务器中。本地存储则不需额外配置存储服务器，直接把切片视频文件放在切片服务器中。\n进行性能测试，首先要知道影响项目性能的因素有那些。与研发沟通后。切片时需关注cpu使用率、平均负载、内存使用。存储时需关注存储cpu使用率、内存使用率、平均负载、系统读写带宽信息、硬盘读写带宽信息。非本地存储时，还需要获取切片服务器与存储服务器之间的网络宽带信息。\nPart3.策划初步测试方案 首先需要明确，此项目主要功能的流程。\n由此可以初步策划两套测试方案。\n第一套\n使用Jmeter下发切片指令，切片服务器中使用top命令获取切片服务器切片过程中的cpu、平均负载、内存等信息 切片完成后。存储服务器中使用top命令获取切片视频存储过程中的cpu、平均负载、内存等信息，使用iostat命令获取切片视频存储过程中存储服务器存储过程中的硬盘信息；切片服务器中使用nload命令获取切片视频存储过程中的网络传输信息。 分析并整理获取到的所有信息 制作成结果图表 第二套\n使用Jmeter下发切片指令后，切片服务器中使用top命令获取切片服务器中的cpu、平均负载、内存等信息，使用iostat命令获取切片服务器存储过程中的硬盘信息。 分析并整理获取到的所有信息（分出切片、存储两个时间段） 制作成结果图表 Part4. 搭建测试方案所需环境 以第一套为例：\n准备切片服务器\n服务器系统使用Linux系统\n服务器中部署切片服务\n服务器中安装iostat、nload\n准备存储服务器\n服务器中部署存储服务(研发已经部署，直接白嫖)\n服务器中安装iostat\n编写服务器脚本，获取服务器信息\n服务器中编写所需top、iostat、nload脚本命令。\ntop脚本，用于切片服务器、存储服务器\n#!/bin/bash # 总循环时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 记录开始时间 start_time=$(date +%s) # 循环直到达到总时间 while true; do # 计算当前时间与开始时间的差值（秒） current_time=$(date +%s) elapsed_time=$((current_time - start_time)) # 如果已经达到或超过总时间，则退出循环 if [ $elapsed_time -ge $total_time ]; then break fi # 执行提供的命令 top -n 1 -b | head -n 6 \u0026gt;\u0026gt; /top.log # 睡眠2秒 sleep 2 done iostat脚本，用于切片服务器、存储服务器\n#!/bin/bash # 总持续时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 记录开始时间 start_time=$(date +%s) # 启动 iostat命令 并将输出重定向到日志文件，同时将其放入后台运行，根据需要写iostat。 (iostat -x -m -t 2 \u0026gt; /iostat.log) \u0026amp; # 保存 nload 的进程ID PID=$! # 等待$1秒 sleep $1 # 终止 iostat 进程 kill $PID nload脚本，用于切片服务器\n#!/bin/bash # 总持续时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 启动 nload 并将输出重定向到日志文件，同时将其放入后台运行 (nload eno1 -u M -m -t 1500 \u0026gt; /nload.log) \u0026amp; # 保存 nload 的进程ID PID=$! # 等待60秒 sleep $1 # 终止 nload 进程 kill $PID 使用python编写服务远程执行top、iostat脚本\n主要目的是为了一键自动化，不需要自己手动执行top、iostat脚本。 思路是：使用Flask实现一个前置服务。Jmeter下发切片指令前请求前置服务，自动远程执行top、iostat脚本。 看读者可能会有疑问，nload脚本呢？ 我也想远程执行，但是远程执行后获取的log文件内没有任何信息。 查询得知，运行nload，Linux会拉起一个终端，但远程执行没有终端被拉起，花了一些时间也没找到解决办法，就只能手动执行了。\n代码如下：\n# Getdata.py import paramiko import time import threading from flask import Blueprint, jsonify, request GetData = Blueprint(\u0026#39;GetData\u0026#39;, __name__, template_folder=\u0026#39;templates\u0026#39;) def create_ssh_client(hostname, port, username, private_key_path): \u0026#34;\u0026#34;\u0026#34;创建并返回一个SSH客户端的辅助函数。\u0026#34;\u0026#34;\u0026#34; private_key = paramiko.RSAKey.from_private_key_file(private_key_path) client = paramiko.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(hostname, port=port, username=username, pkey=private_key) return client def execute_command_async(client, command): \u0026#34;\u0026#34;\u0026#34;在SSH客户端上执行命令的辅助函数。\u0026#34;\u0026#34;\u0026#34; stdin, stdout, stderr = client.exec_command(command) stdout.channel.recv_exit_status() def fetch_files(ssh_client, remote_path, local_path): \u0026#34;\u0026#34;\u0026#34;从远程服务器拉取文件的辅助函数。\u0026#34;\u0026#34;\u0026#34; try: with ssh_client.open_sftp() as sftp_client: sftp_client.get(remote_path, local_path) print(f\u0026#34;成功获取 {remote_path} 到 {local_path}\u0026#34;) except Exception as e: print(f\u0026#34;获取 {remote_path} 时出错: {e}\u0026#34;) def delete_remote_files(client, filenames): \u0026#34;\u0026#34;\u0026#34;删除远程服务器上的文件的辅助函数。\u0026#34;\u0026#34;\u0026#34; for filename in filenames: client.exec_command(f\u0026#39;rm {filename}\u0026#39;) def test165(long, client, hostname_command): \u0026#34;\u0026#34;\u0026#34;切片快结束时，执行存储服务器上的脚本。\u0026#34;\u0026#34;\u0026#34;\ttime.sleep(long - 10) execute_command_async(client, hostname_command) @GetData.route(\u0026#39;/api/GetTop/\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def gettop(): \u0026#34;\u0026#34;\u0026#34;获取切片时长\u0026#34;\u0026#34;\u0026#34; long = int(request.args.get(\u0026#34;time\u0026#34;)) print(long) \u0026#34;\u0026#34;\u0026#34;定义脚本执行时长\u0026#34;\u0026#34;\u0026#34; shi = 600 def background_task(): \u0026#34;\u0026#34;\u0026#34;定义服务器的信息\u0026#34;\u0026#34;\u0026#34; hostname1 = \u0026#39;192.168.1.111\u0026#39; hostname2 = \u0026#39;192.168.1.112\u0026#39; port = 22 username = \u0026#39;root\u0026#39; private_key_path = r\u0026#34;C:\\Users\\Ethereal Jiang\\.ssh\\id_rsa\u0026#34; \u0026#34;\u0026#34;\u0026#34;实例化ssh客户端并执行脚本命令。使用多线程是两个服务器互不影响。\u0026#34;\u0026#34;\u0026#34; client1 = None client2 = None try: client1 = create_ssh_client(hostname1, port, username, private_key_path) client2 = create_ssh_client(hostname2, port, username, private_key_path) hostname1_command = f\u0026#39;bash /opt/top_start.sh {long + shi} \u0026amp; bash /opt/iostat_start.sh {long + shi}\u0026#39; hostname2_command = f\u0026#39;bash /opt/top_start.sh {shi} \u0026amp; bash /opt/iostat_start.sh {shi}\u0026#39; thread1 = threading.Thread(target=execute_command_async, args=(client1, hostname1_command)) thread2 = threading.Thread(target=test165, args=(long, client2, hostname2_command)) thread1.start() thread2.start() thread1.join() thread2.join() except Exception as e: print(f\u0026#34;An error occurred: {e}\u0026#34;) finally: if not client1: client1 = create_ssh_client(hostname1, port, username, private_key_path) if not client2: client2 = create_ssh_client(hostname1, port, username, private_key_path) fetch_files(client2, \u0026#39;/top.log\u0026#39;, \u0026#39;D:\\\\test\\\\165\\\\top.log\u0026#39;) fetch_files(client2, \u0026#39;/iostat.log\u0026#39;, \u0026#39;D:\\\\test\\\\165\\\\iostat.log\u0026#39;) delete_remote_files(client2, [\u0026#39;/top.log\u0026#39;, \u0026#39;/iostat.log\u0026#39;]) fetch_files(client1, \u0026#39;/top.log\u0026#39;, \u0026#39;D:\\\\test\\\\169\\\\top.log\u0026#39;) fetch_files(client1, \u0026#39;/iostat.log\u0026#39;, \u0026#39;D:\\\\test\\\\169\\\\iostat.log\u0026#39;) delete_remote_files(client1, [\u0026#39;/top.log\u0026#39;, \u0026#39;/iostat.log\u0026#39;]) if client1: client1.close() if client2: client2.close() print(\u0026#39;结束\u0026#39; + str(time.time())) task_thread = threading.Thread(target=background_task) task_thread.start() return jsonify({\u0026#34;status\u0026#34;: \u0026#34;任务已开始在后台处理\u0026#34;}), 202 # app.py from flask import Flask from Getdata import GetData app = Flask(__name__) app.secret_key = \u0026#39;jiang\u0026#39; app.register_blueprint(GetData) if __name__ == \u0026#39;__main__\u0026#39;: app.run() 编写Jmeter脚本，下发切片指令\n如图所示： 执行脚本后，首先会请求前置服务，执行服务器脚本，然后，开始并发切片指令。nload脚本就需要在切片快结束时，手动执行。结束后，前置服务自动拉取信息文件到本地。\nPart5. 测试结束后后，分析、整理本地数据 每次并发测试三轮，信息文件放在对应的文件夹中。使用Notepad++和WPS表格处理数据。\nNotepad++查询复制数据，WPS表格分列数据。如图：\nPart6. 将分析整理后的数据制作成图表 我使用的是cdn库的Chart.js。示例如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;性能测试\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.net/Chart.js/3.9.1/chart.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { background: #9e9e9e1a; margin: 0; /* 移除默认的外边距 */ } .card { padding: 0 3%; background: #fff; border: 1px solid #dcdee2; border-color: #e8eaec; border-radius: 15px; width: 80%; /* 设置左右边距为自动 */ margin: 2% auto; } .data { margin-top: 2%; margin-bottom: 4%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;data\u0026#34;\u0026gt; \u0026lt;span\u0026gt;5个并发\u0026lt;/span\u0026gt; \u0026lt;canvas id=\u0026#34;c5_169\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;data\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;c5_165\u0026#34; \u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 并发5 const c5_169_Ctx = document.getElementById(\u0026#39;c5_169\u0026#39;); const c5_169_Labels = [\u0026#39;%错误率\u0026#39;, \u0026#39;切片-%CPU最大使用率\u0026#39;, \u0026#39;切片-CPU最大负载(1分钟)\u0026#39;,\u0026#39;切片-内存最大使用-GiB\u0026#39;, \u0026#39;平均宽带速率-MByte/s\u0026#39;, \u0026#39;最小宽带速率-MByte/s\u0026#39;, \u0026#39;最大宽带速率-MByte/s\u0026#39;, \u0026#39;视频总体积-GByte\u0026#39;, \u0026#39;总流程时间(分)\u0026#39;, \u0026#39;存储写入时长(分)\u0026#39;, \u0026#39;存储-%CPU最大使用率\u0026#39;, \u0026#39;存储-CPU最大负载(1分钟)\u0026#39;, \u0026#39;存储-内存最大使用率-GiB\u0026#39; ]; // 设置 X 轴上对应的标签 const c5_169_Data = { labels: c5_169_Labels, datasets: [{ label: \u0026#39;结果\u0026#39;, data: [0, 11.16666667, 0.906666667, 6.707091217, 53.87263617, 8.97, 69.28666667, 1.86, 10.61666667, 0.555555556, 20.66666667, 1.936666667, 24.95719945], backgroundColor: [ \u0026#39;rgba(255, 99, 132, 0.2)\u0026#39;, // 粉色 \u0026#39;rgba(255, 159, 64, 0.2)\u0026#39;, // 橙色 \u0026#39;rgba(255, 205, 86, 0.2)\u0026#39;, // 浅黄色 \u0026#39;rgba(75, 192, 192, 0.2)\u0026#39;, // 青绿色 \u0026#39;rgba(153, 102, 255, 0.2)\u0026#39;, // 紫罗兰 \u0026#39;rgba(255, 206, 86, 0.2)\u0026#39;, // 金色 \u0026#39;rgba(75, 191, 92, 0.2)\u0026#39;, // 橄榄绿 \u0026#39;rgba(120, 75, 192, 0.2)\u0026#39;, // 深紫罗兰 \u0026#39;rgba(255, 92, 159, 0.2)\u0026#39;, // 品红色 \u0026#39;rgba(92, 255, 206, 0.2)\u0026#39;, // 浅绿松石色 \u0026#39;rgba(206, 92, 255, 0.2)\u0026#39;, // 浅洋红色 \u0026#39;rgba(159, 255, 92, 0.2)\u0026#39;, // 浅黄色绿色 \u0026#39;rgba(102, 86, 255, 0.2)\u0026#39; // 浅灰蓝色 ], borderColor: [ \u0026#39;rgb(255, 99, 132)\u0026#39;, // 粉色 \u0026#39;rgb(255, 159, 64)\u0026#39;, // 橙色 \u0026#39;rgb(255, 205, 86)\u0026#39;, // 浅黄色 \u0026#39;rgb(75, 192, 192)\u0026#39;, // 青绿色 \u0026#39;rgb(153, 102, 255)\u0026#39;, // 紫罗兰 \u0026#39;rgb(255, 206, 86)\u0026#39;, // 金色 \u0026#39;rgb(75, 191, 92)\u0026#39;, // 橄榄绿 \u0026#39;rgb(120, 75, 192)\u0026#39;, // 深紫罗兰 \u0026#39;rgb(255, 92, 159)\u0026#39;, // 品红色 \u0026#39;rgb(92, 255, 206)\u0026#39;, // 浅绿松石色 \u0026#39;rgb(206, 92, 255)\u0026#39;, // 浅洋红色 \u0026#39;rgb(159, 255, 92)\u0026#39;, // 浅黄色绿色 \u0026#39;rgb(102, 86, 255)\u0026#39; // 浅灰蓝色 ], borderWidth: 1 // 设置线条宽度 }] }; const c5_169_Config = { type: \u0026#39;bar\u0026#39;, // 设置图表类型 data: c5_169_Data, // 设置数据集 options: { scales: { y: { beginAtZero: true // 设置 y 轴从 0 开始 } }, plugins: { title: { display: true, text: \u0026#39;\u0026#39; // 这里设置图表的标题 }, datalabels: { anchor: \u0026#39;end\u0026#39;, align: \u0026#39;top\u0026#39;, formatter: function(value, context) { return value.toFixed(2); // 设置标签格式 } } } }, plugins: [ChartDataLabels] }; const c5_169_Chart = new Chart(c5_169_Ctx, c5_169_Config); const c5_165_ctx = document.getElementById(\u0026#39;c5_165\u0026#39;); const c5_165_labels = [\u0026#39;avg-wMB/s\u0026#39;, \u0026#39;min-wMB/s\u0026#39;, \u0026#39;max-wMB/s\u0026#39;,\u0026#39;avg-w_await\u0026#39;, \u0026#39;min-w_await\u0026#39;, \u0026#39;max-w_await\u0026#39;, \u0026#39;avg-%util\u0026#39;, \u0026#39;min-%util\u0026#39;, \u0026#39;max-%util\u0026#39;]; // 设置 X 轴上对应的标签 const c5_165_data = { labels: c5_165_labels, datasets: [{ label: \u0026#39;sdb\u0026#39;, data: [52.36925926, 5.89, 83.85, 28.26445534, 8.703333333, 59.62, 89.57178649, 28.28333333, 98.7], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }, { label: \u0026#39;sdc\u0026#39;, data: [52.37021786, 6.886666667, 83.69333333, 26.18413943, 7.443333333, 60.51333333, 87.21247277, 23.35, 97.43333333], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }, { label: \u0026#39;sdd\u0026#39;, data: [52.37001089, 6.553333333, 83.18666667, 26.98811547, 8.673333333, 56.51, 89.42472767, 26.16666667, 98.3], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }] }; const c5_165_config = { type: \u0026#39;bar\u0026#39;, // 设置图表类型 data: c5_165_data, // 设置数据集 options: { scales: { y: { beginAtZero: true // 设置 y 轴从 0 开始 } }, plugins: { title: { display: true, text: \u0026#39;存储-硬盘信息\u0026#39; // 这里设置图表的标题 }, datalabels: { anchor: \u0026#39;end\u0026#39;, align: \u0026#39;top\u0026#39;, formatter: function(value, context) { return value.toFixed(2); // 设置标签格式 } } } }, plugins: [ChartDataLabels] }; const c5_165_Chart = new Chart(c5_165_ctx, c5_165_config); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; chart.js还是比较强的，可以访问Chart.js学习使用。\nPart7. 最后要说的话 本文一是对本次测试做下总结，二是希望能够供读者们借鉴。\n整个过程还是挺漫长的，即要等待每轮测试结束，还要分析整理数据并制作成图表。不过完成这个性能测试，确给我带来了成就感。也知道自己还有很多不足，希望有大佬同我交流讨论，共同进步。\n本篇就在此止步了。\n","date":"2024-05-28T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Other/Performance/0.png","permalink":"https://www.jzy-blogs.cn/p/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","title":"记一次性能测试"},{"content":"CSV Data Set Config CSV Data Set Config是一种元件。它允许你从CSV、TXT文件中读取数据，并在测试计划的运行过程中将这些数据作为变量使用。这在进行性能测试时非常有用，尤其是当你需要模拟大量用户使用不同的输入数据时。可以添加在测试计划、线程组、取样器下，作用域也随之变化。\n我们在线程组文章中使用过CSV Data Set Config，相信大家已经明白它的作用。这里就再详细描述一下。\nPart1.文件名 需输入数据文件的路径，运行时Jmeter会按路径查找数据文件。如果路径错误，Jmeter会报错。\n如果路径错误。\nJMeter提示试图读取一个名为test.txt的文件，但是这个文件不存在或者JMeter没有读取它的权限。\nPart2.文件编码 编码是计算机用于表示字符的数字或二进制值。以下是一些常见的编码系统及其特点：\nASCII (American Standard Code for Information Interchange)\n编码范围：0-127 字符集：基本的英文字符、数字、标点符号和控制字符。 Extended ASCII\n编码范围：128-255 字符集：在ASCII基础上扩展，包含其他语言的字符。 ISO 8859-1 (Latin-1 Character Set)\n编码范围：0-255 字符集：扩展了ASCII，包括西欧语言的特殊字符。 UTF-8 (Unicode Transformation Format - 8-bit)\n编码范围：1-4字节 字符集：支持全球几乎所有语言的字符，包括表情符号等。 UTF-16 (Unicode Transformation Format - 16-bit)\n编码范围：2字节（BMP）或4字节（辅助平面） 字符集：同UTF-8，但使用固定长度的字节对。 UTF-32 (Unicode Transformation Format - 32-bit)\n编码范围：固定4字节 字符集：同UTF-8和UTF-16，但每个字符固定占用4字节。 GBK (Chinese Internal Code Specification)\n编码范围：双字节 字符集：主要用于简体中文。 GB2312\n编码范围：单字节和双字节 字符集：主要用于简体中文，是GBK的前身。 Big5\n编码范围：双字节 字符集：主要用于繁体中文。 Shift_JIS (Shifting Japanese Industrial Standards)\n编码范围：单字节和双字节 字符集：主要用于日文。 EUC-JP (Extended Unix Code - Japanese)\n编码范围：多字节 字符集：主要用于日文。 KOI8-R (KOI8 Russian)\n编码范围：单字节 字符集：主要用于俄文。 这些编码系统各有特点，适用于不同的语言和场景。随着全球化的发展，UTF-8因其兼容性和效率成为了最广泛使用的编码方式。\n推荐使用UTF-8编码，因为它可以表示任何语言的字符，并且是Web标准。几乎所有的现代文本编辑器、浏览器和编程语言都支持UTF-8。如遇到一些UTF-8无法兼容的语言，可以选择或编辑添加其他编码。\nPart3.变量名称 数据文件中，1列对应1个变量，从左依次对应。变量名称不应多于列数。每次读取1行。以TXT文件为例：\n111,222,333,444,555,666,777 aaa,bbb,ccc,ddd,eee,fff,ggg 数据文件中有5列，代表有7个变量。变量名称可以输入a1,a2,a3,a4,a5,a6,a7，a1获取第1列，a7获取第7列。a1第1次获取111，a1第2次获取aaa。\nPart4.忽略首行 如果数据文件的第一行包含列标题，可以使用此选项跳过第一行，只读取数据。以csv文件为例：\n姓名 联系方式 居住地址 性别 国家 民族 兴趣爱好 姜 17620815555 河南 男 中国 汉 读书 刘备 信使传信 汉蜀 男 蜀国 汉 当皇帝 第1行只是标题，实际上并不需要标题数据。这种情况下可以选择True，不获取第1行。\nPart5.分隔符 不建议更改，使用,(英文符)即可。这代表着TXT文件中列于列之间要用,分隔。\nPart6.是否允许带引号 以TXT文件为例：\n\u0026#34;444\u0026#34; 如果选择True，引用变量时，获取的值会是444。如果选择False，引用变量时，获取的值会是\u0026quot;444\u0026quot;。\nPart7.遇到文件结束符再次循环 文件结束符（End Of File，简称EOF）是一个用于表示文件内容结束的信号，在txt、csv等文件的未尾以\u0026lt;EOF\u0026gt;结束。当程序读取文件时，以\u0026lt;EOF\u0026gt;来确定是否已经到达文件的末尾。\n当读取到文件的结束符\u0026lt;EOF\u0026gt;，线程或循环还没结束时。如果选择True，接下来的线程或循环会继续从文件的首行开始（可能忽略首行）。如果选择False，接下来的线程或循环会一直获取文件的结束符\u0026lt;EOF\u0026gt;。\nPart8.遇到文件结束符停止线程 当读取到文件的结束符\u0026lt;EOF\u0026gt;，线程或循环还没结束时。如果选择True，接下来的线程或循环不会再继续。如果选择False，不会影响到线程或循环的继续。\nPart9.线程共享模式 示例txt文件\n111,222,333,444 aaa,bbb,ccc,ddd 888,999,1010,2020 fff,iii,jjj,kkk 6060,7070,8080,9090 000,ppp,qqq,rrr 示例Jmeter脚本\n此时只有1个线程，线程共享模式配置为所有线程。\n所有线程 所有线程共享同一个CSV文件。这是默认的共享模式。在这个模式下，所有线程将按照顺序读取CSV文件中的数据，直到文件结束。\n示例Jmeter脚本运行结果\n请求1、请求2同属1个线程，从CSV Data Set Config中所获取的数据也是一样的。\n修改示例Jmeter脚本，线程组的线程数为 2 ，运行结果\n线程组1-1的请求1、请求2，从CSV Data Set Config中所获取的数据相同。线程组1-2的请求1、请求2，从CSV Data Set Config中所获取的数据相同。不同线程所获取的数据不同。\n修改示例Jmeter脚本，新增一个线程组\n运行结果\n两个线程组，每个线程组两个线程，共四个线程。这四个线程顺序从CSV Data Set Config获取数据。\n当前线程组 在这个模式下，只有同一个线程组内的线程会共享CSV文件。比如数据文件有10行数据，并且有10个线程在同一个线程组中，每个线程将分别读取一行数据。不同的线程组分别独立从CSV Data Set Config获取数据。\n修改示例Jmeter脚本，新增一个线程组，CSV Data Set Config 线程共享模式配置为 当前线程组\n运行结果\n同是两个线程组、每个线程组两个线程。但配置当前线程组共享，两个线程组分别独立从CSV Data Set Config获取数据。所以线程组1-1与线程组2-1获取的数据一致。\n当前线程 在这个模式下，不同线程不会共享CSV文件，分别独立从CSV Data Set Config获取数据。\n当前线程组-Jmeter脚本中，CSV Data Set Config 线程共享模式配置为 当前线程，运行结果\n每个线程都独立从CSV Data Set Config获取数据。所以各个线程获取的数据是一致的。\nPart10.循环\u0026amp;\u0026amp;编辑 其中忽略首行、是否允许带引号、遇到文件结束符再次循环、遇到文件结束符停止线程、线程共享模式的选项中还有编辑选项。因没有使用过，我并不知怎样使用及作用。读者们可以去探究一番。\n另外在使用CSV Data Set Config时，要注意线程数及循环次数。\n配置所有线程，如果有2个线程组、每个线程组2个线程及多次循环，数据文件有100行。运行时，第1次循环。2个线程组总4个线程依次获取数据文件的前4行。第2次循环。2个线程组总4个线程依次获取数据文件的5-8行。依次类推从数据文件中获取数据。\n配置当前线程组，如果有2个线程组、每个线程组2个线程及多次循环，数据文件有100行。 运行时，第1次循环。每个线程组独立从数据文件中获取数据，每个线程组中的2个线程依次获取数据文件的前2行。第2次循环。每个线程组独立从数据文件中获取数据，每个线程组中的2个线程依次获取数据文件的3-4行。依次类推从数据文件中获取数据。\n配置当前线程，如果有2个线程组、每个线程组2个线程及多次循环，数据文件有100行。 运行时，第1次循环。每个线程独立从数据文件中获取数据，每个线程获取数据文件的第1行。第2次循环。每个线程独立从数据文件中获取数据，每个线程获取数据文件的第2行。依次类推从数据文件中获取数据。\nPart11.最后要说 衷心希望读者进行评论，指出我的不足或者进行交流。\n就让笔迹停在这里吧。\n","date":"2024-05-14T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-csv-data-set-config/","title":"Jmeter-CSV Data Set Config"},{"content":"Part1.背景 咱们测试同学有时候不得不需要自己去搭建一个测试环境，保证自己的测试可以顺畅进行。测试环境可以运行在物理机或者虚拟机上。测试环境在物理机上无疑更真实、准确，但物理机价格、便捷方面都不如虚拟机。而且虚拟机通过精心搭配，真实、准确方面也不容小觑。\n现在市面上可以搭建虚拟机的软件不少。如Vmware、VirtualBox、QEMU、Parallels Desktop、Microsoft Hyper-V等。我为什么推荐VMware呢？因为我第一次搭建虚拟机使用的就是它，而且只用过它😅。无论如何，开始我们的VMware之旅吧。\nPart2.准备VMware 下载VMware\nVMware下载地址包含Mac和window版本\rhttps://www.vmware.com/products/desktop-hypervisor.html\r根据自己的系统去下载对应版本\n请注意这里下载的是Pro版本，是收费的。你也可以去下载免费版本，或者去搜激活码来进行激活。不过你懂的。我不提供方法。\n安装VMware\n下载成功后，双击安装后一直下一步就行。然后界面如下：\n我这里已经搭建了2个虚拟机了，你们刚进去的时候，是没有这两个虚拟机的。\nPart3.新建虚拟机 如图.\n此时一个虚拟机就搭建好了。图中的测试安装centos 7。\nPart4.设置虚拟机 后面还需要对虚拟机进行一些设置，才能达成目的。\n有关网络连接的知识可以点击下方卡片进行了解。\n使用 VMware Workstation Pro\rhttps://docs.vmware.com/cn/VMware-Workstation-Pro/17/com.vmware.ws.using.doc/GUID-0CE1AE01-7E79-41BB-9EA8-4F839BE40E1A.html\rPart5.运行虚拟机 点击运行虚拟机后，VMware开始运行ISO镜像文件。然后就是各个系统经典的初始化界面。我这里以centos 7 为例。\n以上示例的是centos7。需要知道的是，每个系统的初始化界面可能有区别。比如windows一定与centos 7不同。\nPart6.网络配置 此时安装好的centos 7还不能访问inter网、局域网，甚至主机。访问其他网络，需要进行一些配置。我们以桥接模式为例。\nVMware上进行设置\ncentos 7上进行配置\n查看网口信息\n# 查看网口信息 ip link # 示例centos 7，输出信息如下： 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: ens33: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:0c:29:cf:f0:d8 brd ff:ff:ff:ff:ff:ff 输出的网口信息有lo、ens33.\nlo 是本地回环接口，通常用于本地主机上的网络服务。它总是激活的，并且可以用于本地主机上的网络请求。\nens33 是一个以太网接口。这个接口是连接到物理网络的，但是当前的输出并没有显示IP地址分配情况。\n编辑网络配置文件。\n# 编辑ens33的配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置网络接口\n# 只需要自动分配IP就行。修改以下配置。 BOOTPROTO=dhcp ONBOOT=yes 重启网络服务：\n# 保存并关闭配置文件，然后重启网络服务以应用更改 sudo systemctl restart network 验证网络配置\n# 使用ping命令测试网络连接 ping -c 4 8.8.8.8 # 使用ip addr 检查IP地址 ip addr 远程连接\n使用MobaXterm远程。\n如果远程失败，可以使用systemctl stop firewalld关闭防火墙，再远程。\n以上以centos 7为示例。其他系统的IP设置可能不是这样，至少windows肯定与centos 7不同。\nPart7.最后要说 到这一步呢，距离你搭建完整的测试环境，只剩下部署你们的产品了。我就没有发言权了。另外还有网络这块，VMware还有NAT模式、仅主机模式、自定义、LAN区段值得探讨。除此之外，还有其他的内容。不过都放在之后的文章中吧，本文不在阐述。\n","date":"2024-05-10T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Other/VMware1/0.png","permalink":"https://www.jzy-blogs.cn/p/%E4%BD%BF%E7%94%A8vmware%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/","title":"使用VMware搭建测试环境"},{"content":"HTTP请求 JMeter提供多种取样器，HTTP取样器（HTTP Sampler）无疑是最核心的一个。HTTP取样器是用来模拟客户端和服务器之间HTTP请求和接收响应的工具，它可以发送各种类型的HTTP请求，如GET、POST、PUT、DELETE等，用于请求不同的资源。\nHTTP取样器控制面板中包含元素：\n名称、注释\nweb服务器\nHTTP请求\n参数\n消息体数据\n文件上传\n客户端实现\n超时\n从HTML文件获取所有内含的资源\n源地址\n代理服务器\n其他任务\nPart1.web服务器\u0026amp;\u0026amp;HTTP请求 web服务器没什么好讲的，只保证IP/域名、端口、路径、请求方式、协议正确就好。内容编码最好输入UTF-8(兼容大部分语言)，防止接口解析时乱码。\n自动重定向和跟随重定向 自动重定向只针对Get和Head请求，自动重定向转向到最终目标页面，但是Jmeter不记录重定向的中间页面过程，只记录最终页面返回结果。在结果树中，只能看到最终页面的服务器返回。\n跟随重定向是http request 取样器的默认选项，会自动跳转到目标地址。Jmeter会记录重定向过程中的所有请求的响应结果。在结果树中，可以看到所有请求的服务器返回。\n两者只能选中一个。这次我们访问知乎来进行测试。\n示例Jmeter脚本\n测试计划中添加线程组\n线程组中添加HTTP取样器\n请求地址：HTTPS://www.zhihu.com\n请求方式：GET\n测试计划中添加查看结果树\n勾选跟随重定向，运行结果\nHTTP请求-0的GET https（请求地址）为//www.zhihu.com/，HTTP请求-1的GET https（请求地址）为//www.zhihu.com/signin?next=%2F。\nHTTP请求-0的响应数据是一个重定向的a链接，链接地址为//www.zhihu.com/signin?next=%2F-即HTTP请求-1的请求地址。HTTP请求-1的响应才是最终的页面。Jmeter的查看结果树记录了重定向过程。\n勾选自动重定向，运行结果\n结果树中只有一个HTTP请求，请求地址为//www.zhihu.com/signin?next=%2F-即最终的页面数据。查看结果树中没有记录重定向过程。\n使用KeepAlive 选中该选项，JMeter和目标服务器之间使用Keep-Alive方式进行HTTP通信，默认选中。keep-alive属性，用于建立长连接，可以避免连接频繁建立和释放的开销。有兴趣的可以搜索HTTP的Keep-Alive模式，详细了解。\n与浏览器兼容的头 没有发现有什么作用。希望有知道的读者可以通过评论指正我。\nPart2.请求参数-GET 请求方式为GET时，请求参数一般都直接跟在url后面，不需要参数类型。当然也可以请求参数不跟在url后面，不过比较少见。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest2/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def parameters(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#34;此次请求的请求方式是GET，请求参数为: name=\u0026#34;+request.args.get(\u0026#39;name\u0026#39;) return \u0026#34;请使用GET请求方式\u0026#34; 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest2/\n请求方式：GET\n参数名称：name\n参数值：随意写就行\n测试计划中添加查看结果树\nGET请求下，使用参数发送请求，运行结果\n仔细看请求数据中的第一行，它的值为：GET http://127.0.0.1:5000/api/HTTPRequest2/?name=姜。\n其中?name=姜就是脚本中添加的参数。\n必须使用参数吗？我们可以尝试一下不使用参数的方法（修改示例脚本）\nHTTP 请求中删除参数\nHTTP 请求中路径改为/api/HTTPRequest2/?name=姜\n看一下修改示例脚本后的运行结果\n仔细看图会发现，与使用参数方法的结果是一样的。\n请求中GET http://127.0.0.1:5000/api/HTTPRequest2/?name=姜 一样。\nPart3.请求参数-POST\u0026amp;application/x-www-from-urlencoded 请求参数为POST时，常用的的请求参数类型(Content-Type)有application/x-www-from-urlencoded、multipart/form-data、raw、binary。\napplication/x-www-from-urlencoded会将表单内的数据转换为键值对，比如name=python\u0026amp;age = 22，这种方式只能以键值对形式发送参数，一般如果不指定content-type，默认便是application/x-www-form-urlencoded。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest2/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def parameters(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#34;此次请求的请求方式是GET，请求参数为: name=\u0026#34;+request.args.get(\u0026#39;name\u0026#39;) return \u0026#34;请使用GET请求方式\u0026#34; 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest2/\n请求方式：POST\n参数名称：随意写就行\n参数值：随意写就行\n测试计划中添加查看结果树\n运行结果\nRequest Headers中的Content-Type: application/x-www-form-urlencoded; charset=UTF-8，表明该请求参数类型为application/x-www-form-urlencoded。\nRequest Body中的POST data也是键值对形式： aaaa=EtherealBoyJIang\u0026amp;bbb=EtherealBoyJIang\u0026amp;ccc=EtherealBoyJIang\nPart4.请求参数-POST\u0026amp;multipart/form-data multipart/form-data会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。就像这样：\nPOST /profile HTTP/1.1 HOST: example.com Content-Type: multipart/form-data; boundary=example-part-boundary # multipart/form-data; boundary=example-part-boundary表示这个请求的的消息类型是 # multipart-form-data，每个 part 之间的边界为 example-part-boundary。 # example-part-boundary是一段很长的字符串，如bqtFfLzQXUbOvsHrs8eOO9kIlZ30hA。 --example-part-boundary Content-Disposition: form-data; name=\u0026#34;username\u0026#34; Content-Type: text/plain Nicholas # 第一个 part 的类型为 text/plain，它在表单上对应的 key 为 username，value 为 Nicholas --example-part-boundary Content-Disposition: form-data; name=\u0026#34;address\u0026#34; Content-Type: application/json { \u0026#34;country\u0026#34;: \u0026#34;China\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Beijing\u0026#34; } # 第二个 part 的类型为 application/json，它在表单上对应的 key 为 address。 --example-part-boundary Content-Disposition: form-data; name=\u0026#34;avatar\u0026#34;; filename=\u0026#34;my_avatar.jpeg\u0026#34; Content-Type: image/jpeg \u0026lt;binary-image data\u0026gt; # 第三个 part 的数据类型为 image/jpeg，它在表单上对应的 key 为 avatar， # 并且 part 的头部还附加了文件名相关的元数据 filename=\u0026#34;my_avatar.jpeg。 --example-part-boundary-- # 最后面的 --example-part-boundary-- 表示整个 multipart 消息的结束。 由于这种方式可以将数据分为很多部分，它既可以上传键值对，也可以上传文件，甚至多个文件。当上传的字段是文件时，会有Content-Type来说明文件类型：Content-disposition，用来说明字段的一些信息。 每部分都是以-boundary开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容(字段、文本或二进制等)。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以-boundary-标示结束。\n当使用POST方式进行请求\u0026amp;请求参数包含一般参数\u0026amp;文件时，会自动指定参数类型为multipart/form-data。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest1/\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def upload_file(): if \u0026#39;username\u0026#39; not in request.form: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;缺少username字段\u0026#39;}), 400 if \u0026#39;address\u0026#39; not in request.form: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;缺少address字段\u0026#39;}), 400 if \u0026#39;image\u0026#39; not in request.files: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;缺少image字段\u0026#39;}), 400 username = request.form[\u0026#39;username\u0026#39;] address = request.form[\u0026#39;address\u0026#39;] image_file = request.files[\u0026#39;image\u0026#39;] if image_file.filename == \u0026#39;\u0026#39;: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;未选择文件\u0026#39;}), 400 if image_file: filename = secure_filename(image_file.filename) save_path = \u0026#39;C:/image/\u0026#39; # 指定保存路径 # 检查保存路径是否存在，如果不存在则创建 if not os.path.exists(save_path): os.makedirs(save_path) # 保存文件到指定保存路径，Jmeter请求后可以到save_path指定路径查看上传的文件 image_file.save(os.path.join(save_path, filename)) return jsonify({ \u0026#39;username\u0026#39;: username, \u0026#39;address\u0026#39;: address, \u0026#39;avatar_filename\u0026#39;: filename }), 200 return jsonify({\u0026#39;error\u0026#39;: \u0026#39;未选择文件\u0026#39;}), 400 示例Jmeter脚本\n测试计划中添加线程组\n线程组中添加HTTP 取样器\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest1/\n请求方式：POST\n参数1名称：username\n参数1值:EtherealBoyJIang\n参数2名称：address\n参数2值:{\u0026quot;country\u0026quot;: \u0026quot;中国\u0026quot;,\u0026quot;city\u0026quot;: \u0026quot;杭州\u0026quot; }\n文件上传名称：正确的文件路径（可以上传图片）\n文件上传参数名称：image\n测试计划中添加查看结果树\n运行结果\n可以清晰的看到请求数据的格式是multipart/form-data的格式，响应也是正确的。另外可以去save_path查看上传的图片或文件。\n示例使用的参数中添加请求参数做的演示。当然使用消息体添加请求参数也是一样，并且你可以在消息体中添加Text、JavaScript、JSON、HTML、XML等格式\u0026amp;上传文件。读者可以自己尝试一下。\n使用POST方式进行请求\u0026amp;请求参数包含一般参数\u0026amp;不包含文件时，会自动指定参数类型为application/x-www-form-urlencoded。有没有什么方法指定参数类型为content-type为multipart/form-data呢？你可以勾选对POST使用multipart/ form-data。读者可以自己尝试一下。\nPart5.请求参数-POST\u0026amp;text/plain raw是指可以上传任意格式的文本，如text、json、xml、html等。这里演示一下如何上传文本内容。\ntext/plain用于发送纯文本内容，空格转换为 \u0026ldquo;+\u0026rdquo; 加号，不对特殊字符进行编码，一般用于email之类的；\n在Jmeter中发送纯文本内容，需要在消息体中输入相应内容\u0026amp;不在消息头管理器指定对应的content-type。会自动匹配content-type为text/plain\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest2/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def parameters(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#34;此次请求的请求方式是GET，请求参数为: name=\u0026#34;+request.args.get(\u0026#39;name\u0026#39;) return \u0026#34;请使用GET请求方式\u0026#34; 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest2/\n请求方式：POST\n消息体数据：随意（中间加空格）写就行\n测试计划中添加查看结果树\n运行结果\nRequest Headers中的Content-Type: text/plain; charset=UTF-8，表明该请求参数类型为text/plain。\nRequest Body中的POST data就是纯文本：随意写就行。\nPart6.请求参数-POST\u0026amp;application/json application/json用于发送JSON字符串，也是比较常用的一种方式。\n在Jmeter中发送JSON字符串，需要在消息体中输入JSON格式内容\u0026amp;在消息头管理器指定对应的content-type为content-type为application/json。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest3/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def httprequest3(): if request.method == \u0026#39;POST\u0026#39;: data = request.get_json() if \u0026#34;name\u0026#34; not in data: return \u0026#34;请求参数错误\u0026#34; return \u0026#34;此次请求的请求方式是GET，请求参数为: \u0026#34; + str(data) return \u0026#34;请使用POST请求方式\u0026#34; 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest3/\n请求方式：POST\n消息体数据：{\u0026quot;name\u0026quot;:\u0026quot;EtherealBoyJiang\u0026quot;}\nHTTP 请求中添加HTTP信息请求头管理器（右键-添加-配置元件）\n名称：content-type\n值：application/json\n测试计划中添加查看结果树 运行结果\nRequest Headers中的Content-Type: application/json，表明该请求参数类型为application/json。\nRequest Body中的POST data就是JSON字符串：{\u0026quot;name\u0026quot;:\u0026quot;EtherealBoyJiang\u0026quot;}。\nraw还包括HTML、XML、CSS、JS，上传方法与JSON一样，都是在消息体中输入响应格式的内容，然后再信息头管理器中指定对应的Content-Type。\nHTMl的Content-Type是text/html;XML的Content-Type是text/XML;CSS的Content-Type是text/CSS;JS的Content-Type是text/JS。读者可以自己尝试一下。\nPart7.请求参数-POST\u0026amp;binary binary对应着http请求中的Content-Type:application/octet-stream，只可以上传二进制数据，通常用来上传文件，由于没有键值，所以，一次只能上传二进制文件。\n在Jmeter中发送二进制文件，需要在消息体中输入二进制数据\u0026amp;在消息头管理器指定对应的content-type为application/octet-stream。\n文本转二进制工具\n示例接口\ndef httprequest4(): if request.method != \u0026#39;POST\u0026#39;: return \u0026#39;你的请求方式有误\u0026#39;, 405 if request.content_type == \u0026#39;application/octet-stream\u0026#39;: stream = request.stream data = stream.read() print(data) try: text_data = data.decode(\u0026#39;utf-8\u0026#39;) print(text_data) except UnicodeDecodeError: return \u0026#39;解码错误，数据可能不是UTF-8编码\u0026#39;, 400 binary_strings = text_data.split() decimal_numbers = [int(binary, 2) for binary in binary_strings] unicode_characters = [chr(decimal) for decimal in decimal_numbers] text = \u0026#39;\u0026#39; for x in unicode_characters: text = text + x return text, 200 else: return \u0026#39;不支持的Content-Type\u0026#39;, 415 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest4/\n请求方式：POST\n消息体数据：110001000010001 110011000101111 1001010 1101001 1100001 1101110 1100111（\u0026lsquo;我是Jiang\u0026rsquo;的二进制流）\nHTTP 请求中添加HTTP信息请求头管理器（右键-添加-配置元件）\n名称：content-type\n值：application/octet-stream\n测试计划中添加查看结果树 运行结果\nRequest Headers中的Content-Type: application/octet-stream，表明该请求参数类型为application/octet-stream。\nRequest Body中的POST data就是二进制流：110001000010001 110011000101111 1001010 1101001 1100001 1101110 1100111。\n响应数据我是Jiang正是转换二进制前的文本内容。\nPart8.Http请求默认值 翻跟斗广泛的\n","date":"2024-04-03T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-http%E8%AF%B7%E6%B1%82/","title":"Jmeter-HTTP请求"},{"content":"线程组 线程组作为JMeter测试计划的核心组件之一，对于模拟并发用户的行为至关重要。线程组元件是整个测试计划的入口，所有的取样器和控制器必须放置在线程组下。\n可以将线程组视为一个虚拟用户池，其中每个线程可被理解为一个虚拟用户，多个虚拟用户同时执行相同的一批任务。\n在这个虚拟用户池中，每个线程之间是相互隔离且互不影响的。每个线程的执行过程中，操作的变量不会对其他线程的变量值产生影响。\n线程组的关键任务之一是定义并发用户的行为，包括设置线程数、循环次数、启动延迟等关键参数。通过适当配置线程组，测试人员可以模拟多用户在系统中同时执行任务的场景，从而评估系统的性能和稳定性。\n通过灵活使用setup线程组、线程组、tearDown线程组、开放模型线程组，配置前置操作、主要操作、后置操作，更能真实、详细的评估系统。\n线程组分为四类:\n线程组 setUp线程组 tearDown线程组 开放模型线程组 线程组、setUp线程组、tearDown线程组控制面板中的元素基本一致：\n名称、注释 在取样器错误后执行的动作 线程数 Ramp-Up时间 Same user on each iteration 延迟创建线程直到需要（只有线程组有） 调度器 开放模型线程组控制面板中的元素：\n名称、注释 在取样器错误后执行的动作 调度计划 随机种子 Part1.取样器错误后执行的动作 在JMeter中，取样器（Sampler）是用于模拟用户请求发送到目标服务器的组件，例如HTTP请求、FTP请求等。当取样器执行过程中出现错误时，可以通过配置相应的动作来处理这些错误。以下是一些处理取样器错误时，线程组中常见方式：\n停止线程\n任何一个线程（用户）在执行过程中遇到错误时，该线程被停止，不影响其他线程（用户）。\n启动下一进程循环 任何一个线程（用户）在执行过程中遇到错误时，Jmeter会立即停止当前线程的本次执行，并进行当前线程（用户）的下次执行，主要应用于线程多次循环时。\n继续（无需演示）\nJMeter将在取样器执行错误时，忽略错误继续执行本线程的后续操作及执行其他线程。\n停止线程-多线程 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止线程\n线程数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${yonghu}（在前）、正确请求-${yonghu}\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;200,用户1\n\u0026emsp;\u0026emsp;1111,用户2\n\u0026emsp;\u0026emsp;200,用户3\n文件编码：UTF-8\n变量名称：ceshi,yonghu\n错误请求取样器下添加响应断言\n值：${ceshi}\n在测试计划中，添加查看结果树\n运行结果\n连续运行了3次，结果是一致的。总共有三个用户执行线程组，其中用户1、用户3完全执行成功；用户2只执行了错误请求。\n因为设置取样器错误后执行的动作为停止线程，用户2执行错误请求时发生错误，Jmeter只会停止用户2的后续执行，不会影响其他线程。\n多线程组也是多线程，读者在实际的脚本编写中，要注意每个线程的情况去使用停止线程。\n停止线程-多循环 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止线程\n循环次数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${xunhuan}（在前）、正确请求-${xunhuan}\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;200,第1次循环\n\u0026emsp;\u0026emsp;1111,第2次循环\n\u0026emsp;\u0026emsp;200,第3次循环\n文件编码：UTF-8\n变量名称：ceshi,xunhuan\n错误请求取样器下添加响应断言\n值：${ceshi}\n在测试计划中，添加查看结果树\n运行结果\n连续运行了3次，结果是一致的。用户在第2次循环执行到错误请求时，Jmeter停止测试。\n因为设置取样器错误后执行的动作为停止线程，用户的第2次循环，执行错误请求时发生错误，Jmeter停止用户的后续执行（就它一个线程）。\n启动下一进程循环 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选启动下一线程循环\n循环次数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${xunhuan}（在前）、正确请求-${xunhuan}\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;200,第1次循环\n\u0026emsp;\u0026emsp;1111,第2次循环\n\u0026emsp;\u0026emsp;200,第3次循环\n文件编码：UTF-8\n变量名称：ceshi,xunhuan\n错误请求取样器下添加响应断言\n值：${ceshi}\n在测试计划中，添加查看结果树\n运行结果\n连续运行了3次，结果是一致的。用户执行了3次循环，其中第2次循环中，错误请求出现错误，跳过正确请求。\n因为设置取样器错误后执行的动作为启动下一线程循环，用户的第2次循环，执行错误请求时发生错误，Jmeter会跳过用户的本次执行，进行用户的后续执行。\nPart2.ramp-up时间 ramp-up时间用于设置启动所有线程所需要的时间。例如：线程数设置为10，ramp-up时间设置为100秒，那么JMeter将使用100秒使10个用户启动并运行，即每个用户将在前一个用户启动后的10秒启动。\n如果ramp-up值设置得很小、线程数又设置得很大，刚开始执行测试时会对服务器产生很大的压力。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\nRamp-Up时间：9\n线程数：3\n线程组下添加1个HTTP 请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行结果\n连续运行了3次，结果是一致的。3个用户执行线程组，各个用户的请求时间分别为2024-04-15 16:12:37 CST、2024-04-15 16:12:40 CST、2024-04-15 16:12:43 CST。\n3个用户执行请求的间隔时间正好是3秒，即ramp-up时间/线程数。\nPart3.same user on each iteration（在每次迭代中使用相同的用户） 没有研究出来它有什么用。经过我的测试，same user on each iteration（在每次迭代中使用相同的用户）启用与否，作用是一样的。\n如读者对此有不同见解，欢迎与我联系，共同探讨。目前，我十分费解。\nPart4.延迟创建线程直到需要 当在JMeter中启用延迟创建线程直到需要时，JMeter会根据预设的Ramp-up时间动态地分配线程。假设Ramp-up时间设置为20秒，线程数为10，那么JMeter会在测试启动后立即创建第一个线程并开始请求处理。随后，每隔2秒，JMeter将创建下一个线程，直到所有线程都被启动。\n如果关闭“延迟创建线程直到需要”选项，JMeter会在测试开始时一次性创建所有线程。使用同样的参数，即在测试一开始，JMeter会立即创建全部的10个线程。这些线程会按照设定的“Ramp-up时间”进行执行，每个线程将间隔2秒启动。\n延迟创建线程直到需要这一配置的目的是为了应对测试机性能有限的情况。通过这种方式，可以避免在测试初期就创建所有线程，导致资源过度占用和可能的性能问题。这种方法有助于平滑地增加系统负载，同时防止资源瞬间紧张导致测试无法正常进行。\nPart5.调度器-启动延迟 调度器主要控制线程操作时间。启用调度器后，可以输入持续时间（值不能为空），启动延迟来控制线程组的操作时间及线程组操作前的延迟时间。\n同时输入持续时间，启动延迟时，先计算启动延迟，再计算持续时间。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n启用调度器\n持续时间：10\n启动延迟：3\n线程组下添加1个HTTP 请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行结果\n注意看图中右上角-黄色三角形左边的计时器，值固定在2秒。这个计时器计算整个测试计划的持续时间。由于示例请求的接口响应较快，可以理解为计时器的时间就是HTTP请求时的时间。\n因为启动延迟设置为3秒，所以HTTP请求会在延迟3秒执行。不过计时器的时间是2秒，误差1秒。我多次试过把持续时间、启动延迟的时间拉长，误差还是1秒。\nPart6.调度器-持续时间 持续时间用于控制线程组的执行时间。比如持续时间设置为100秒，就算循环设置为永远，执行100秒后，线程组也会结束执行，不在发送新的请求。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup6/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup6(): sleep(3) return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n启用调度器\n持续时间：2\n线程组下添加1个HTTP 请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup6/\n请求方式：GET\nHTTP 请求下添加1个固定定时器\n值：3000\n在测试计划中，添加查看结果树\n运行结果\n图中结果树中什么都没有，这是因为线程组的持续时间只有2秒，但固定定时器的延迟有3秒，导致还未执行取样器，持续时间已经结束。\n此时删掉固定定时器，运行结果\n此时有人会有疑问。接口中设置的休眠时间就已经是3秒了，脚本中的持续时间还只是2秒，为什么这次成功执行了呢？\n持续时间的设置，只作用与还未执行的取样器。已经执行的取样器，无论等待多长时间，都会执行完成。\n本文示例接口源代码可从前言中下载。\n","date":"2024-03-30T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%8B%E7%AF%87/","title":"Jmeter-线程组下篇"},{"content":"线程组 线程组作为JMeter测试计划的核心组件之一，对于模拟并发用户的行为至关重要。线程组元件是整个测试计划的入口，所有的取样器和控制器必须放置在线程组下。\n可以将线程组视为一个虚拟用户池，其中每个线程可被理解为一个虚拟用户，多个虚拟用户同时执行相同的一批任务。\n在这个虚拟用户池中，每个线程之间是相互隔离且互不影响的。每个线程的执行过程中，操作的变量不会对其他线程的变量值产生影响。\n线程组的关键任务之一是定义并发用户的行为，包括设置线程数、循环次数、启动延迟等关键参数。通过适当配置线程组，测试人员可以模拟多用户在系统中同时执行任务的场景，从而评估系统的性能和稳定性。\n通过灵活使用setup线程组、线程组、tearDown线程组、开放模型线程组，配置前置操作、主要操作、后置操作，更能真实、详细的评估系统。\n线程组分为四类:\n线程组 setUp线程组 tearDown线程组 开放模型线程组 线程组、setUp线程组、tearDown线程组控制面板中的元素基本一致：\n名称、注释 在取样器错误后执行的动作 线程数 Ramp-Up时间 Same user on each iteration 延迟创建线程直到需要（只有线程组有） 调度器 开放模型线程组控制面板中的元素：\n名称、注释 在取样器错误后执行的动作 调度计划 随机种子 执行顺序 在JMeter中，setUp线程组拥有最高的优先级，而tearDown线程组则具有最低的优先级。这一优先级关系可用表达式表示为：setUp线程组 \u0026gt; 线程组 = 开放模型线程组 \u0026gt; tearDown线程组。\n这意味着在测试计划执行过程中，setUp线程组将首先执行，其后是线程组和开放模型线程组，最后执行tearDown线程组。\n通常情况下，setUp线程组用于在测试执行之前进行一些初始化工作，而tearDown线程组用于测试执行结束后的清理工作。 其他线程组在测试执行过程中按照它们在测试计划中的顺序执行。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup1(): sleep(3) # 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 return \u0026#34;我是响应\u0026#34; 示例Jmeter脚本\n在测试计划中，分别添加tearDown线程组、线程组、setUp线程组\n在tearDown线程组、线程组、setUp线程组下分别添加HTTP请求取样器\n名称分别为：tearDown线程组、线程组、setUp线程组\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup1/\n请求方式：GET\n在测试计划下添加查看结果树\n运行结果\n可以观察到在2024-04-03 15:00:07 时，setUp线程组中的取样器发送了请求。\n随后，在 2024-04-03 15:00:10 时，线程组中的请求取样器也发出了请求。\n最后，在 2024-04-03 15:00:13时，tearDown线程组请求取样器发出了请求。\n取样器的请求时间间隔与接口设置的休眠时间一致，表明 JMeter 先执行setUp线程组，随后执行线程组，最后执行 tearDown线程组 。即使脚本中的顺序不是这样。\nJmeter中线程组的执行顺序可以归纳为：setUp线程组 \u0026gt; 线程组 = 开放模型线程组 \u0026gt; tearDown线程组。\n线程数 线程组中的线程数指的是同时运行的虚拟用户数量。这个数量决定了你的测试将模拟多少个用户同时访问目标应用程序或服务。\n在JMeter的线程组配置中，你可以根据你的需求来设置线程数，通常是根据你想要模拟的用户负载量和你的系统资源来决定的。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup2/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup1(): return \u0026#34;我是响应\u0026#34; 示例Jmeter脚本\n测试计划下，添加1个线程组\n线程数：3\n在线程组下，添加HTTP请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup2/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行结果\n图中取样器结果中的Thread Name分别为线程组 1-1、线程组 1-2、线程组 1-3。这是因为线程组中线程数值为3，Jmeter启功了3个线程，每个线程皆执行1次线程组。\n在Jmeter中1个线程就代表1个用户，现在就相当于3个用户一起执行线程组。\n循环次数 在JMeter中，循环次数是指每个线程（即虚拟用户）执行其测试计划的次数。这个数量决定了你的测试将模拟用户访问目标应用程序或服务的次数。\n在JMeter的线程组配置中，你可以根据你的需求来设置循环次数，通常是根据你想要模拟的用户访问上限值，如抽奖次数。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup2/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup1(): return \u0026#34;我是响应\u0026#34; 示例Jmeter脚本\n测试计划下，添加1个线程组\n循环次数：3\n在线程组下，添加HTTP请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup2/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行结果\n图中取样器结果中的Thread Name皆为线程组 1-1。这是因为线程组中循环次数值为3，Jmeter启功了1个线程，连续执行了3次线程组。\n在Jmeter中1个线程就代表1个用户，现在就相当于1个用户执行了3次线程组。\n取样器错误后执行的动作 在JMeter中，取样器（Sampler）是用于模拟用户请求发送到目标服务器的组件，例如HTTP请求、FTP请求等。当取样器执行过程中出现错误时，可以通过配置相应的动作来处理这些错误。以下是一些处理取样器错误时，线程组中常见方式：\n停止测试\n任何一个取样器在执行过程中遇到错误时，整个测试计划将会在所有当前正在执行的线程执行完毕后停止。\n立即停止测试 任何一个取样器在执行过程中遇到错误时，JMeter会立即停止当前运行的测试，不再执行任何后续的请求或操作。\n通过合理配置这些错误处理方式，可以根据测试需求和场景来控制测试计划的行为，确保对错误有适当的响应和处理。\n停止测试-单线程组\u0026amp;单线程 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup3(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止测试\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求（在前）、正确请求（在后）\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup3/\n错误请求的请求方式：GET\n正确请求的请求方式：POST\n错误请求取样器下添加响应断言\n值：1111\n在测试计划中，添加查看结果树\n运行结果\n图中连续请求了三次，结果是一致的。\n取样器在线程组中一般是从上至下顺序执行。错误请求的结果报错后，因为设置取样器错误后执行的动作为停止测试，同时没有其他正在执行的线程，Jmeter直接结束本次测试。\n删除响应断言，再次运行\n图中连续请求了三次，结果是一致的。因为错误请求的结果没有报错，会继续执行正确请求。\n停止测试-单线程组\u0026amp;多线程 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup3(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止测试\n线程数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${yonghu}（在前）、正确请求-${yonghu}（在后）\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup3/\n错误请求的请求方式：GET\n正确请求的请求方式：POST\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;500,用户1\n\u0026emsp;\u0026emsp;1111,用户2\n\u0026emsp;\u0026emsp;500,用户3\n文件编码：UTF-8\n变量名称：ceshi,yonghu\n错误请求取样器下添加响应断言\n值：${ceshi}$\n在测试计划中，添加查看结果树\n运行结果\n图中连续请求了三次，结果是一致的。\n可以看到每次执行都是执行完用户1的线程后，因为设置取样器错误后执行的动作为停止测试，执行用户2-错误请求时发生错误，同时没有其他正在执行的线程，Jmeter直接结束本次测试。\n从这次测试中还可以看出，不仅线程组下的取样器有执行顺序，多线程也有执行顺序，即用户1\u0026gt;用户2\u0026gt;用户3。\n停止测试-单线程组\u0026amp;多循环 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup3(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止测试\n循环次数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${xunhuan}（在前）、正确请求-${xunhuan}（在后）\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup3/\n错误请求的请求方式：GET\n正确请求的请求方式：POST\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;500,第1次循环\n\u0026emsp;\u0026emsp;1111,第2次循环\n\u0026emsp;\u0026emsp;500,第3次循环\n文件编码：UTF-8\n变量名称：ceshi,xunhuan\n错误请求取样器下添加响应断言\n值：${ceshi}$\n在测试计划中，添加查看结果树\n运行结果\n图中连续请求了三次，结果是一致的。\n可以看到每次执行都是执行完第1次循环后，因为设置取样器错误后执行的动作为停止测试，执行第2循环时的错误请求-第2次循环时发生错误，同时没有其他正在执行的线程，Jmeter直接结束本次测试。\n停止测试-多线程组\u0026amp;勾选独立运行每个线程组 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup4/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup4(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 sleep(2) # 确保 与错误并行请求 在 错误请求 后结束 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划面板中勾选独立运行每个线程组\n测试计划下添加2个线程组\n名称：线程组1、线程组2\n取样器错误后执行的动作中勾选停止测试\n线程组1下添加HTTP 请求取样器\n名称：错误请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：GET\n线程组2下添加2个HTTP 请求取样器\n名称：与错误请求并行的请求、错误请求之后的请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：POST\n错误请求取样器下添加响应断言\n值：1111\n错误请求之后的正确请求取样器下添加固定定时器（右键取样器-添加-定时器）\n线程延迟：3000\t（确保 错误请求之后的正确请求 在 错误请求 后开始）\n在测试计划中，添加查看结果树\n固定定时器可以延迟取样器的执行时间，设置为3秒，可以确保错误请求之后的请求在错误请求结束后执行。\n运行结果\n图中连续运行了多次。会发现，哎！怎么会有不一样的情况。我经过多次测试，发现在勾选独立运行每个线程组\u0026amp;有多个线程组时，此时勾选停止测试，并不会按照预期进行。\n预期结果应该是，错误请求之后，Jemter直接结束测试计划，并不会执行线程组2。读者在使用时需要注意这种情况。具体原理咱们在这里就不深究了，欢迎任何有见解的读者联系我，我会贴在此段下面。\n停止测试-多线程组\u0026amp;不勾选独立运行每个线程组 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup4/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup4(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 sleep(2) # 确保 与错误并行请求 在 错误请求 后结束 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划面板中不勾选独立运行每个线程组\n测试计划下添加2个线程组\n名称：线程组1、线程组2\n取样器错误后执行的动作中勾选停止测试\n线程组1下添加HTTP 请求取样器\n名称：错误请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：GET\n线程组2下添加2个HTTP 请求取样器\n名称：与错误请求并行的请求、错误请求之后的请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：POST\n错误请求取样器下添加响应断言\n值：1111\n错误请求之后的正确请求取样器下添加固定定时器（右键取样器-添加-定时器）\n线程延迟：3000\t（确保 错误请求之后的正确请求 在 错误请求 后开始）\n在测试计划中，添加查看结果树\n运行结果\n图中连续运行了多次。每次结果都一致，执行了错误请求、与错误请求并行的请求。\n此时线程组1和线程组2是并发的，同时执行。所以在执行错误请求时，也在执行与错误请求并行的请求。另外错误请求之后的请求因固定定时器的延迟，还未执行。\n因为设置取样器错误后执行的动作为停止测试，虽然执行错误请求时发生错误，但因此时还在执行与错误请求并行的请求，Jemter会等待与错误请求并行的请求执行结束后，在结束测试计划。\n立即停止测试-多线程组\u0026amp;不勾选独立运行每个线程组* 构想设计的立即停止测试-单线程组\u0026amp;单线程、立即停止测试-单线程组\u0026amp;多线程、立即停止测试-单线程组\u0026amp;多循环；因不涉及多个取样器并行的情况，结果是与停止测试是一致的。读者可以修改停止测试为立即停止测试进行尝试，此处不在赘述。\n构想设计的立即停止测试-多线程组\u0026amp;勾选独立运行每个线程组、与停止测试-多线程组\u0026amp;勾选独立运行每个线程组的结果是一致的。读者可以修改停止测试为立即停止测试进行尝试，此处不在赘述。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup4/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup4(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 sleep(2) # 确保 与错误并行请求 在 错误请求 后结束 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划面板中不勾选独立运行每个线程组\n测试计划下添加2个线程组\n名称：线程组1、线程组2\n取样器错误后执行的动作中勾选立即停止测试\n线程组1下添加HTTP 请求取样器\n名称：错误请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：GET\n线程组2下添加2个HTTP 请求取样器\n名称：与错误请求并行的请求、错误请求之后的请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：POST\n错误请求取样器下添加响应断言\n值：1111\n错误请求之后的正确请求取样器下添加固定定时器（右键取样器-添加-定时器）\n线程延迟：3000\t（确保 错误请求之后的正确请求 在 错误请求 后开始）\n在测试计划中，添加查看结果树\n运行结果\n图中连续请求了三次。结果是一致的，执行了错误请求、与错误请求并行的请求；但错误请求是一个完整的过程，成功接受到响应数据；与错误请求并行的请求则不然，在图中可以看到响应数据中有报错信息（Socket 关闭异常）。\n这是因设置为立即停止测试，在错误请求发生错误时，Jmeter立即停止测试计划，不会等待与错误请求并行的请求。\n本文示例接口源代码可从前言中下载。\n","date":"2024-03-19T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%8A%E7%AF%87/","title":"Jmeter-线程组上篇"},{"content":"测试计划 可以将测试计划可视化为用于运行测试的JMeter脚本。测试计划由测试元素组成，例如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。 每个测试计划中至少应有一个线程组。 我们可以根据要求添加或删除元素。 前言中的快速开始就是一个测试计划。\n当你执行测试时，添加的所有所需组件和元件组成了一个有机整体，即一个完整的测试计划。这个测试计划反映了你对系统性能和功能的验证方式以及测试场景的设计。\n测试计划控制面板中的元素：\n名称和注释\n用户定义的变量\n独立运行每个线程组\n主线程结束后运行tearDown线程组\n函数测试模式\n添加目录或jar包到classpath\n用户定义的变量 当在测试计划的多个部分中存在重复的数值时，可以通过用户定义的变量来提供更灵活的设置。\n测试计划控制面板中的用户定义的变量的作用域覆盖整个测试计划。\n你可以通过${变量名称}的方式来引用这些变量。这种方式允许你在不同的请求或操作中使用相同的数值，从而更加方便地维护和修改。\n示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan1/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan1(): if request.method != \u0026#39;POST\u0026#39;: return \u0026#34;嘿！伙计，你的请求方式错了呀！\u0026#34; data = request.get_json() if \u0026#34;Variables\u0026#34; not in data: return \u0026#34;嘿！伙计，你的请求参数错了呀！\u0026#34; return \u0026#34;本次请求的用户定义的变量值是：\u0026#34; + data[\u0026#39;Variables\u0026#39;] 示例Jmeter脚本\n测试计划面板中添加用户定义的变量\n名称：Variables\n值随意输入：比如：姜\n测试计划下添加线程组\n线程组下添加HTTP请求\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan1/\n请求方式：POST\n消息体数据:{\u0026quot;Variables\u0026quot;:\u0026quot;${Variables}\u0026quot;}\nHTTP请求下添加HTTP信息头管理器（右键HTTP请求-添加-配置元件-HTTP信息头管理器，添加信息头，指定请求体类型）\n名称：Content-Type\n值：application/json\n测试计划下添加查看结果树\n运行结果\n请求体中的数据为：{\u0026ldquo;Variables\u0026rdquo;:\u0026ldquo;姜\u0026rdquo;}。说明成功调用可测试计划中用户定义的变量。\n此外，JMeter提供的配置元件中也包含用户定义的变量元件，通过测试计划/线程组/取样器-添加-配置元件-用户定义的变量进行添加。用法与测试计划面板中的用户定义的变量一致，不同之处在于作用域。\n举例来说，在测试计划下添加的用户定义的变量将在整个测试计划中生效，与测试计划面板中的用户定义的变量作用范围一致。然而，如果用户定义的变量位于取样器中，其作用范围将仅限于该特定取样器内。这种灵活性允许在不同配置元件中使用变量，使其作用范围更具体而有针对性。\n建议使用更自由的配置元件中的用户定义的变量 。\n不勾选独立运行每个线程组 不勾选独立运行每个线程组，测试计划下各线程组随机并行执行。\n示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan2/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan2(): sleep(3) # 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 return \u0026#34;响应时间：\u0026#34; + str(datetime.now()) 示例Jmeter脚本\n测试计划下添加两个线程组\n名称：线程组1、线程组2\n测试计划面板中不勾选独立运行每个线程组\n两个线程组下皆添加取样器\n名称与对应线程组一致：线程组1、线程组2\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan2/\n请求方式：GET\n测试计划下添加查看结果树\n运行结果\n取样器结果中的Sample Start 是请求发出的时间。可以观察到两个线程组内的 HTTP 请求在同一时刻发出，即 2024-04-03 11:27:43。因为两个线程组是并发、随机执行的。\n此外需要多说一下。未勾选 独立运行每个线程组时，线程组是并发执行。但线程组中的多个取样器并不会并发，而是在较短时间内发出全部请求，尤其是在取样器数量较多的情况下。\n因此，在模拟高并发时，如果需要多线程组、所有取样器请求并发，建议在测试计划中添加同步定时器（Synchronizing Timer）。\n同步定时器（Synchronizing Timer）可以确保在并发场景下的同一时间点触发多个线程组中多个取样器的请求，以更真实地模拟多用户同时访问系统的情况。\n勾选独立运行每个线程组 勾选独立运行每个线程组，测试计划下各线程组按照从上到下的顺序依次执行。\n示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan2/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan2(): sleep(3) # 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 return \u0026#34;响应时间：\u0026#34; + str(datetime.now()) 示例Jmeter脚本\n测试计划下添加两个线程组\n名称：线程组1、线程组2\n测试计划面板中勾选独立运行每个线程组\n两个线程组下皆添加取样器\n名称与对应线程组一致：线程组1、线程组2\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan2/\n请求方式：GET\n测试计划下添加查看结果树\n运行结果\n取样器结果中的Sample Start 是请求发出的时间。可以观察到两个线程组内的 HTTP 请求并非在同一时刻发出，线程组2的请求发出时间是 2024-04-03 11:29:28，线程组1的请求发出时间是 2024-04-03 11:29:31。两者之间的时间差为3秒，正与接口休眠的三秒相符，这表明两个线程组是顺序执行的。\n不勾选主线程结束后运行tearDown线程组 在 JMeter 中，线程组的执行优先级大于tearDown 线程组，因此tearDown 线程组将会等待所有线程组执行完毕后才会执行。\n线程组中的取样器配置为在取样器错误发生后要执行的动作为停止测试或立即停止测试时，如果线程组中的取样器发生错误，tearDown线程组就无法执行。\n如果你对这个场景有需要，可以勾选主线程结束后运行tearDown线程组。它的作用是即使普通线程由于取样器错误而导致线程结束执行时，Jmeter也会继续执行 tearDown 线程。\n这意味着即使在测试中发生了错误，系统仍会在整个测试结束前执行 tearDown 线程，以确保在测试运行结束时执行一些清理或必要的操作。\n示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan3(): return {\u0026#34;code\u0026#34;: 200} 示例Jmeter脚本\n测试计划下添加线程组、tearDown线程组\n在取样器错误后要执行的动作的选项勾选停止测试或立即停止测试\n线程组和tearDown线程组下添加http请求\n名称：线程组，tearDown线程组\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan3/\n请求方式：GET\n线程组请求取样器下添加响应断言（右键取样器-添加-断言-响应断言）\n添加、输入值：1111\n测试计划下添加查看结果树\n响应断言用于匹配实际响应信息，作为验证接口响应的一种手段。例如，示例接口响应的是 {'code': 200}，而添加的断言是 1111，这两者无法匹配，即判断该取样器请求存在错误。\n运行结果\n因为响应体{\u0026quot;code\u0026quot;: 200}与断言1111无法匹配，响应断言判断该取样器请求发生错误。未勾选主线程结束后运行tearDown线程组时，不会执行 tearDown 线程组。\n此时，修改响应断言为：{\u0026quot;code\u0026quot;:200，运行\n这次因为响应体{\u0026quot;code\u0026quot;: 200}与断言{\u0026quot;code\u0026quot;:200匹配，响应断言判断该取样器请求正常，所以线程组被执行完毕后，执行 tearDown 线程组。\n勾选主线程结束后运行tearDown线程组 示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan3(): return {\u0026#34;code\u0026#34;: 200} 示例Jmeter脚本\n测试计划下添加线程组、tearDown线程组\n在取样器错误后要执行的动作的选项勾选停止测试或立即停止测试\n线程组和tearDown线程组下添加http请求\n名称：线程组，tearDown线程组\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan3/\n请求方式：GET\n线程组请求取样器下添加响应断言（右键取样器-添加-断言-响应断言）\n添加、输入值：1111\n测试计划下添加查看结果树\n运行结果\n即使响应断言判断请求发生错误，因为了勾选主线程结束后运行tearDown线程组，tearDown 线程组也会被执行。\n函数测试模式 若选择了此选项，并且监听组件（比如“查看结果树”）配置了将结果保存到文件中，JMeter将每次的请求结果记录到文件中。值得注意的是，这种做法相对消耗资源，在负载测试中并不建议勾选。然而，在平时脚本调试的情况下，可以考虑启用该选项。\n这样的设置主要适用于需要详细记录每次请求结果的情况，以便后续分析或排查问题。在负载测试中，由于可能生成大量的结果数据，将其全部保存到文件可能导致性能和资源开销的增加，因此需要谨慎使用。\n实际应用场景相对有限，因此在本文中不进行详细演示。\n添加目录或jar包到classpath 添加文件或 JAR 包功能主要用于调用外部的 JAR 包。当脚本需要引用外部的 Java 文件或 JAR 包时，可以通过将 JAR 包的路径添加到此功能中。这样，在 Beanshell 脚本中就可以通过 import 语句导入外部 JAR 包，并直接调用其中的方法。\n这个特性提供了一种扩展 JMeter 功能的途径，使得用户可以方便地集成和调用外部 Java 类库，从而实现更复杂和灵活的测试脚本。\n在后续的内容中，当涉及到 Beanshell 时，将详细阐述如何使用这一功能。\n","date":"2024-01-26T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/","title":"Jmeter-测试计划"},{"content":"\nJMeter 环境安装及配置 在使用 JMeter 之前，需要配置相应的环境，包括安装JDK和JMeter。\n首先，了解一下JDK，它就是Java的开发工具包。\nJMeter 是使用 Java 编写的。一般来说，只需要安装 JRE（Java 运行时环境）就可以运行 JMeter，因为 JRE 包含了运行 Java 应用程序所需的组件。那么为什么建议安装 JDK 呢？\n如果你想要在 JMeter 中使用一些插件、进行脚本开发、编译测试计划等高级功能，安装 JDK 可能会更有帮助，因为 JDK 包含了 JRE，并且还提供了编译 Java 代码所需的工具，比如 javac。此外，一些场景下，比如进行 HTTPS 压力测试，需要使用 JDK 中的 keytool 工具。\n确保正确配置JDK和JMeter环境，可以让你更灵活地应对不同的测试需求\nJDK 下载JDK 注意一定要下载与Jmeter对应的JDK版本，如jmeter-5.6.3与JDK21对应\nJDK下载地址示例环境为Windows，读者应根据实际环境下载JDK的安装包。推荐下载exe文件，安装方便快捷。\rhttps://www.oracle.com/java/technologies/downloads/#jdk21-windows\r安装JDK 建议在安装之前在D盘或C盘下新建一个下新建一个Tools\\JDK 文件夹。在安装 JDK 时，修改安装目录为Tools\\JDK文件夹。这样做的好处在于方便管理和配置环境变量。\n接下来就是一直下一步就行。\n配置JDK系统变量、环境变量 系统变量和环境变量是计算机系统中的两个重要概念，它们用于存储和管理系统或应用程序运行过程中需要使用的信息。\n系统变量是指在操作系统级别上设置的一些全局信息，用于控制和影响整个计算机系统的行为。 这些变量通常由操作系统或系统管理员配置，用于存储系统范围的配置参数和信息。系统变量可以影响所有用户和应用程序的行为。 如PATH是一个常见的系统变量，它存储了操作系统在哪些目录中查找可执行文件的信息。\n环境变量是在操作系统或应用程序运行过程中设置的一些动态变量，用于影响当前进程的行为。 环境变量提供了一种将信息传递给正在运行的程序的方法，以便程序根据这些变量的值来调整其行为。 如PATH变量中的值就是执行文件的环境变量。\n系统变量是操作系统级别的全局配置，而环境变量是在运行过程中用于传递信息给正在执行的程序的配置。在许多情况下，环境变量的值可以由用户或程序员进行配置，以影响特定应用程序或进程的行为。\n不要随意改动环境变量，否则可能造成系统死机。 新建JDK系统变量\n右键此电脑-属性-高级系统设置-环境变量，系统变量-新建。\n变量名：JDK\n变量值：JDK安装目录(进入JDK目录，复制文件地址栏中的值)或者浏览目录进行选择（Windows11）\nPath中新建JDK的环境环境\n系统变量中找到Path，选中后点击编辑，进入Path系统变量窗口，新建两条环境变量。然后一路确定。\n第一条：%JDK%\\bin;\n第二条：%JDK%\\jre\\bin;\nJmeter JMeter 是一个独立的 Java 应用程序，它不依赖于系统注册表或其他系统级配置。所以它能够在不同操作系统上运行而无需进行安装。只需要下载完成后，将 ZIP 文件解压缩到指定的目录。 在解压缩后的目录中找到 JMeter 启动脚本（例如 windows的jmeter.bat 或 Linux的jmeter.sh），运行该脚本以启动 JMeter。\n下载JmeterZIP包 注意一定要下载与JDK对应的Jmeter版本，如jmeter-5.6.3与JDK21对应\n历史版本Jmeter下载地址示例环境为Windows，读者应根据实际系统环境及JDK版本，下载Jmeter的安装包。下载页面写有JDK版本要求。Windows环境推荐zip包，Linux环境推荐tgz包。\rhttps://archive.apache.org/dist/jmeter/binaries/\r最新版本Jmeter下载地址示例环境为Windows，读者应根据实际系统环境及JDK版本，下载Jmeter的安装包。下载页面写有JDK版本要求。Windows环境推荐zip包，Linux环境推荐tgz包。\rhttps://jmeter.apache.org/download_jmeter.cgi\r解压到目录 建议解压到D:\\Tools目录下，方便管理。\n汉化Jmeter界面 编辑Jmeter/bin/jmeter.properties，40行增加language=zh_CN，然后保存。\n发送启动文件到桌面快捷方式 启动Jmeter 双击桌面上的 JMeter 快捷方式，等待脚本运行，然后 JMeter 界面将会显示出来。\n快速使用 我们可以使用最简单的JMeter脚本来快速进行一次接口请求。这个脚本包括测试计划、线程组、取样器（Sampler）以及查看结果器（View Results Tree）。\n在测试计划中，我们定义了整个测试的基本设置。线程组用于模拟用户，而取样器则代表了具体的请求。查看结果器则用于查看请求的详细结果。\n通过这个简单的脚本，我们能够迅速进行一次接口请求测试。\n示例接口\n@QuickUse.route(\u0026#39;/api/QuickUse/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def quickuse(): # Jmeter教程快速开始api if request.method != \u0026#39;GET\u0026#39;: return \u0026#34;请求方式非 GET\u0026#34; return \u0026#34;请求方式为 GET\u0026#34; 示例Jmeter脚本\n测试计划下添加线程组\n右键测试计划-添加-线程（用户）-线程组\n测试计划下添加查看结果树\n右键测试计划-添加-监听器-查看结果树\n线程组下添加HTTP请求\n右键线程组-添加-取样器-HTTP请求\n请求地址：HTTP://127.0.0.1:5000/api/QuickUse/\n请求方式：GET\n运行结果\n从图中可以清晰的看出，请求成功。请求数据中，包括Request Headers 请求头和Request Body 请求体。响应数据中，包括Response Headers 响应头和Response Body 响应体。\n此次请求的响应体数据为： 请求方式为 GET\n","date":"2024-01-25T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"Jmeter-环境配置"},{"content":"前言 为什么要撰写这样一个教程呢？ 深入学习Jmeter\n温故而知新。尽管我已经使用JMeter很长时间，但还有许多元件我并不十分了解，因此，编写教程的过程成为了我的学习过程，通过反复回顾和整理知识，我能够更全面地掌握JMeter。\n分享知识\n我深信知识具有强大力量，而这种力量应该共享，我愿意将我的所学分享给志同道合的朋友——也就是你们。它不仅能够为他人提供帮助，EtherealBoyJiang还能够在这个过程中体验到一种内在的满足感。\n结识朋友\n这是我的第一个教程，后续也会编辑更多的教程。希望能通过这一行为与各位取得交流，成为朋友，与大家一起讨论更多的事情。\n关于Jmeter JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。\nJMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。\n另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。\n我们为什么使用Jmeter 开源免费，基于Java编写，可集成到其他系统可拓展各个功能插件\n支持接口测试，压力测试等多种功能，支持录制回放，入门简单\n相较于自己编写框架活其他开源工具，有较为完善的UI界面，便于接口调试\n多平台支持，可在Linux，Windows，Mac上运行selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。\n主要组件介绍 测试计划(Test Plan)\n是使用JMeter进行测试的起点，它是其它JMeter测试元件的容器。\n线程组(Thread Group)\n代表一定数量的并发用户，它可以用来模拟并发用户发送请求。\n取样器(sampler)\n定义实际的请求内容，被线程组包含，我们主要用HTTP请求。\n监听器(Listener)\n负责收集测试结果，同时也被告知了结果显示的方式。我们常用的包括：聚合报告、察看结果树、用表格查看结果，都支持将结果数据写入文件。其他的添加上去看看就行。\n逻辑控制器(Logic Controller)\n可以自定义JMeter发送请求的行为逻辑，它与Sampler结合使用可以模拟复杂的请求序列。\n其分为循环控制器和事务控制器。\n断言(Assertions)\n可以用来判断请求响应的结果是否如用户所期望的。它可以用来隔离问题域，即在确保功能正确的前提下执行压力测试。这个限制对于有效的测试是非常有用的。\n配置元件(Config Element)\n维护Sampler需要的配置信息，并根据实际的需要会修改请求的内容。我们主要在参数化中用到CSV Data Set Config。\n前置处理器(Pre Processors)和后置处理器(Post Processors)\n负责在生成请求之前和之后完成工作。前置处理器常常用来修改请求的设置，后置处理器则常常用来处理响应的数据。我们主要在动态关联中用到后置处理器的正则表达式提取器。\n定时器(Timer)\n负责定义请求之间的延迟间隔。\n执行顺序(Execution sequence)\n配置元件、前置处理器、定时器、取样器、后置处理器、断言、监听器\n工作流程 JMeter通过模拟一组用户将请求发送到目标服务器。 随后，收集数据以通过各种格式计算目标服务器的统计和显示性能度量。\n内容引用 Jmeter测试组件介绍|EMQ本系列教程中部分组件介绍文本引用于此\rhttps://www.emqx.com/zh/blog/introduction-to-jmeter-test-components#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E7%BB%84\r鸟哥教程本系列教程中部分组件介绍文本引用于此\rhttps://www.niaoge.com/jmeter/jmeter-index.html\r示例接口代码 下载示例代码本系列文章中所有示例接口皆由python编写，python版本为3.12.1，如要使用示例接口请安装python3.12.1与pycharm。压缩包内包含源码和使用说明\rhttps://thelonelypatient.github.io/Jiang/code/JmeterApi.zip\r说明 对于测试人员来说，JMeter是一款非常强大的接口测试工具，尤其在性能测试方面表现出色。希望读者们通过EtherealBoyJiang编写的系列教程，能够熟练掌握JMeter的使用。\n本文基于JDK21、Jmeter-5.6.3测试编写，可能不适用于历史版本及未来版本。如果Jmeter在后续的新版本中有所变化，或者文中有错漏的地方，请联系EtherealBoyJiang，EtherealBoyJiang感激不尽。\n对EtherealBoyJiang来说，能够帮助到读者是一件莫大的荣幸，期待更多读者通过本系列教程获得成长。\n","date":"2024-01-23T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E5%89%8D%E8%A8%80/","title":"Jmeter-前言"}]