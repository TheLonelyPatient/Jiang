[{"content":"定时器(Timer) JMeter中的定时器（Timer）是一种配置元件，它在测试计划中的各个请求（Sampler）之间添加延迟或等待时间。可以模拟用户在操作过程中的自然停顿，以及控制请求的发送频率。以下是JMeter中几种常用的定时器类型：\n固定定时器(Constant Timer)\n统一随机定时器(Uniform Random Timer)\n常数吞吐量定时器(Constant Throughput Timer)\n准确的吞吐量定时器(Precise Throughput Timer)\n暂不讲\nJSR223定时器(JSR223 Timer)\n同步定时器(Synchronizing Timer)\n泊松随机定时器(Poisson Random Timer)\n高斯随机定时器(Gaussian Random Timer)\nBeanShall定时器(BeanShell Timer)\nPart1.固定定时器 它的作用是添加固定的时间间隔。可添加在测试计划、线程组、取样器下，使其延迟执行。时间单位为毫秒。\n测试计划下添加固定定时器，设置延迟为3000。它会造成测试计划下所有的请求以延迟3秒的时间执行。\n图中，测试计划中勾选了独立运行每个线程组，所以6个请求顺序执行。固定定时器的作用域是整个测试计划。可以看出每个请求执行前都会延迟3秒。\n线程组下添加固定定时器，设置延迟为3000。它会造成该线程组下所有的请求以延迟3秒的时间执行。\n3个请求顺序执行。固定定时器的作用域是整个线程组。可以看出每个请求执行前都会延迟3秒。\n取样器下添加固定定时器，设置延迟为3000。它会造成该取样器延迟3秒执行。\n3个请求顺序执行。固定定时器的作用域是HTTP请求-1-3。可以看出只有HTTP请求-1-3执行前延迟3秒。\nPart2.统一随机定时器 它的作用是添加一个随机的时间间隔+一个固定的时间间隔。随机的时间间隔在用户0-值之间随机获取，固定的时间间隔可以看作最小时间，时间单位为毫秒。总的延时 = 固定延迟时间 + 随机生成的延时。\n统一随机定时器中配置Random Delay Maximum(随机延迟):3000\u0026amp;\u0026amp;Constant Delay Offset(固定延迟):3000\n3个请求顺序执行，执行了2次。HTTP请求-1-2两次执行前延迟不一致，第一次是3秒，第二次是4秒。\nPart3.同步定时器 它的作用是保证取样器在同一时刻向服务器发起负载测试。可以设置模拟用户组的数量、超出时间，对并发量及等待时间进行控制。\n同步定时器一般在线程达到模拟用户组的数量时，同步释放。如果线程未达到模拟用户组的数量，它就会一致等待，此时就可以配置超出时间，等待一段时间后，将线程同步释放。\n线程组的线程数配置为100,未配置同步定时器\n可以看出第1个线程请求与第100个线程请求的执行时间相差1秒左右。\n线程组的线程数配置为100,配置同步定时器\n可以看出第1个线程请求与第100个线程请求的执行时间只相差几毫秒左右。\n超出时间。配置线程组的线程数配置为10，同步定时器的模拟用户组数量为9、超出时间为3000\n10个线程，同步定时器在线程数达到9(模拟用户组数量)时，释放这9个请求。剩下的1个，由于达不到9个线程(模拟用户组数量)的要求，只能延迟3秒(超出时间)释放。\nPart3.常数吞吐量定时器 此计时器引入了可变暂停，经过计算以使总吞吐量（以每分钟样本数计算）尽可能接近给定数字。当然，如果服务器无法处理，或者其他计时器或耗时的测试元素阻止了吞吐量，则吞吐量会更低。\n常数吞吐量定时器参数说明\n姓名：描述性名称\n目标吞吐量（每分钟的样本量）：单位分钟。比如样本量3000，则吞吐量为500/sec。\n基于计算吞吐量：\n只有此线程：\n目标吞吐量：3000样本/分钟\n线程数：5\n结果：每个线程将独立尝试保持3000样本/分钟，总吞吐量 = 3000 * 5 = 15000样本/分钟。\n所有活动线程：\n目标吞吐量：3000样本/分钟\n线程组数：3，每组10个线程\n结果：所有30个线程将共同实现3000样本/分钟的吞吐量，每个线程的吞吐量将基于它上次运行的时间，根据需要延迟调整。\n注意：每个线程组都需要一个具有相同设置的常数吞吐量定时器。\n所有活动线程（共享）：\n目标吞吐量：3000样本/分钟\n线程组数：3，每组10个线程\n结果：所有30个线程将共同实现3000样本/分钟的吞吐量，每个线程的吞吐量将根据任何线程上次运行的时间而延迟。\n注意：每个线程组都需要一个具有相同设置的常数吞吐量定时器。\n当前线程组中的所有活动线程：\n目标吞吐量：3000样本/分钟\n当前线程组：10个线程\n结果：这10个线程将共同实现3000样本/分钟的吞吐量，分配吞吐量并根据每个线程上次运行的时间进行延迟调整。\n当前线程组中的所有活动线程（共享）：\n目标吞吐量：3000样本/分钟\n当前线程组：10个线程\n结果：这10个线程将共同实现3000样本/分钟的吞吐量，分配吞吐量并根据当前线程组中任何线程上次运行的时间进行延迟调整。\n配置示例Jmeter脚本\n测试计划下添加聚合报告、常数吞吐定时器、线程组\n线程组下添加20个相同的HTTP请求取样器\n线程组的线程数配置为：1000\nHTTP请求取样器配置请求地址为：HTTP://127.0.0.1:5000/api/GetList/\nHTTP请求取样器配置请求方式为：GET\n常数吞吐定时器的基于计算吞吐量配置为：此线程、目标吞吐量配置为：60(1/sec)，线程组的线程数修改配置为：100\n配置只有此线程，总的吞吐量=基于吞吐量×线程数。则此次测试的总吞吐量为1×100=100/sec。与图中几乎一致。\n常数吞吐定时器的基于计算吞吐量配置为：当前线程组中的所有活动线程、目标吞吐量配置为：600(10/sec)\n配置当前线程组中的所有活动线程，总的吞吐量=基于吞吐量。则此次测试的总吞吐量为1×100=100/sec。图中为10.5/sec，好像与图中几乎一致。\n但是请注意，其中是有问题的。\n用表格查看结果表示。好家伙！在48分28秒时，竟然偷偷完成了72个请求的吞吐。在48分29秒时，偷偷完成了43个请求的吞吐。\n后续的吞吐量貌似正常了，其实有很多时间每秒只有7/sec、8/sec或9/sec的吞吐量来补偿前面的72/sec、43/sec。可恶啊！可恶。\n用表格查看结果温馨提示，请谨慎使用当前线程组中的所有活动线程。\n常数吞吐定时器的基于计算吞吐量配置为：当前线程组中的所有活动线程（共享）、目标吞吐量配置为：600(10/sec)\n嗯！很完美的10/sec。\n但有上面的问题吗？\n用表格查看结果表示。呵！一丘之貉。只不过有比当前线程组中的所有活动线程更快、更激烈的补偿，使之不符合目标吞吐量的时间较之大大缩短。\n常数吞吐定时器的基于计算吞吐量配置为：所有活动线程与所有活动线程（共享）用于多线程组。也有着当前线程组中的所有活动线程的问题，就不贴上来了。\n未完待续\n","date":"2024-06-15T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E5%AE%9A%E6%97%B6%E5%99%A8/","title":"Jmeter-定时器"},{"content":"监听器 在JMeter中，监听器（Listeners）是用来收集和展示采样器（Samplers）产生的结果数据的元件。它们可以显示测试过程中的响应时间、吞吐量、错误率等信息。JMeter监听器包括：\n查看结果树(View Results Tree)\n汇总报告(Summary Report)\n聚合报告(Aggregate Report)\n后端监听器(Backend Listener)\nJSR223 监听器(JSR223 Listener)\n保存响应到文件(Save Responses to a file)\n响应时间图(Response Time Graph)\n图形结果(Graph Results）\n这个可以不用了解，消耗资源多且生成的图表质量不高。\n断言结果(Assertion Results)\n比较断言可视化器(Comparison Assertion Visualizer)\n汇总图(Aggregate Graph)\n生成概要结果(Generate Summary Results)\n用表格查看结果(View Results in Table)\n简单数据写入器(Simple Data Writer)\n邮件观察仪(Mailer Visualizer)\nBeanShell 监听器(BeanShell Listener)\nPart1.查看结果树 查看结果树显示请求的取样器结果、请求信息、响应信息。我们可以通过查看结果树中的内容，检查脚本是否有问题。比如IP、端口或者请求数据。还可以检查，响应数据是否正常。常用于接口测试及验证脚本。\n在进行性能测试时，它在过程中会消耗大量资源，尽量不要使用查看结果树。\n结果列表\n绿色代表请求成功，红色代表请求失败(断言未通过也算失败)。\n取样器结果\nThread Name: 执行请求的线程名称，这里是\u0026quot;线程组 1-1\u0026quot;，表示这是属于线程组1的第1个线程。\nSample Start: 请求开始的时间，格式为年-月-日 时:分:秒，这里是\u0026quot;2024-06-14 16:17:12 CST\u0026quot;。\nLoad time: 请求的加载时间，包括建立连接、发送请求、接收响应的总时间，这里是2毫秒。\nConnect Time: 建立到服务器的连接所需的时间，这里是1毫秒。\nLatency: 服务器延迟时间，即从发送请求到接收到第一个字节响应的时间，这里是2毫秒。注意这里的延迟时间与连接时间相等，可能是因为这个值已经包含了连接时间。\nSize in bytes: 响应的总字节数，这里是192字节。\nSent bytes: 发送到服务器的请求的字节数，这里是265字节。\nHeaders size in bytes: 响应头的大小，这里是173字节。\nBody size in bytes: 响应体的大小，这里是19字节。\nSample Count: 在这个监听器中捕获的样本数量，这里是1。\nError Count: 遇到的错误数量，这里是0，表示请求成功。\nData type: 响应数据的类型，这里标记为\u0026quot;text\u0026quot;，表示响应是文本类型。\nResponse code: HTTP响应状态码，200表示请求成功。\nResponse message: HTTP响应消息，\u0026ldquo;OK\u0026quot;表示请求被成功处理。\nHTTPSampleResult fields:\nContentType: 响应的MIME类型和字符编码，这里是\u0026quot;text/html; charset=utf-8\u0026rdquo;，表示响应是HTML文本，使用UTF-8编码。 DataEncoding: 响应数据的编码，这里也是\u0026quot;utf-8\u0026quot;。 请求数据\nConnection: 表示客户端希与服务器的连接方式，这里是长连接。\nContent-Length: 表示请求体的长度是15个字节。\nContent-Type: 表示请求体的类型是application/x-www-form-urlencoded，并且使用UTF-8字符编码。\nHost: 指定了请求的目标服务器地址和端口号，这里是本地主机的5000端口。\nUser-Agent: 表示发送请求的客户端软件和版本，这里是Apache HttpClient库，运行在Java环境中。\nPOST http://127.0.0.1:5000/api/QuickUse/: 表示请求方式、URL(包括协议、主机、端口和请求的路径)。\nPOST data:显示请求体中的数据。\n[no cookies]: 这表示请求中没有携带任何Cookie。\n响应数据\nHTTP/1.1 200 OK: 这表示使用的是HTTP协议版本1.1，并且请求成功，状态码200表示服务器成功处理了请求并返回了所请求的资源。\nServer: 这里表明服务器使用的是Werkzeug服务器软件，版本为3.0.1，运行在Python环境下，Python的版本为3.12.3。\nDate: 表示响应的日期和时间，使用GMT（格林尼治标准时间）。\nContent-Type: 这里表示响应的内容类型是HTML，字符编码是UTF-8。\nContent-Length: 表示响应体的字节长度是19字节。\nConnection: close 表示服务器在发送完响应后将关闭连接。这与 Connection: keep-alive 相反，后者表示连接可以保持开启状态以用于发送多个请求。\n请求方式非 GET: 这就是响应体数据。\n所有数据写入一个文件\n建议不要保存文件到C盘，除非以管理员身份运行Jmeter。另外还可以配置日志内容，就请读者自己探究吧。\n这个功能有连个作用：\n配置运行结果保存到那个文件\n通过浏览-打开文件，可以读取文件的数据，在对应的监听器中显示数据。\n监听器的 所有数据写入一个文件，都是同种作用。\n查找\u0026amp;\u0026amp;结果显示方式\n可以通过查找快速定位请求，支持正则表达式。查找的结果用红色框包裹。\n我自己标记的绿色框，可以选择结果显示方式。还是请读者自己去探究吧。\nPart2.汇总报告 可以查看事务或者取样器在某个时间范围内执行的汇总结果，一个取样器或事务占一行。数据包括样本(请求量)、平均值、最小值、最大值、标准偏差、异常%(错误请求)、吞吐量、接受KB/sec、发送KB/sec、平均字节数。\nLable：f\n样本（Samples）：取样器请求的数量\n平均值（Average）：请求（事务）的平均响应时间\n最小值（Min）：请求的最小响应时间\n最大值（Max）：请求的最大响应时间\n标准偏差（Std.Dev）： 响应时间的标准方差\n异常 %（Error）：请求的错误率 = 错误请求的数量/请求的总数\n吞吐量（Throughput）：默认情况下表示每秒完成的请求数，一般认为它为TPS。（注意单位的变化，如上图中，当TPS很低时，jmeter中默认会统计成每分钟的值，这时我们需要换算成以秒为单位）。当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数\n接收 KB/sec（Received KB/sec）：每秒接收的千字节数\n发送 KB/sec（Sent KB/sec）：每秒发送的千字节数\n平均字节数（Avg.Bytes）：取样结果返回的平均大小\n还可以保存数据到文件及保存表格数据。\nPart3.聚合报告 聚合报告与汇总报告类似，较于汇总报告更占用主机资源。数据包括样本(请求量)、平均值、中位数、90%百分位、95%百分位、99%百分位、最小值、最大值、异常%(错误请求)、吞吐量、接受KB/sec、发送KB/sec。\nLabel：Label：每个请求的名称。每个 JMeter 的 element(例如 HTTP Request)都有一个 Name 属性，这里显示的就是 Name 属性的值\n样本（Samples）：各请求发出的数量。表示你这次测试中一共发出了多少个请求，如果模拟10个用户，每个用户迭代10次，那么这里显示100\n平均值（Average：平均响应时间（单位：毫秒）。默认是单个Request的平均响应时间，当使用了Transaction Controller时，也可以以Transaction为单位显示平均响应时间。值 = 总运行时间 / 发送到服务器的总请求数\n中位数（Median）：50%用户的响应时间在小于该值，注意它与average平均响应时间的区别\n90%百分位：90%用户的响应时间小于该值，90%line是性能测试中比较重要的一个衡量指标。\n95%百分位：95%用户的响应时间小于该值\n99%百分位：99%用户的响应时间小于该值\n最小值（Min）：请求的最小响应时间\n最大值（Max）：请求的最大响应时间\n异常 %（Error）：请求的错误率 = 错误请求的数量/请求的总数\n吞吐量（Throughput）：默认情况下表示每秒完成的请求数，一般认为它为TPS。（注意单位的变化，如上图中，当TPS很低时，jmeter中默认会统计成每分钟的值，这时我们需要换算成以秒为单位）。当使用了 Transaction Controller 时，也可以表示类似 LoadRunner 的 Transaction per Second 数\n接收 KB/sec（Received KB/sec）：每秒接收的千字节数\n发送 KB/sec（Sent KB/sec）：每秒发送的千字节数\n还可以保存数据到文件及保存表格数据。另外可以访问百分位数了解概念。\nPart4.后端监听器 在Apache JMeter中，后端监听器（Backend Listener）是用于将测试结果实时发送到外部数据存储或监控系统的一种组件。它常用于将性能测试结果发送到外部系统，如Grafana、InfluxDB、ElasticSearch等数据库，以便实时监控和分析性能测试的结果。\n在“后端监听器”组件中，选择“Backend Listener Implementation”（后端监听器实现）类型。常见的实现有： org.apache.jmeter.visualizers.backend.influxdb.InfluxdbBackendListenerClient：发送数据到InfluxDB。 org.apache.jmeter.visualizers.backend.graphite.GraphiteBackendListenerClient：发送数据到Graphite。\n根据选择的实现类型，填写相应的配置信息，如数据库URL、用户名、密码等。\n比如配置InfluxDB后端监听器：\n选择InfluxdbBackendListenerClient作为实现类。\ninfluxdbMetricsSender: 默认值就行。\ninfluxdbUrl: InfluxDB的URL，例如http://localhost:8086/write?db=jmeter。\napplication: 应用名称，用于区分不同的应用或测试。\nmeasurement: 数据表名。\nsummaryOnly: 是否只发送汇总数据，默认false。\nsamplersRegex: 正则表达式，用于匹配要发送的采样器名称，默认是“.*”表示所有采样器。\npercentiles: 需要记录的百分位数，默认是90,95,99。\n启动InfluxDB和Grafana（如果使用这些工具）：\n确保InfluxDB和Grafana已启动并配置正确。\n在InfluxDB中创建一个数据库，用于存储JMeter发送的数据。\n在Grafana中配置一个数据源，指向InfluxDB数据库，并创建仪表盘用于展示数据。\n运行JMeter测试：\n启动JMeter测试计划。\n在Grafana或其他监控工具中查看实时性能测试结果，分析系统的性能表现。\n可以访问github开源JMeter后端监听器了解并使用更多方便、强大的后端监听器方案。\nPart5.JSR223 监听器 它允许用户通过自定义脚本来处理采样器的结果数据，使用的主要目的是数据存储、实时监控和报警。JSR223监听器支持多种脚本语言，如Groovy、JavaScript、BeanShell等，提供了很大的灵活性来执行复杂的数据处理和结果分析任务。\n示例\n选择脚本语言Groovy。\n在“脚本”区域中，编写脚本代码。\nimport org.apache.jmeter.samplers.SampleResult import java.nio.file.Files import java.nio.file.Paths import java.nio.file.StandardOpenOption // 获取当前采样器的结果 SampleResult sampleResult = prev // 获取采样器名称 String samplerName = sampleResult.getSampleLabel() // 获取响应时间 long responseTime = sampleResult.getTime() // 获取响应数据 String responseData = sampleResult.getResponseDataAsString() // 获取响应状态 boolean success = sampleResult.isSuccessful() // 构造日志信息 String logMessage = \u0026#34;Sampler: ${samplerName}, Response Time: ${responseTime}ms, Success: ${success}, Response Data: ${responseData}\\n\u0026#34; // 定义日志文件路径 String logFilePath = \u0026#34;D:\\logfile.log\u0026#34; // 将日志信息写入文件 Files.write(Paths.get(logFilePath), logMessage.getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND) 输出的logfile.log文件\n当然你也可以在脚本中将结果数据传递到数据库或其他服务系统进行处理，或者直接进行处理。不过这会消耗主机资源，需要做好取舍。\n自定义参数\n你可以通过参数，其他元件（比如用户定义的变量、Jmeter-CSV Data Set Config、函数等）传递数据给脚本。\n参数中输入jiang 1（空格分割，值可以是列表、元组等）\n添加用户定义的变量\n修改上述脚本\n// 新增获取自定义参数，自定义参数会保存到args变量(列表)， String name = args[0] String number = args[1] // 构造日志信息,新增name，number, class, random。random是随机函数。 String logMessage = \u0026#34;Sampler: ${samplerName}, Response Time: ${responseTime}ms, Success: ${success}, Response Data: ${responseData}, name: ${name}, number: ${number}, class: ${class}, random: ${__Random(111111,222222,)}\\n\u0026#34; 输出的logfile.log文件\nname，number, class, random的值都被输出到logfile.log文件中了。\n脚本文件（覆盖脚本）\n符合字面意思，引用脚本文件会覆盖脚本内容。\n把示例脚本内容添加到空白的test.groovy文件中\n引用test.groovy`\n删除logfile.log文件\n输出的logfile.log文件\nname，number, class, random的值不再输出，因为执行的是test.groovy脚本。\n你也可以通过脚本实现阈值功能，比如错误率达到一定值时，自动停止测试。不过在这里我就不再过多阐述，读者可以自己探究。\nPart6.保存响应到文件 当结果太大，使用结果树监听器影响图形模式时，我们可以采用响应保存监听器来处理，可以将结果树数据保存到文件。\nSave Successful Responses only：仅保存成功响应\nSave Failed Responses only：仅保存失败响应\nDon’t save Transaction Controller SampleResult：不保存事务控制器样本结果\n文件前缀：文件路径 + 文件前缀\nDon’t add number to prefix：不添加数字到文件前缀\nDon’t add content type suffix：不添加文件的后缀类型\nAdd timestamp：添加时间戳到文件前缀\nMinimum Length of sequence number：设置文件名称最小的序列号；例如4，文件序号为0001…\n示例Jmeter\n文件前缀：D:\\Results\\Results1\n线程组线程数：200\n请求地址：HTTP://127.0.0.1:5000//api/GetList/\n请求方式：GET\n运行后结果\n一个请求结果独立一个文件。\nPart7.响应时间图 响应时间图是一个直方图，其中 X 轴表示时间，Y 轴表示响应时间。\n响应时间：就是一个请求从发送到接收到响应的总时间。在图中，每个数据点的Y坐标表示请求响应时间。\n时间：测试计划运行的持续时间。在图中，每个数据点的X坐标表示请求开始的时间。\n分布：数据点在图中的分布，可以分析出响应时间的变化。如果数据点在一条线附近，那么响应时间可能比较稳定。如果数据点在图中的分布比较广，那么响应时间可能有比较大的波动。\n趋势：我们也可以通过响应时间图来观察响应时间的趋势。例如，如果数据点从左至右逐渐上升，那么可能表明随着时间的推移，响应时间在增加。\n其余参数\n时间间隔关系X轴的显示。其它参数都是改变显示方式，如字体。读者可自行探究。\nPart8.断言结果 文本显示所有请求名称，如果断言失败，名称下方显示失败原因，成功则不显示。消耗资源较多，且我认为意义不大。\nPart9.比较断言可视化器 显示请求断言情况，若断言失败，标红。但无法给出断言信息。\nPart10.汇总图 较于汇总报告，多了柱形图功能。列可显示平均值、中位数、90%百分位、95%百分位、99%百分位、最小值、最大值。\nPart11.生成概要结果 生成概要结果没有配置参数。生成结果需要在Jmeter日志或者Jmeter-cmd窗口查看。\nin：TPS，每秒取样器执行的数量\nAvg：平均值。平均响应时间，所有请求的平均响应时间，单位是毫秒\nMin：最小值。请求的最小响应时间\nMax：最大值。请求的最大响应时间\nErr：异常百分比。（错误请求的数量/请求的总数)\nPart12.用表格查看结果 与查看结果树不同，此元件将结果写进表格中，可查看数据也不同。不过都能查看各个请求结果状态。\nSample#：请求序号\nStart Time：请求开始时间\nThread Name：线程名称\nLabel：请求的名称（实际请求中可使用参数化对每个请求做区分）\nSample Time(ms)：请求的响应时间\nStatus：请求状态，为勾则表示成功，为叉表示失败\nBytes：响应的字节数及请求的字节数\nSent Bytes：发送的字节数\nLatency：延迟时间（单位：毫秒）\nConnect Time(ms)：连接服务器的时间。（单位：毫秒）\n样本数目：所有的请求个数\n平均：所有请求的平均响应时间。（单位：毫秒）\n最新样本：最新样本响应时间，表示服务器响应最后一个请求的时间。（单位：毫秒）\n偏离：不知道怎么算的，不发表意见。\nPart13.简单数据写入器 使用该元件，需要在所有数据写入一个文件配置文件路径(建议保存到D盘)。运行后，数据就会保存到文件中。然后可以使用查看结果树、聚合报告、图形结果等查看数据。\nPart14.邮件观察仪 主要是做提示用。可以自定义请求成功或失败的次数阈值，触发后就会自动发送邮件。\n需要配置发送人、收件人以及SMTP server。\nFrom：发件人邮箱\nAddressee(s)：收件人邮箱\nSuccess Subject：成功的请求数达到阈值后，要发送的信息\nFailure Subject：失败的请求数达到阈值后，要发送的信息\nSuccess Limit：成功的请求数阈值。如果不想发送，可以将值设未极大，如10000000\nFailure Limit：失败的请求数阈值。如果不想发送，可以将值设未极大，如10000000\nHost：SMTP服务器的域名或IP\nPort：SMTP服务器的端口号\nLogin：发件人邮箱账号，一般为发件人邮箱\nPassword：发件人的授权密码\n163邮箱为例，在设置中获取：\nCommection security：连接协议。一般都是SSl，以SMTP服务器指定协议为准。\n收件人收到的邮件\nPart15.BeanShell 监听器 BeanShell 监听器类似JSR223 监听器。只不过BeanShell 监听器只可以使用BeanShell语言。\n如果会使用JSR223 监听器，那么BeanShell 监听器也没问题。本质上都是编写脚本。\nPart15.最后要说的话 其实最常用的监听器就是查看结果树、聚合报告、JSR223 监听器，其他监听器特定情况也会用就是了。\n本篇总结了Jmeter中所有的监听器，希望能够供读者们借鉴。也期待大家踊跃发言。\n笔就横在这里吧。\n","date":"2024-06-14T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E7%9B%91%E5%90%AC%E5%99%A8/","title":"Jmeter-监听器"},{"content":"Part1.背景 我负责的一个项目经过长时间的开发，终于在客户现场正式运行了。虽然在正式运行前很长一段时间里我一直计划进行一次性能测试，但由于各种原因，测试一直没有进行。我们的运维人员在正式运行前进行了试运行，结果在一定数量的并发下，由于硬盘顶不住，系统直接卡死了。好吧！\nPart2.影响项目性能的因素分析 我负责的这个项目的主要功能就是对监控设备的视频流进行切片、存储，然后生成URL供平台调阅。它主要分为两个部分，切片、存储。这个项目中，不同存储方式导致项目架构不同。\n存储方面，提供3中存储方式——本地存储、S3接口存储、智能云存储。S3接口存储、智能云存储需额外配置存储服务器，与切片服务器分开，切片视频文件放在存储服务器中。本地存储则不需额外配置存储服务器，直接把切片视频文件放在切片服务器中。\n进行性能测试，首先要知道影响项目性能的因素有那些。与研发沟通后。切片时需关注cpu使用率、平均负载、内存使用。存储时需关注存储cpu使用率、内存使用率、平均负载、系统读写带宽信息、硬盘读写带宽信息。非本地存储时，还需要获取切片服务器与存储服务器之间的网络宽带信息。\nPart3.策划初步测试方案 首先需要明确，此项目主要功能的流程。\n由此可以初步策划两套测试方案。\n第一套\n使用Jmeter下发切片指令，切片服务器中使用top命令获取切片服务器切片过程中的cpu、平均负载、内存等信息 切片完成后。存储服务器中使用top命令获取切片视频存储过程中的cpu、平均负载、内存等信息，使用iostat命令获取切片视频存储过程中存储服务器存储过程中的硬盘信息；切片服务器中使用nload命令获取切片视频存储过程中的网络传输信息。 分析并整理获取到的所有信息 制作成结果图表 第二套\n使用Jmeter下发切片指令后，切片服务器中使用top命令获取切片服务器中的cpu、平均负载、内存等信息，使用iostat命令获取切片服务器存储过程中的硬盘信息。 分析并整理获取到的所有信息（分出切片、存储两个时间段） 制作成结果图表 Part4. 搭建测试方案所需环境 以第一套为例：\n准备切片服务器\n服务器系统使用Linux系统\n服务器中部署切片服务\n服务器中安装iostat、nload\n准备存储服务器\n服务器中部署存储服务(研发已经部署，直接白嫖)\n服务器中安装iostat\n编写服务器脚本，获取服务器信息\n服务器中编写所需top、iostat、nload脚本命令。\ntop脚本，用于切片服务器、存储服务器\n#!/bin/bash # 总循环时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 记录开始时间 start_time=$(date +%s) # 循环直到达到总时间 while true; do # 计算当前时间与开始时间的差值（秒） current_time=$(date +%s) elapsed_time=$((current_time - start_time)) # 如果已经达到或超过总时间，则退出循环 if [ $elapsed_time -ge $total_time ]; then break fi # 执行提供的命令 top -n 1 -b | head -n 6 \u0026gt;\u0026gt; /top.log # 睡眠2秒 sleep 2 done iostat脚本，用于切片服务器、存储服务器\n#!/bin/bash # 总持续时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 记录开始时间 start_time=$(date +%s) # 启动 iostat命令 并将输出重定向到日志文件，同时将其放入后台运行，根据需要写iostat。 (iostat -x -m -t 2 \u0026gt; /iostat.log) \u0026amp; # 保存 nload 的进程ID PID=$! # 等待$1秒 sleep $1 # 终止 iostat 进程 kill $PID nload脚本，用于切片服务器\n#!/bin/bash # 总持续时间（秒） total_time=$1 # 检查是否提供了总时间参数 if [ -z \u0026#34;$total_time\u0026#34; ]; then echo \u0026#34;Usage: $0 \u0026lt;total_time\u0026gt;\u0026#34; exit 1 fi # 启动 nload 并将输出重定向到日志文件，同时将其放入后台运行 (nload eno1 -u M -m -t 1500 \u0026gt; /nload.log) \u0026amp; # 保存 nload 的进程ID PID=$! # 等待60秒 sleep $1 # 终止 nload 进程 kill $PID 使用python编写服务远程执行top、iostat脚本\n主要目的是为了一键自动化，不需要自己手动执行top、iostat脚本。 思路是：使用Flask实现一个前置服务。Jmeter下发切片指令前请求前置服务，自动远程执行top、iostat脚本。 看读者可能会有疑问，nload脚本呢？ 我也想远程执行，但是远程执行后获取的log文件内没有任何信息。 查询得知，运行nload，Linux会拉起一个终端，但远程执行没有终端被拉起，花了一些时间也没找到解决办法，就只能手动执行了。\n代码如下：\n# Getdata.py import paramiko import time import threading from flask import Blueprint, jsonify, request GetData = Blueprint(\u0026#39;GetData\u0026#39;, __name__, template_folder=\u0026#39;templates\u0026#39;) def create_ssh_client(hostname, port, username, private_key_path): \u0026#34;\u0026#34;\u0026#34;创建并返回一个SSH客户端的辅助函数。\u0026#34;\u0026#34;\u0026#34; private_key = paramiko.RSAKey.from_private_key_file(private_key_path) client = paramiko.SSHClient() client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) client.connect(hostname, port=port, username=username, pkey=private_key) return client def execute_command_async(client, command): \u0026#34;\u0026#34;\u0026#34;在SSH客户端上执行命令的辅助函数。\u0026#34;\u0026#34;\u0026#34; stdin, stdout, stderr = client.exec_command(command) stdout.channel.recv_exit_status() def fetch_files(ssh_client, remote_path, local_path): \u0026#34;\u0026#34;\u0026#34;从远程服务器拉取文件的辅助函数。\u0026#34;\u0026#34;\u0026#34; try: with ssh_client.open_sftp() as sftp_client: sftp_client.get(remote_path, local_path) print(f\u0026#34;成功获取 {remote_path} 到 {local_path}\u0026#34;) except Exception as e: print(f\u0026#34;获取 {remote_path} 时出错: {e}\u0026#34;) def delete_remote_files(client, filenames): \u0026#34;\u0026#34;\u0026#34;删除远程服务器上的文件的辅助函数。\u0026#34;\u0026#34;\u0026#34; for filename in filenames: client.exec_command(f\u0026#39;rm {filename}\u0026#39;) def test165(long, client, hostname_command): \u0026#34;\u0026#34;\u0026#34;切片快结束时，执行存储服务器上的脚本。\u0026#34;\u0026#34;\u0026#34;\ttime.sleep(long - 10) execute_command_async(client, hostname_command) @GetData.route(\u0026#39;/api/GetTop/\u0026#39;, methods=[\u0026#39;GET\u0026#39;]) def gettop(): \u0026#34;\u0026#34;\u0026#34;获取切片时长\u0026#34;\u0026#34;\u0026#34; long = int(request.args.get(\u0026#34;time\u0026#34;)) print(long) \u0026#34;\u0026#34;\u0026#34;定义脚本执行时长\u0026#34;\u0026#34;\u0026#34; shi = 600 def background_task(): \u0026#34;\u0026#34;\u0026#34;定义服务器的信息\u0026#34;\u0026#34;\u0026#34; hostname1 = \u0026#39;192.168.1.111\u0026#39; hostname2 = \u0026#39;192.168.1.112\u0026#39; port = 22 username = \u0026#39;root\u0026#39; private_key_path = r\u0026#34;C:\\Users\\Ethereal Jiang\\.ssh\\id_rsa\u0026#34; \u0026#34;\u0026#34;\u0026#34;实例化ssh客户端并执行脚本命令。使用多线程是两个服务器互不影响。\u0026#34;\u0026#34;\u0026#34; client1 = None client2 = None try: client1 = create_ssh_client(hostname1, port, username, private_key_path) client2 = create_ssh_client(hostname2, port, username, private_key_path) hostname1_command = f\u0026#39;bash /opt/top_start.sh {long + shi} \u0026amp; bash /opt/iostat_start.sh {long + shi}\u0026#39; hostname2_command = f\u0026#39;bash /opt/top_start.sh {shi} \u0026amp; bash /opt/iostat_start.sh {shi}\u0026#39; thread1 = threading.Thread(target=execute_command_async, args=(client1, hostname1_command)) thread2 = threading.Thread(target=test165, args=(long, client2, hostname2_command)) thread1.start() thread2.start() thread1.join() thread2.join() except Exception as e: print(f\u0026#34;An error occurred: {e}\u0026#34;) finally: if not client1: client1 = create_ssh_client(hostname1, port, username, private_key_path) if not client2: client2 = create_ssh_client(hostname1, port, username, private_key_path) fetch_files(client2, \u0026#39;/top.log\u0026#39;, \u0026#39;D:\\\\test\\\\165\\\\top.log\u0026#39;) fetch_files(client2, \u0026#39;/iostat.log\u0026#39;, \u0026#39;D:\\\\test\\\\165\\\\iostat.log\u0026#39;) delete_remote_files(client2, [\u0026#39;/top.log\u0026#39;, \u0026#39;/iostat.log\u0026#39;]) fetch_files(client1, \u0026#39;/top.log\u0026#39;, \u0026#39;D:\\\\test\\\\169\\\\top.log\u0026#39;) fetch_files(client1, \u0026#39;/iostat.log\u0026#39;, \u0026#39;D:\\\\test\\\\169\\\\iostat.log\u0026#39;) delete_remote_files(client1, [\u0026#39;/top.log\u0026#39;, \u0026#39;/iostat.log\u0026#39;]) if client1: client1.close() if client2: client2.close() print(\u0026#39;结束\u0026#39; + str(time.time())) task_thread = threading.Thread(target=background_task) task_thread.start() return jsonify({\u0026#34;status\u0026#34;: \u0026#34;任务已开始在后台处理\u0026#34;}), 202 # app.py from flask import Flask from Getdata import GetData app = Flask(__name__) app.secret_key = \u0026#39;jiang\u0026#39; app.register_blueprint(GetData) if __name__ == \u0026#39;__main__\u0026#39;: app.run() 编写Jmeter脚本，下发切片指令\n如图所示： 执行脚本后，首先会请求前置服务，执行服务器脚本，然后，开始并发切片指令。nload脚本就需要在切片快结束时，手动执行。结束后，前置服务自动拉取信息文件到本地。\nPart5. 测试结束后后，分析、整理本地数据 每次并发测试三轮，信息文件放在对应的文件夹中。使用Notepad++和WPS表格处理数据。\nNotepad++查询复制数据，WPS表格分列数据。如图：\nPart6. 将分析整理后的数据制作成图表 我使用的是cdn库的Chart.js。示例如下：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;性能测试\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.net/Chart.js/3.9.1/chart.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; body { background: #9e9e9e1a; margin: 0; /* 移除默认的外边距 */ } .card { padding: 0 3%; background: #fff; border: 1px solid #dcdee2; border-color: #e8eaec; border-radius: 15px; width: 80%; /* 设置左右边距为自动 */ margin: 2% auto; } .data { margin-top: 2%; margin-bottom: 4%; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;data\u0026#34;\u0026gt; \u0026lt;span\u0026gt;5个并发\u0026lt;/span\u0026gt; \u0026lt;canvas id=\u0026#34;c5_169\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;data\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;c5_165\u0026#34; \u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 并发5 const c5_169_Ctx = document.getElementById(\u0026#39;c5_169\u0026#39;); const c5_169_Labels = [\u0026#39;%错误率\u0026#39;, \u0026#39;切片-%CPU最大使用率\u0026#39;, \u0026#39;切片-CPU最大负载(1分钟)\u0026#39;,\u0026#39;切片-内存最大使用-GiB\u0026#39;, \u0026#39;平均宽带速率-MByte/s\u0026#39;, \u0026#39;最小宽带速率-MByte/s\u0026#39;, \u0026#39;最大宽带速率-MByte/s\u0026#39;, \u0026#39;视频总体积-GByte\u0026#39;, \u0026#39;总流程时间(分)\u0026#39;, \u0026#39;存储写入时长(分)\u0026#39;, \u0026#39;存储-%CPU最大使用率\u0026#39;, \u0026#39;存储-CPU最大负载(1分钟)\u0026#39;, \u0026#39;存储-内存最大使用率-GiB\u0026#39; ]; // 设置 X 轴上对应的标签 const c5_169_Data = { labels: c5_169_Labels, datasets: [{ label: \u0026#39;结果\u0026#39;, data: [0, 11.16666667, 0.906666667, 6.707091217, 53.87263617, 8.97, 69.28666667, 1.86, 10.61666667, 0.555555556, 20.66666667, 1.936666667, 24.95719945], backgroundColor: [ \u0026#39;rgba(255, 99, 132, 0.2)\u0026#39;, // 粉色 \u0026#39;rgba(255, 159, 64, 0.2)\u0026#39;, // 橙色 \u0026#39;rgba(255, 205, 86, 0.2)\u0026#39;, // 浅黄色 \u0026#39;rgba(75, 192, 192, 0.2)\u0026#39;, // 青绿色 \u0026#39;rgba(153, 102, 255, 0.2)\u0026#39;, // 紫罗兰 \u0026#39;rgba(255, 206, 86, 0.2)\u0026#39;, // 金色 \u0026#39;rgba(75, 191, 92, 0.2)\u0026#39;, // 橄榄绿 \u0026#39;rgba(120, 75, 192, 0.2)\u0026#39;, // 深紫罗兰 \u0026#39;rgba(255, 92, 159, 0.2)\u0026#39;, // 品红色 \u0026#39;rgba(92, 255, 206, 0.2)\u0026#39;, // 浅绿松石色 \u0026#39;rgba(206, 92, 255, 0.2)\u0026#39;, // 浅洋红色 \u0026#39;rgba(159, 255, 92, 0.2)\u0026#39;, // 浅黄色绿色 \u0026#39;rgba(102, 86, 255, 0.2)\u0026#39; // 浅灰蓝色 ], borderColor: [ \u0026#39;rgb(255, 99, 132)\u0026#39;, // 粉色 \u0026#39;rgb(255, 159, 64)\u0026#39;, // 橙色 \u0026#39;rgb(255, 205, 86)\u0026#39;, // 浅黄色 \u0026#39;rgb(75, 192, 192)\u0026#39;, // 青绿色 \u0026#39;rgb(153, 102, 255)\u0026#39;, // 紫罗兰 \u0026#39;rgb(255, 206, 86)\u0026#39;, // 金色 \u0026#39;rgb(75, 191, 92)\u0026#39;, // 橄榄绿 \u0026#39;rgb(120, 75, 192)\u0026#39;, // 深紫罗兰 \u0026#39;rgb(255, 92, 159)\u0026#39;, // 品红色 \u0026#39;rgb(92, 255, 206)\u0026#39;, // 浅绿松石色 \u0026#39;rgb(206, 92, 255)\u0026#39;, // 浅洋红色 \u0026#39;rgb(159, 255, 92)\u0026#39;, // 浅黄色绿色 \u0026#39;rgb(102, 86, 255)\u0026#39; // 浅灰蓝色 ], borderWidth: 1 // 设置线条宽度 }] }; const c5_169_Config = { type: \u0026#39;bar\u0026#39;, // 设置图表类型 data: c5_169_Data, // 设置数据集 options: { scales: { y: { beginAtZero: true // 设置 y 轴从 0 开始 } }, plugins: { title: { display: true, text: \u0026#39;\u0026#39; // 这里设置图表的标题 }, datalabels: { anchor: \u0026#39;end\u0026#39;, align: \u0026#39;top\u0026#39;, formatter: function(value, context) { return value.toFixed(2); // 设置标签格式 } } } }, plugins: [ChartDataLabels] }; const c5_169_Chart = new Chart(c5_169_Ctx, c5_169_Config); const c5_165_ctx = document.getElementById(\u0026#39;c5_165\u0026#39;); const c5_165_labels = [\u0026#39;avg-wMB/s\u0026#39;, \u0026#39;min-wMB/s\u0026#39;, \u0026#39;max-wMB/s\u0026#39;,\u0026#39;avg-w_await\u0026#39;, \u0026#39;min-w_await\u0026#39;, \u0026#39;max-w_await\u0026#39;, \u0026#39;avg-%util\u0026#39;, \u0026#39;min-%util\u0026#39;, \u0026#39;max-%util\u0026#39;]; // 设置 X 轴上对应的标签 const c5_165_data = { labels: c5_165_labels, datasets: [{ label: \u0026#39;sdb\u0026#39;, data: [52.36925926, 5.89, 83.85, 28.26445534, 8.703333333, 59.62, 89.57178649, 28.28333333, 98.7], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }, { label: \u0026#39;sdc\u0026#39;, data: [52.37021786, 6.886666667, 83.69333333, 26.18413943, 7.443333333, 60.51333333, 87.21247277, 23.35, 97.43333333], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }, { label: \u0026#39;sdd\u0026#39;, data: [52.37001089, 6.553333333, 83.18666667, 26.98811547, 8.673333333, 56.51, 89.42472767, 26.16666667, 98.3], backgroundColor: [ // 设置每个柱形图的背景颜色 \u0026#39;rgba(55, 163, 236, 0.2)\u0026#39;, \u0026#39;rgba(76, 193, 192, 0.2)\u0026#39;, \u0026#39;rgba(256, 205, 87, 0.2)\u0026#39;, \u0026#39;rgba(152, 103, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 65, 0.2)\u0026#39;, \u0026#39;rgba(254, 100, 133, 0.2)\u0026#39;, \u0026#39;rgba(154, 101, 254, 0.2)\u0026#39;, \u0026#39;rgba(254, 160, 66, 0.2)\u0026#39;, \u0026#39;rgba(254, 98, 133, 0.2)\u0026#39; ], borderColor: [ //设置每个柱形图边框线条颜色 \u0026#39;rgba(55, 163, 236)\u0026#39;, \u0026#39;rgba(76, 193, 192)\u0026#39;, \u0026#39;rgba(256, 205, 87)\u0026#39;, \u0026#39;rgba(152, 103, 254)\u0026#39;, \u0026#39;rgba(254, 160, 65)\u0026#39;, \u0026#39;rgba(254, 100, 133)\u0026#39;, \u0026#39;rgba(154, 101, 254)\u0026#39;, \u0026#39;rgba(254, 160, 66)\u0026#39;, \u0026#39;rgba(254, 98, 133)\u0026#39; ], borderWidth: 1 // 设置线条宽度 }] }; const c5_165_config = { type: \u0026#39;bar\u0026#39;, // 设置图表类型 data: c5_165_data, // 设置数据集 options: { scales: { y: { beginAtZero: true // 设置 y 轴从 0 开始 } }, plugins: { title: { display: true, text: \u0026#39;存储-硬盘信息\u0026#39; // 这里设置图表的标题 }, datalabels: { anchor: \u0026#39;end\u0026#39;, align: \u0026#39;top\u0026#39;, formatter: function(value, context) { return value.toFixed(2); // 设置标签格式 } } } }, plugins: [ChartDataLabels] }; const c5_165_Chart = new Chart(c5_165_ctx, c5_165_config); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; chart.js还是比较强的，可以访问Chart.js学习使用。\nPart7. 最后要说的话 本文一是对本次测试做下总结，二是希望能够供读者们借鉴。\n整个过程还是挺漫长的，即要等待每轮测试结束，还要分析整理数据并制作成图表。不过完成这个性能测试，确给我带来了成就感。也知道自己还有很多不足，希望有大佬同我交流讨论，共同进步。\n本篇就在此止步了。\n","date":"2024-05-28T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Other/Performance/0.png","permalink":"https://www.jzy-blogs.cn/p/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/","title":"记一次性能测试"},{"content":"CSV Data Set Config CSV Data Set Config是一种元件。它允许你从CSV、TXT文件中读取数据，并在测试计划的运行过程中将这些数据作为变量使用。这在进行性能测试时非常有用，尤其是当你需要模拟大量用户使用不同的输入数据时。可以添加在测试计划、线程组、取样器下，作用域也随之变化。\n我们在线程组文章中使用过CSV Data Set Config，相信大家已经明白它的作用。这里就再详细描述一下。\n","date":"2024-05-24T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/pytest/","title":"pytest"},{"content":"CSV Data Set Config CSV Data Set Config是一种元件。它允许你从CSV、TXT文件中读取数据，并在测试计划的运行过程中将这些数据作为变量使用。这在进行性能测试时非常有用，尤其是当你需要模拟大量用户使用不同的输入数据时。可以添加在测试计划、线程组、取样器下，作用域也随之变化。\n我们在线程组文章中使用过CSV Data Set Config，相信大家已经明白它的作用。这里就再详细描述一下。\nPart1.文件名 需输入数据文件的路径，运行时Jmeter会按路径查找数据文件。如果路径错误，Jmeter会报错。\n如果路径错误。\nJMeter提示试图读取一个名为test.txt的文件，但是这个文件不存在或者JMeter没有读取它的权限。\nPart2.文件编码 编码是计算机用于表示字符的数字或二进制值。以下是一些常见的编码系统及其特点：\nASCII (American Standard Code for Information Interchange)\n编码范围：0-127 字符集：基本的英文字符、数字、标点符号和控制字符。 Extended ASCII\n编码范围：128-255 字符集：在ASCII基础上扩展，包含其他语言的字符。 ISO 8859-1 (Latin-1 Character Set)\n编码范围：0-255 字符集：扩展了ASCII，包括西欧语言的特殊字符。 UTF-8 (Unicode Transformation Format - 8-bit)\n编码范围：1-4字节 字符集：支持全球几乎所有语言的字符，包括表情符号等。 UTF-16 (Unicode Transformation Format - 16-bit)\n编码范围：2字节（BMP）或4字节（辅助平面） 字符集：同UTF-8，但使用固定长度的字节对。 UTF-32 (Unicode Transformation Format - 32-bit)\n编码范围：固定4字节 字符集：同UTF-8和UTF-16，但每个字符固定占用4字节。 GBK (Chinese Internal Code Specification)\n编码范围：双字节 字符集：主要用于简体中文。 GB2312\n编码范围：单字节和双字节 字符集：主要用于简体中文，是GBK的前身。 Big5\n编码范围：双字节 字符集：主要用于繁体中文。 Shift_JIS (Shifting Japanese Industrial Standards)\n编码范围：单字节和双字节 字符集：主要用于日文。 EUC-JP (Extended Unix Code - Japanese)\n编码范围：多字节 字符集：主要用于日文。 KOI8-R (KOI8 Russian)\n编码范围：单字节 字符集：主要用于俄文。 这些编码系统各有特点，适用于不同的语言和场景。随着全球化的发展，UTF-8因其兼容性和效率成为了最广泛使用的编码方式。\n推荐使用UTF-8编码，因为它可以表示任何语言的字符，并且是Web标准。几乎所有的现代文本编辑器、浏览器和编程语言都支持UTF-8。如遇到一些UTF-8无法兼容的语言，可以选择或编辑添加其他编码。\nPart3.变量名称 数据文件中，1列对应1个变量，从左依次对应。变量名称不应多于列数。每次读取1行。以TXT文件为例：\n111,222,333,444,555,666,777 aaa,bbb,ccc,ddd,eee,fff,ggg 数据文件中有5列，代表有7个变量。变量名称可以输入a1,a2,a3,a4,a5,a6,a7，a1获取第1列，a7获取第7列。a1第1次获取111，a1第2次获取aaa。\nPart4.忽略首行 如果数据文件的第一行包含列标题，可以使用此选项跳过第一行，只读取数据。以csv文件为例：\n姓名 联系方式 居住地址 性别 国家 民族 兴趣爱好 姜 17620815555 河南 男 中国 汉 读书 刘备 信使传信 汉蜀 男 蜀国 汉 当皇帝 第1行只是标题，实际上并不需要标题数据。这种情况下可以选择True，不获取第1行。\nPart5.分隔符 不建议更改，使用,(英文符)即可。这代表着TXT文件中列于列之间要用,分隔。\nPart6.是否允许带引号 以TXT文件为例：\n\u0026#34;444\u0026#34; 如果选择True，引用变量时，获取的值会是444。如果选择False，引用变量时，获取的值会是\u0026quot;444\u0026quot;。\nPart7.遇到文件结束符再次循环 文件结束符（End Of File，简称EOF）是一个用于表示文件内容结束的信号，在txt、csv等文件的未尾以\u0026lt;EOF\u0026gt;结束。当程序读取文件时，以\u0026lt;EOF\u0026gt;来确定是否已经到达文件的末尾。\n当读取到文件的结束符\u0026lt;EOF\u0026gt;，线程或循环还没结束时。如果选择True，接下来的线程或循环会继续从文件的首行开始（可能忽略首行）。如果选择False，接下来的线程或循环会一直获取文件的结束符\u0026lt;EOF\u0026gt;。\nPart8.遇到文件结束符停止线程 当读取到文件的结束符\u0026lt;EOF\u0026gt;，线程或循环还没结束时。如果选择True，接下来的线程或循环不会再继续。如果选择False，不会影响到线程或循环的继续。\nPart9.线程共享模式 示例txt文件\n111,222,333,444 aaa,bbb,ccc,ddd 888,999,1010,2020 fff,iii,jjj,kkk 6060,7070,8080,9090 000,ppp,qqq,rrr 示例Jmeter脚本\n此时只有1个线程，线程共享模式配置为所有线程。\n所有线程 所有线程共享同一个CSV文件。这是默认的共享模式。在这个模式下，所有线程将按照顺序读取CSV文件中的数据，直到文件结束。\n示例Jmeter脚本运行结果\n请求1、请求2同属1个线程，从CSV Data Set Config中所获取的数据也是一样的。\n修改示例Jmeter脚本，线程组的线程数为 2 ，运行结果\n线程组1-1的请求1、请求2，从CSV Data Set Config中所获取的数据相同。线程组1-2的请求1、请求2，从CSV Data Set Config中所获取的数据相同。不同线程所获取的数据不同。\n修改示例Jmeter脚本，新增一个线程组\n运行结果\n两个线程组，每个线程组两个线程，共四个线程。这四个线程顺序从CSV Data Set Config获取数据。\n当前线程组 在这个模式下，只有同一个线程组内的线程会共享CSV文件。比如数据文件有10行数据，并且有10个线程在同一个线程组中，每个线程将分别读取一行数据。不同的线程组分别独立从CSV Data Set Config获取数据。\n修改示例Jmeter脚本，新增一个线程组，CSV Data Set Config 线程共享模式配置为 当前线程组\n运行结果\n同是两个线程组、每个线程组两个线程。但配置当前线程组共享，两个线程组分别独立从CSV Data Set Config获取数据。所以线程组1-1与线程组2-1获取的数据一致。\n当前线程 在这个模式下，不同线程不会共享CSV文件，分别独立从CSV Data Set Config获取数据。\n当前线程组-Jmeter脚本中，CSV Data Set Config 线程共享模式配置为 当前线程，运行结果\n每个线程都独立从CSV Data Set Config获取数据。所以各个线程获取的数据是一致的。\nPart10.循环\u0026amp;\u0026amp;编辑 其中忽略首行、是否允许带引号、遇到文件结束符再次循环、遇到文件结束符停止线程、线程共享模式的选项中还有编辑选项。因没有使用过，我并不知怎样使用及作用。读者们可以去探究一番。\n另外在使用CSV Data Set Config时，要注意线程数及循环次数。\n配置所有线程，如果有2个线程组、每个线程组2个线程及多次循环，数据文件有100行。运行时，第1次循环。2个线程组总4个线程依次获取数据文件的前4行。第2次循环。2个线程组总4个线程依次获取数据文件的5-8行。依次类推从数据文件中获取数据。\n配置当前线程组，如果有2个线程组、每个线程组2个线程及多次循环，数据文件有100行。 运行时，第1次循环。每个线程组独立从数据文件中获取数据，每个线程组中的2个线程依次获取数据文件的前2行。第2次循环。每个线程组独立从数据文件中获取数据，每个线程组中的2个线程依次获取数据文件的3-4行。依次类推从数据文件中获取数据。\n配置当前线程，如果有2个线程组、每个线程组2个线程及多次循环，数据文件有100行。 运行时，第1次循环。每个线程独立从数据文件中获取数据，每个线程获取数据文件的第1行。第2次循环。每个线程独立从数据文件中获取数据，每个线程获取数据文件的第2行。依次类推从数据文件中获取数据。\nPart11.最后要说 衷心希望读者进行评论，指出我的不足或者进行交流。\n就让笔迹停在这里吧。\n","date":"2024-05-14T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-csv-data-set-config/","title":"Jmeter-CSV Data Set Config"},{"content":"Part1.背景 咱们测试同学有时候不得不需要自己去搭建一个测试环境，保证自己的测试可以顺畅进行。测试环境可以运行在物理机或者虚拟机上。测试环境在物理机上无疑更真实、准确，但物理机价格、便捷方面都不如虚拟机。而且虚拟机通过精心搭配，真实、准确方面也不容小觑。\n现在市面上可以搭建虚拟机的软件不少。如Vmware、VirtualBox、QEMU、Parallels Desktop、Microsoft Hyper-V等。我为什么推荐VMware呢？因为我第一次搭建虚拟机使用的就是它，而且只用过它😅。无论如何，开始我们的VMware之旅吧。\nPart2.准备VMware 下载VMware\nVMware下载地址包含Mac和window版本\rhttps://www.vmware.com/products/desktop-hypervisor.html\r根据自己的系统去下载对应版本\n请注意这里下载的是Pro版本，是收费的。你也可以去下载免费版本，或者去搜激活码来进行激活。不过你懂的。我不提供方法。\n安装VMware\n下载成功后，双击安装后一直下一步就行。然后界面如下：\n我这里已经搭建了2个虚拟机了，你们刚进去的时候，是没有这两个虚拟机的。\nPart3.新建虚拟机 如图.\n此时一个虚拟机就搭建好了。图中的测试安装centos 7。\nPart4.设置虚拟机 后面还需要对虚拟机进行一些设置，才能达成目的。\n有关网络连接的知识可以点击下方卡片进行了解。\n使用 VMware Workstation Pro\rhttps://docs.vmware.com/cn/VMware-Workstation-Pro/17/com.vmware.ws.using.doc/GUID-0CE1AE01-7E79-41BB-9EA8-4F839BE40E1A.html\rPart5.运行虚拟机 点击运行虚拟机后，VMware开始运行ISO镜像文件。然后就是各个系统经典的初始化界面。我这里以centos 7 为例。\n以上示例的是centos7。需要知道的是，每个系统的初始化界面可能有区别。比如windows一定与centos 7不同。\nPart6.网络配置 此时安装好的centos 7还不能访问inter网、局域网，甚至主机。访问其他网络，需要进行一些配置。我们以桥接模式为例。\nVMware上进行设置\ncentos 7上进行配置\n查看网口信息\n# 查看网口信息 ip link # 示例centos 7，输出信息如下： 1: lo: \u0026lt;LOOPBACK,UP,LOWER_UP\u0026gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 2: ens33: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000 link/ether 00:0c:29:cf:f0:d8 brd ff:ff:ff:ff:ff:ff 输出的网口信息有lo、ens33.\nlo 是本地回环接口，通常用于本地主机上的网络服务。它总是激活的，并且可以用于本地主机上的网络请求。\nens33 是一个以太网接口。这个接口是连接到物理网络的，但是当前的输出并没有显示IP地址分配情况。\n编辑网络配置文件。\n# 编辑ens33的配置文件 vi /etc/sysconfig/network-scripts/ifcfg-ens33 配置网络接口\n# 只需要自动分配IP就行。修改以下配置。 BOOTPROTO=dhcp ONBOOT=yes 重启网络服务：\n# 保存并关闭配置文件，然后重启网络服务以应用更改 sudo systemctl restart network 验证网络配置\n# 使用ping命令测试网络连接 ping -c 4 8.8.8.8 # 使用ip addr 检查IP地址 ip addr 远程连接\n使用MobaXterm远程。\n如果远程失败，可以使用systemctl stop firewalld关闭防火墙，再远程。\n以上以centos 7为示例。其他系统的IP设置可能不是这样，至少windows肯定与centos 7不同。\nPart7.最后要说 到这一步呢，距离你搭建完整的测试环境，只剩下部署你们的产品了。我就没有发言权了。另外还有网络这块，VMware还有NAT模式、仅主机模式、自定义、LAN区段值得探讨。除此之外，还有其他的内容。不过都放在之后的文章中吧，本文不在阐述。\n","date":"2024-05-10T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Other/VMware1/0.png","permalink":"https://www.jzy-blogs.cn/p/%E4%BD%BF%E7%94%A8vmware%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83/","title":"使用VMware搭建测试环境"},{"content":"HTTP请求 JMeter提供多种取样器，HTTP取样器（HTTP Sampler）无疑是最核心的一个。HTTP取样器是用来模拟客户端和服务器之间HTTP请求和接收响应的工具，它可以发送各种类型的HTTP请求，如GET、POST、PUT、DELETE等，用于请求不同的资源。\nHTTP取样器控制面板中包含元素：\n名称、注释\nweb服务器\nHTTP请求\n参数\n消息体数据\n文件上传\n客户端实现\n超时\n从HTML文件获取所有内含的资源\n源地址\n代理服务器\n其他任务\nPart1.web服务器\u0026amp;\u0026amp;HTTP请求 web服务器没什么好讲的，只保证IP/域名、端口、路径、请求方式、协议正确就好。内容编码最好输入UTF-8(兼容大部分语言)，防止接口解析时乱码。\n自动重定向和跟随重定向 自动重定向只针对Get和Head请求，自动重定向转向到最终目标页面，但是Jmeter不记录重定向的中间页面过程，只记录最终页面返回结果。在结果树中，只能看到最终页面的服务器返回。\n跟随重定向是http request 取样器的默认选项，会自动跳转到目标地址。Jmeter会记录重定向过程中的所有请求的响应结果。在结果树中，可以看到所有请求的服务器返回。\n两者只能选中一个。这次我们访问知乎来进行测试。\n示例Jmeter脚本\n测试计划中添加线程组\n线程组中添加HTTP取样器\n请求地址：HTTPS://www.zhihu.com\n请求方式：GET\n测试计划中添加查看结果树\n勾选跟随重定向，运行结果\nHTTP请求-0的GET https（请求地址）为//www.zhihu.com/。\nHTTP请求-1的GET https（请求地址）为//www.zhihu.com/signin?next=%2F。\nHTTP请求-0的响应数据是一个重定向的a链接，链接地址为//www.zhihu.com/signin?next=%2F-即HTTP请求-1的请求地址。\nHTTP请求-1的响应才是最终的页面。Jmeter的查看结果树记录了重定向过程。\n勾选自动重定向，运行结果\n结果树中只有一个HTTP请求，请求地址为//www.zhihu.com/signin?next=%2F-即最终的页面数据。查看结果树中没有记录重定向过程。\n使用KeepAlive 选中该选项，JMeter和目标服务器之间使用Keep-Alive方式进行HTTP通信，默认选中。keep-alive属性，用于建立长连接，可以避免连接频繁建立和释放的开销。有兴趣的可以搜索HTTP的Keep-Alive模式，详细了解。\n与浏览器兼容的头 没有发现有什么作用。希望有知道的读者可以通过评论指正我。\nPart2.请求参数-GET 请求方式为GET时，请求参数一般都直接跟在url后面，不需要参数类型。当然也可以请求参数不跟在url后面，不过比较少见。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest2/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def parameters(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#34;此次请求的请求方式是GET，请求参数为: name=\u0026#34;+request.args.get(\u0026#39;name\u0026#39;) return \u0026#34;请使用GET请求方式\u0026#34; 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest2/\n请求方式：GET\n参数名称：name\n参数值：随意写就行\n测试计划中添加查看结果树\nGET请求下，使用参数发送请求，运行结果\n请求数据中的第一行：GET http://127.0.0.1:5000/api/HTTPRequest2/?name=姜。\n其中?name=姜就是脚本中添加的参数。\n必须使用参数吗？我们可以尝试一下不使用参数的方法（修改示例脚本）\nHTTP 请求中删除参数\nHTTP 请求中路径改为/api/HTTPRequest2/?name=姜\n看一下修改示例脚本后的运行结果\n仔细看图会发现，与使用参数方法的结果是一样的。\n都是GET http://127.0.0.1:5000/api/HTTPRequest2/?name=姜 。\nPart3.请求参数-POST\u0026amp;application/x-www-from-urlencoded 请求方式POST，常用的的请求参数类型(Content-Type)有application/x-www-from-urlencoded、multipart/form-data、raw、binary。\napplication/x-www-from-urlencoded会将表单内的数据转换为键值对，比如name=python\u0026amp;age = 22。\n这种方式只能以键值对形式发送参数，如果不指定content-type，默认application/x-www-form-urlencoded。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest2/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def parameters(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#34;此次请求的请求方式是GET，请求参数为: name=\u0026#34;+request.args.get(\u0026#39;name\u0026#39;) return \u0026#34;请使用GET请求方式\u0026#34; 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest2/\n请求方式：POST\n参数名称：随意写就行\n参数值：随意写就行\n测试计划中添加查看结果树\n运行结果\nRequest Headers中显示 Content-Type 为 application/x-www-form-urlencoded; charset=UTF-8。\nRequest Body中的 POST data 也是键值对形式： aaaa=姜振园\u0026amp;bbb=姜振园\u0026amp;ccc=姜振园\nPart4.请求参数-POST\u0026amp;multipart/form-data multipart/form-data会将表单的数据处理为一条消息，以标签为单元，用分隔符分开。就像这样：\nPOST /profile HTTP/1.1 HOST: example.com Content-Type: multipart/form-data; boundary=example-part-boundary # multipart/form-data; boundary=example-part-boundary表示这个请求的的消息类型是 # multipart-form-data，每个 part 之间的边界为 example-part-boundary。 # example-part-boundary是一段很长的字符串，如bqtFfLzQXUbOvsHrs8eOO9kIlZ30hA。 --example-part-boundary Content-Disposition: form-data; name=\u0026#34;username\u0026#34; Content-Type: text/plain Nicholas # 第一个 part 的类型为 text/plain，它在表单上对应的 key 为 username，value 为 Nicholas --example-part-boundary Content-Disposition: form-data; name=\u0026#34;address\u0026#34; Content-Type: application/json { \u0026#34;country\u0026#34;: \u0026#34;China\u0026#34;, \u0026#34;city\u0026#34;: \u0026#34;Beijing\u0026#34; } # 第二个 part 的类型为 application/json，它在表单上对应的 key 为 address。 --example-part-boundary Content-Disposition: form-data; name=\u0026#34;avatar\u0026#34;; filename=\u0026#34;my_avatar.jpeg\u0026#34; Content-Type: image/jpeg \u0026lt;binary-image data\u0026gt; # 第三个 part 的数据类型为 image/jpeg，它在表单上对应的 key 为 avatar， # 并且 part 的头部还附加了文件名相关的元数据 filename=\u0026#34;my_avatar.jpeg。 --example-part-boundary-- # 最后面的 --example-part-boundary-- 表示整个 multipart 消息的结束。 由于这种方式可以将数据分为很多部分，它既可以上传键值对，也可以上传文件，甚至多个文件。当上传的字段是文件时，会有Content-Type来说明文件类型：Content-disposition，用来说明字段的一些信息。\n每部分都是以-boundary开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容(字段、文本或二进制等)。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以-boundary-标示结束。\n当使用POST方式进行请求\u0026amp;请求参数包含一般参数\u0026amp;文件时，会自动指定参数类型为multipart/form-data。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest1/\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def upload_file(): if \u0026#39;username\u0026#39; not in request.form: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;缺少username字段\u0026#39;}), 400 if \u0026#39;address\u0026#39; not in request.form: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;缺少address字段\u0026#39;}), 400 if \u0026#39;image\u0026#39; not in request.files: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;缺少image字段\u0026#39;}), 400 username = request.form[\u0026#39;username\u0026#39;] address = request.form[\u0026#39;address\u0026#39;] image_file = request.files[\u0026#39;image\u0026#39;] if image_file.filename == \u0026#39;\u0026#39;: return jsonify({\u0026#39;error\u0026#39;: \u0026#39;未选择文件\u0026#39;}), 400 if image_file: filename = secure_filename(image_file.filename) save_path = \u0026#39;C:/image/\u0026#39; # 指定保存路径 # 检查保存路径是否存在，如果不存在则创建 if not os.path.exists(save_path): os.makedirs(save_path) # 保存文件到指定保存路径，Jmeter请求后可以到save_path指定路径查看上传的文件 image_file.save(os.path.join(save_path, filename)) return jsonify({ \u0026#39;username\u0026#39;: username, \u0026#39;address\u0026#39;: address, \u0026#39;avatar_filename\u0026#39;: filename }), 200 return jsonify({\u0026#39;error\u0026#39;: \u0026#39;未选择文件\u0026#39;}), 400 示例Jmeter脚本\n测试计划中添加线程组\n线程组中添加HTTP 取样器\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest1/\n请求方式：POST\n参数1名称：username\n参数1值:姜振园\n参数2名称：address\n参数2值:{\u0026quot;country\u0026quot;: \u0026quot;中国\u0026quot;,\u0026quot;city\u0026quot;: \u0026quot;杭州\u0026quot; }\n文件上传名称：正确的文件路径（可以上传图片）\n文件上传参数名称：image\n测试计划中添加查看结果树\n运行结果\n请求参数类型是multipart/form-data，响应也是正确的。另外可以去save_path查看上传的图片或文件。\n当然也可使用消息体添加请求参数(可以添加 Text、JavaScript、JSON、HTML、XML 等格式文件)\u0026amp;\u0026amp;上传文件。读者可以自己尝试一下。\n请求方式为POST\u0026amp;\u0026amp;请求参数包含一般参数\u0026amp;\u0026amp;不上传文件，请求参数类型默认application/x-www-form-urlencoded。\n这种场景下，如果想要指定请求参数类型为multipart/ form-data，可以勾选对POST使用multipart/ form-data。读者可以自己尝试一下。\nPart5.请求参数-POST\u0026amp;text/plain raw是指可以上传任意格式的文本，如text、json、xml、html等。这里演示一下如何上传文本内容。\ntext/plain用于发送纯文本内容，空格符为+，不对特殊字符进行编码。\nJmeter中，消息体中输入相应内容，请求参数类型默认为text/plain。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest2/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def parameters(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#34;此次请求的请求方式是GET，请求参数为: name=\u0026#34;+request.args.get(\u0026#39;name\u0026#39;) return \u0026#34;请使用GET请求方式\u0026#34; 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest2/\n请求方式：POST\n消息体数据：随意（中间加空格）写就行\n测试计划中添加查看结果树\n运行结果\nContent-Type: text/plain; charset=UTF-8，表明该请求参数类型为text/plain。 请求参数就是纯文本：随意写就行。\nPart6.请求参数-POST\u0026amp;application/json application/json用于发送JSON字符串，也是比较常用的一种方式。\nJmeter中发送JSON字符串，需要在消息体中输入JSON格式内容\u0026amp;\u0026amp;在消息头管理器添加content-type：application/json。\n示例接口\n@HTTPRequest.route(\u0026#39;/api/HTTPRequest3/\u0026#39;, methods=[\u0026#39;POST\u0026#39;, \u0026#39;GET\u0026#39;]) def httprequest3(): if request.method == \u0026#39;POST\u0026#39;: data = request.get_json() if \u0026#34;name\u0026#34; not in data: return \u0026#34;请求参数错误\u0026#34; return \u0026#34;此次请求的请求方式是GET，请求参数为: \u0026#34; + str(data) return \u0026#34;请使用POST请求方式\u0026#34; 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest3/\n请求方式：POST\n消息体数据：{\u0026quot;name\u0026quot;:\u0026quot;姜振园\u0026quot;}\nHTTP 请求中添加HTTP信息请求头管理器（右键-添加-配置元件）\n名称：content-type\n值：application/json\n测试计划中添加查看结果树 运行结果\n请求参数类型为application/json。请求参数就是JSON字符串：{\u0026quot;name\u0026quot;:\u0026quot;姜振园\u0026quot;}。\n还可以请求HTML、XML、CSS、JS等内容，上传方法与JSON类似。消息体中输入相应格式内容\u0026amp;\u0026amp;信息头管理器中添加对应的Content-Type。\nHTMl的请求参数类型是text/html。\nXML的请求参数类型是text/XML。\nCSS的请求参数类型是text/CSS。\nJS的请求参数类型是text/JS。\n读者可以尝试一下。\nPart7.请求参数-POST\u0026amp;binary binary即application/octet-stream，二进制数据。通常用来上传二进制文件，没有键值。\nJmeter中，消息体中输入二进制数据\u0026amp;\u0026amp;消息头管理器添加content-type:application/octet-stream。\n文本转二进制工具\n示例接口\ndef httprequest4(): if request.method != \u0026#39;POST\u0026#39;: return \u0026#39;你的请求方式有误\u0026#39;, 405 if request.content_type == \u0026#39;application/octet-stream\u0026#39;: stream = request.stream data = stream.read() print(data) try: text_data = data.decode(\u0026#39;utf-8\u0026#39;) print(text_data) except UnicodeDecodeError: return \u0026#39;解码错误，数据可能不是UTF-8编码\u0026#39;, 400 binary_strings = text_data.split() decimal_numbers = [int(binary, 2) for binary in binary_strings] unicode_characters = [chr(decimal) for decimal in decimal_numbers] text = \u0026#39;\u0026#39; for x in unicode_characters: text = text + x return text, 200 else: return \u0026#39;不支持的Content-Type\u0026#39;, 415 示例Jmeter脚本\n测试计划 中添加 线程组\n线程组中添加HTTP 请求\n请求地址：HTTP://127.0.0.1:5000/api/HTTPRequest4/\n请求方式：POST\n消息体数据：110001000010001 110011000101111 1001010 1101001 1100001 1101110 1100111（\u0026lsquo;我是Jiang\u0026rsquo;的二进制流）\nHTTP 请求中添加HTTP信息请求头管理器（右键-添加-配置元件）\n名称：content-type\n值：application/octet-stream\n测试计划中添加查看结果树 运行结果\nContent-Type: application/octet-stream，表明该请求参数类型为application/octet-stream。\n请求参数就是二进制流：110001000010001 110011000101111 1001010 1101001 1100001 1101110 1100111。\n响应数据我是Jiang正是二进制文件处理后的文本内容。\nPart8.Http请求默认值 Jmeter中提供配置元件HTTP请求默认值，它提供默认能力。比如HTTP默认值中指定了IP、端口，其作用域下任何没有指定IP、端口的HTTP取样器都会使用HTTP默认值中IP、端口。其他参数的逻辑一致。\nHTTP请求默认值中不能进行文件上传。\nPart9.最后要说 现在的应用基本都使用HTTP协议进行传输，希望本篇能帮助读者了解及使用Jmeter发送HTTP协议的请求。\n衷心希望读者进行评论及指正。\n那就在这里结束啦。\n","date":"2024-04-03T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-http%E8%AF%B7%E6%B1%82/","title":"Jmeter-HTTP请求"},{"content":"线程组 线程组作为JMeter测试计划的核心组件之一，对于模拟并发用户的行为至关重要。线程组元件是整个测试计划的入口，所有的取样器和控制器必须放置在线程组下。\n可以将线程组视为一个虚拟用户池，其中每个线程可被理解为一个虚拟用户，多个虚拟用户同时执行相同的一批任务。\n在这个虚拟用户池中，每个线程之间是相互隔离且互不影响的。每个线程的执行过程中，操作的变量不会对其他线程的变量值产生影响。\n线程组的关键任务之一是定义并发用户的行为，包括设置线程数、循环次数、启动延迟等关键参数。通过适当配置线程组，测试人员可以模拟多用户在系统中同时执行任务的场景，从而评估系统的性能和稳定性。\n通过灵活使用setup线程组、线程组、tearDown线程组、开放模型线程组，配置前置操作、主要操作、后置操作，更能真实、详细的评估系统。\n线程组分为四类:\n线程组 setUp线程组 tearDown线程组 开放模型线程组 线程组、setUp线程组、tearDown线程组控制面板中的元素基本一致：\n名称、注释 在取样器错误后执行的动作 线程数 Ramp-Up时间 Same user on each iteration 延迟创建线程直到需要（只有线程组有） 调度器 开放模型线程组控制面板中的元素：\n名称、注释 在取样器错误后执行的动作 调度计划 随机种子 Part1.取样器错误后执行的动作 在JMeter中，取样器（Sampler）是用于模拟用户请求发送到目标服务器的组件，例如HTTP请求、FTP请求等。当取样器执行过程中出现错误时，可以通过配置相应的动作来处理这些错误。以下是一些处理取样器错误时，线程组中常见方式：\n停止线程\n任何一个线程（用户）在执行过程中遇到错误时，该线程被停止，不影响其他线程（用户）。\n启动下一进程循环 任何一个线程（用户）在执行过程中遇到错误时，Jmeter会立即停止当前线程的本次执行，并进行当前线程（用户）的下次执行，主要应用于线程多次循环时。\n继续（无需演示）\nJMeter将在取样器执行错误时，忽略错误继续执行本线程的后续操作及执行其他线程。\n停止线程-多线程 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止线程\n线程数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${yonghu}（在前）、正确请求-${yonghu}\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;200,用户1\n\u0026emsp;\u0026emsp;1111,用户2\n\u0026emsp;\u0026emsp;200,用户3\n文件编码：UTF-8\n变量名称：ceshi,yonghu\n错误请求取样器下添加响应断言\n值：${ceshi}\n在测试计划中，添加查看结果树\n运行结果\n连续运行了3次，结果是一致的。总共有三个用户执行线程组，其中用户1、用户3完全执行成功；用户2只执行了错误请求。\n因为设置取样器错误后执行的动作为停止线程，用户2执行错误请求时发生错误，Jmeter只会停止用户2的后续执行，不会影响其他线程。\n多线程组也是多线程，读者在实际的脚本编写中，要注意每个线程的情况去使用停止线程。\n停止线程-多循环 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止线程\n循环次数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${xunhuan}（在前）、正确请求-${xunhuan}\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;200,第1次循环\n\u0026emsp;\u0026emsp;1111,第2次循环\n\u0026emsp;\u0026emsp;200,第3次循环\n文件编码：UTF-8\n变量名称：ceshi,xunhuan\n错误请求取样器下添加响应断言\n值：${ceshi}\n在测试计划中，添加查看结果树\n运行结果\n连续运行了3次，结果是一致的。用户在第2次循环执行到错误请求时，Jmeter停止测试。\n因为设置取样器错误后执行的动作为停止线程，用户的第2次循环，执行错误请求时发生错误，Jmeter停止用户的后续执行（就它一个线程）。\n启动下一进程循环 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选启动下一线程循环\n循环次数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${xunhuan}（在前）、正确请求-${xunhuan}\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;200,第1次循环\n\u0026emsp;\u0026emsp;1111,第2次循环\n\u0026emsp;\u0026emsp;200,第3次循环\n文件编码：UTF-8\n变量名称：ceshi,xunhuan\n错误请求取样器下添加响应断言\n值：${ceshi}\n在测试计划中，添加查看结果树\n运行结果\n连续运行了3次，结果是一致的。用户执行了3次循环，其中第2次循环中，错误请求出现错误，跳过正确请求。\n因为设置取样器错误后执行的动作为启动下一线程循环，用户的第2次循环，执行错误请求时发生错误，Jmeter会跳过用户的本次执行，进行用户的后续执行。\nPart2.ramp-up时间 ramp-up时间用于设置启动所有线程所需要的时间。例如：线程数设置为10，ramp-up时间设置为100秒，那么JMeter将使用100秒使10个用户启动并运行，即每个用户将在前一个用户启动后的10秒启动。\n如果ramp-up值设置得很小、线程数又设置得很大，刚开始执行测试时会对服务器产生很大的压力。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\nRamp-Up时间：9\n线程数：3\n线程组下添加1个HTTP 请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行结果\n连续运行了3次，结果是一致的。3个用户执行线程组，各个用户的请求时间分别为2024-04-15 16:12:37 CST、2024-04-15 16:12:40 CST、2024-04-15 16:12:43 CST。\n3个用户执行请求的间隔时间正好是3秒，即ramp-up时间/线程数。\nPart3.same user on each iteration（在每次迭代中使用相同的用户） 没有研究出来它有什么用。经过我的测试，same user on each iteration（在每次迭代中使用相同的用户）启用与否，作用是一样的。\n如读者对此有不同见解，欢迎与我联系，共同探讨。目前，我十分费解。\nPart4.延迟创建线程直到需要 当在JMeter中启用延迟创建线程直到需要时，JMeter会根据预设的Ramp-up时间动态地分配线程。假设Ramp-up时间设置为20秒，线程数为10，那么JMeter会在测试启动后立即创建第一个线程并开始请求处理。随后，每隔2秒，JMeter将创建下一个线程，直到所有线程都被启动。\n如果关闭“延迟创建线程直到需要”选项，JMeter会在测试开始时一次性创建所有线程。使用同样的参数，即在测试一开始，JMeter会立即创建全部的10个线程。这些线程会按照设定的“Ramp-up时间”进行执行，每个线程将间隔2秒启动。\n延迟创建线程直到需要这一配置的目的是为了应对测试机性能有限的情况。通过这种方式，可以避免在测试初期就创建所有线程，导致资源过度占用和可能的性能问题。这种方法有助于平滑地增加系统负载，同时防止资源瞬间紧张导致测试无法正常进行。\nPart5.调度器-启动延迟 调度器主要控制线程操作时间。启用调度器后，可以输入持续时间（值不能为空），启动延迟来控制线程组的操作时间及线程组操作前的延迟时间。\n同时输入持续时间，启动延迟时，先计算启动延迟，再计算持续时间。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup5/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup5(): return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n启用调度器\n持续时间：10\n启动延迟：3\n线程组下添加1个HTTP 请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup5/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行结果\n注意看图中右上角-黄色三角形左边的计时器，值固定在2秒。这个计时器计算整个测试计划的持续时间。由于示例请求的接口响应较快，可以理解为计时器的时间就是HTTP请求时的时间。\n因为启动延迟设置为3秒，所以HTTP请求会在延迟3秒执行。不过计时器的时间是2秒，误差1秒。我多次试过把持续时间、启动延迟的时间拉长，误差还是1秒。\nPart6.调度器-持续时间 持续时间用于控制线程组的执行时间。比如持续时间设置为100秒，就算循环设置为永远，执行100秒后，线程组也会结束执行，不在发送新的请求。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup6/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup6(): sleep(3) return \u0026#39;200\u0026#39; 示例Jmeter脚本\n测试计划下添加线程组\n启用调度器\n持续时间：2\n线程组下添加1个HTTP 请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup6/\n请求方式：GET\nHTTP 请求下添加1个固定定时器\n值：3000\n在测试计划中，添加查看结果树\n运行结果\n图中结果树中什么都没有，这是因为线程组的持续时间只有2秒，但固定定时器的延迟有3秒，导致还未执行取样器，持续时间已经结束。\n此时删掉固定定时器，运行结果\n此时有人会有疑问。接口中设置的休眠时间就已经是3秒了，脚本中的持续时间还只是2秒，为什么这次成功执行了呢？\n持续时间的设置，只作用与还未执行的取样器。已经执行的取样器，无论等待多长时间，都会执行完成。\n本文示例接口源代码可从前言中下载。\n","date":"2024-03-30T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%8B%E7%AF%87/","title":"Jmeter-线程组下篇"},{"content":"线程组 线程组作为JMeter测试计划的核心组件之一，对于模拟并发用户的行为至关重要。线程组元件是整个测试计划的入口，所有的取样器和控制器必须放置在线程组下。\n可以将线程组视为一个虚拟用户池，其中每个线程可被理解为一个虚拟用户，多个虚拟用户同时执行相同的一批任务。\n在这个虚拟用户池中，每个线程之间是相互隔离且互不影响的。每个线程的执行过程中，操作的变量不会对其他线程的变量值产生影响。\n线程组的关键任务之一是定义并发用户的行为，包括设置线程数、循环次数、启动延迟等关键参数。通过适当配置线程组，测试人员可以模拟多用户在系统中同时执行任务的场景，从而评估系统的性能和稳定性。\n通过灵活使用setup线程组、线程组、tearDown线程组、开放模型线程组，配置前置操作、主要操作、后置操作，更能真实、详细的评估系统。\n线程组分为四类:\n线程组 setUp线程组 tearDown线程组 开放模型线程组 线程组、setUp线程组、tearDown线程组控制面板中的元素基本一致：\n名称、注释 在取样器错误后执行的动作 线程数 Ramp-Up时间 Same user on each iteration 延迟创建线程直到需要（只有线程组有） 调度器 开放模型线程组控制面板中的元素：\n名称、注释 在取样器错误后执行的动作 调度计划 随机种子 执行顺序 在JMeter中，setUp线程组拥有最高的优先级，而tearDown线程组则具有最低的优先级。这一优先级关系可用表达式表示为：setUp线程组 \u0026gt; 线程组 = 开放模型线程组 \u0026gt; tearDown线程组。\n这意味着在测试计划执行过程中，setUp线程组将首先执行，其后是线程组和开放模型线程组，最后执行tearDown线程组。\n通常情况下，setUp线程组用于在测试执行之前进行一些初始化工作，而tearDown线程组用于测试执行结束后的清理工作。 其他线程组在测试执行过程中按照它们在测试计划中的顺序执行。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup1(): sleep(3) # 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 return \u0026#34;我是响应\u0026#34; 示例Jmeter脚本\n在测试计划中，分别添加tearDown线程组、线程组、setUp线程组\n在tearDown线程组、线程组、setUp线程组下分别添加HTTP请求取样器\n名称分别为：tearDown线程组、线程组、setUp线程组\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup1/\n请求方式：GET\n在测试计划下添加查看结果树\n运行结果\n可以观察到在2024-04-03 15:00:07 时，setUp线程组中的取样器发送了请求。\n随后，在 2024-04-03 15:00:10 时，线程组中的请求取样器也发出了请求。\n最后，在 2024-04-03 15:00:13时，tearDown线程组请求取样器发出了请求。\n取样器的请求时间间隔与接口设置的休眠时间一致，表明 JMeter 先执行setUp线程组，随后执行线程组，最后执行 tearDown线程组 。即使脚本中的顺序不是这样。\nJmeter中线程组的执行顺序可以归纳为：setUp线程组 \u0026gt; 线程组 = 开放模型线程组 \u0026gt; tearDown线程组。\n线程数 线程组中的线程数指的是同时运行的虚拟用户数量。这个数量决定了你的测试将模拟多少个用户同时访问目标应用程序或服务。\n在JMeter的线程组配置中，你可以根据你的需求来设置线程数，通常是根据你想要模拟的用户负载量和你的系统资源来决定的。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup2/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup1(): return \u0026#34;我是响应\u0026#34; 示例Jmeter脚本\n测试计划下，添加1个线程组\n线程数：3\n在线程组下，添加HTTP请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup2/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行结果\n图中取样器结果中的Thread Name分别为线程组 1-1、线程组 1-2、线程组 1-3。这是因为线程组中线程数值为3，Jmeter启功了3个线程，每个线程皆执行1次线程组。\n在Jmeter中1个线程就代表1个用户，现在就相当于3个用户一起执行线程组。\n循环次数 在JMeter中，循环次数是指每个线程（即虚拟用户）执行其测试计划的次数。这个数量决定了你的测试将模拟用户访问目标应用程序或服务的次数。\n在JMeter的线程组配置中，你可以根据你的需求来设置循环次数，通常是根据你想要模拟的用户访问上限值，如抽奖次数。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup2/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup1(): return \u0026#34;我是响应\u0026#34; 示例Jmeter脚本\n测试计划下，添加1个线程组\n循环次数：3\n在线程组下，添加HTTP请求取样器\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup2/\n请求方式：GET\n在测试计划中，添加查看结果树\n运行结果\n图中取样器结果中的Thread Name皆为线程组 1-1。这是因为线程组中循环次数值为3，Jmeter启功了1个线程，连续执行了3次线程组。\n在Jmeter中1个线程就代表1个用户，现在就相当于1个用户执行了3次线程组。\n取样器错误后执行的动作 在JMeter中，取样器（Sampler）是用于模拟用户请求发送到目标服务器的组件，例如HTTP请求、FTP请求等。当取样器执行过程中出现错误时，可以通过配置相应的动作来处理这些错误。以下是一些处理取样器错误时，线程组中常见方式：\n停止测试\n任何一个取样器在执行过程中遇到错误时，整个测试计划将会在所有当前正在执行的线程执行完毕后停止。\n立即停止测试 任何一个取样器在执行过程中遇到错误时，JMeter会立即停止当前运行的测试，不再执行任何后续的请求或操作。\n通过合理配置这些错误处理方式，可以根据测试需求和场景来控制测试计划的行为，确保对错误有适当的响应和处理。\n停止测试-单线程组\u0026amp;单线程 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup3(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止测试\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求（在前）、正确请求（在后）\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup3/\n错误请求的请求方式：GET\n正确请求的请求方式：POST\n错误请求取样器下添加响应断言\n值：1111\n在测试计划中，添加查看结果树\n运行结果\n图中连续请求了三次，结果是一致的。\n取样器在线程组中一般是从上至下顺序执行。错误请求的结果报错后，因为设置取样器错误后执行的动作为停止测试，同时没有其他正在执行的线程，Jmeter直接结束本次测试。\n删除响应断言，再次运行\n图中连续请求了三次，结果是一致的。因为错误请求的结果没有报错，会继续执行正确请求。\n停止测试-单线程组\u0026amp;多线程 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup3(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止测试\n线程数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${yonghu}（在前）、正确请求-${yonghu}（在后）\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup3/\n错误请求的请求方式：GET\n正确请求的请求方式：POST\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;500,用户1\n\u0026emsp;\u0026emsp;1111,用户2\n\u0026emsp;\u0026emsp;500,用户3\n文件编码：UTF-8\n变量名称：ceshi,yonghu\n错误请求取样器下添加响应断言\n值：${ceshi}$\n在测试计划中，添加查看结果树\n运行结果\n图中连续请求了三次，结果是一致的。\n可以看到每次执行都是执行完用户1的线程后，因为设置取样器错误后执行的动作为停止测试，执行用户2-错误请求时发生错误，同时没有其他正在执行的线程，Jmeter直接结束本次测试。\n从这次测试中还可以看出，不仅线程组下的取样器有执行顺序，多线程也有执行顺序，即用户1\u0026gt;用户2\u0026gt;用户3。\n停止测试-单线程组\u0026amp;多循环 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup3(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划下添加线程组\n取样器错误后执行的动作中勾选停止测试\n循环次数：3\n线程组下依次添加2个HTTP 请求取样器\n名称：错误请求-${xunhuan}（在前）、正确请求-${xunhuan}（在后）\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup3/\n错误请求的请求方式：GET\n正确请求的请求方式：POST\n线程组下添加CSV 数据文件设置（右键-添加-配置元件）\n文件名：ceshi.txt的路径\n\u0026emsp;ceshi.txt文件内容：（复制后，手动删除前面的空格）\n\u0026emsp;\u0026emsp;500,第1次循环\n\u0026emsp;\u0026emsp;1111,第2次循环\n\u0026emsp;\u0026emsp;500,第3次循环\n文件编码：UTF-8\n变量名称：ceshi,xunhuan\n错误请求取样器下添加响应断言\n值：${ceshi}$\n在测试计划中，添加查看结果树\n运行结果\n图中连续请求了三次，结果是一致的。\n可以看到每次执行都是执行完第1次循环后，因为设置取样器错误后执行的动作为停止测试，执行第2循环时的错误请求-第2次循环时发生错误，同时没有其他正在执行的线程，Jmeter直接结束本次测试。\n停止测试-多线程组\u0026amp;勾选独立运行每个线程组 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup4/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup4(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 sleep(2) # 确保 与错误并行请求 在 错误请求 后结束 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划面板中勾选独立运行每个线程组\n测试计划下添加2个线程组\n名称：线程组1、线程组2\n取样器错误后执行的动作中勾选停止测试\n线程组1下添加HTTP 请求取样器\n名称：错误请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：GET\n线程组2下添加2个HTTP 请求取样器\n名称：与错误请求并行的请求、错误请求之后的请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：POST\n错误请求取样器下添加响应断言\n值：1111\n错误请求之后的正确请求取样器下添加固定定时器（右键取样器-添加-定时器）\n线程延迟：3000\t（确保 错误请求之后的正确请求 在 错误请求 后开始）\n在测试计划中，添加查看结果树\n固定定时器可以延迟取样器的执行时间，设置为3秒，可以确保错误请求之后的请求在错误请求结束后执行。\n运行结果\n图中连续运行了多次。会发现，哎！怎么会有不一样的情况。我经过多次测试，发现在勾选独立运行每个线程组\u0026amp;有多个线程组时，此时勾选停止测试，并不会按照预期进行。\n预期结果应该是，错误请求之后，Jemter直接结束测试计划，并不会执行线程组2。读者在使用时需要注意这种情况。具体原理咱们在这里就不深究了，欢迎任何有见解的读者联系我，我会贴在此段下面。\n停止测试-多线程组\u0026amp;不勾选独立运行每个线程组 示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup4/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup4(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 sleep(2) # 确保 与错误并行请求 在 错误请求 后结束 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划面板中不勾选独立运行每个线程组\n测试计划下添加2个线程组\n名称：线程组1、线程组2\n取样器错误后执行的动作中勾选停止测试\n线程组1下添加HTTP 请求取样器\n名称：错误请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：GET\n线程组2下添加2个HTTP 请求取样器\n名称：与错误请求并行的请求、错误请求之后的请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：POST\n错误请求取样器下添加响应断言\n值：1111\n错误请求之后的正确请求取样器下添加固定定时器（右键取样器-添加-定时器）\n线程延迟：3000\t（确保 错误请求之后的正确请求 在 错误请求 后开始）\n在测试计划中，添加查看结果树\n运行结果\n图中连续运行了多次。每次结果都一致，执行了错误请求、与错误请求并行的请求。\n此时线程组1和线程组2是并发的，同时执行。所以在执行错误请求时，也在执行与错误请求并行的请求。另外错误请求之后的请求因固定定时器的延迟，还未执行。\n因为设置取样器错误后执行的动作为停止测试，虽然执行错误请求时发生错误，但因此时还在执行与错误请求并行的请求，Jemter会等待与错误请求并行的请求执行结束后，在结束测试计划。\n立即停止测试-多线程组\u0026amp;不勾选独立运行每个线程组* 构想设计的立即停止测试-单线程组\u0026amp;单线程、立即停止测试-单线程组\u0026amp;多线程、立即停止测试-单线程组\u0026amp;多循环；因不涉及多个取样器并行的情况，结果是与停止测试是一致的。读者可以修改停止测试为立即停止测试进行尝试，此处不在赘述。\n构想设计的立即停止测试-多线程组\u0026amp;勾选独立运行每个线程组、与停止测试-多线程组\u0026amp;勾选独立运行每个线程组的结果是一致的。读者可以修改停止测试为立即停止测试进行尝试，此处不在赘述。\n示例接口代码\n@ThreadGroup.route(\u0026#39;/api/ThreadGroup4/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def threadgroup4(): if request.method == \u0026#39;GET\u0026#39;: return \u0026#39;500\u0026#39; # 返回错误代码 sleep(2) # 确保 与错误并行请求 在 错误请求 后结束 return \u0026#39;200\u0026#39; # 返回正确代码 示例Jmeter脚本\n测试计划面板中不勾选独立运行每个线程组\n测试计划下添加2个线程组\n名称：线程组1、线程组2\n取样器错误后执行的动作中勾选立即停止测试\n线程组1下添加HTTP 请求取样器\n名称：错误请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：GET\n线程组2下添加2个HTTP 请求取样器\n名称：与错误请求并行的请求、错误请求之后的请求\n请求地址：HTTP://127.0.0.1:5000/api/ThreadGroup4/\n请求方式：POST\n错误请求取样器下添加响应断言\n值：1111\n错误请求之后的正确请求取样器下添加固定定时器（右键取样器-添加-定时器）\n线程延迟：3000\t（确保 错误请求之后的正确请求 在 错误请求 后开始）\n在测试计划中，添加查看结果树\n运行结果\n图中连续请求了三次。结果是一致的，执行了错误请求、与错误请求并行的请求；但错误请求是一个完整的过程，成功接受到响应数据；与错误请求并行的请求则不然，在图中可以看到响应数据中有报错信息（Socket 关闭异常）。\n这是因设置为立即停止测试，在错误请求发生错误时，Jmeter立即停止测试计划，不会等待与错误请求并行的请求。\n本文示例接口源代码可从前言中下载。\n","date":"2024-03-19T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E7%BA%BF%E7%A8%8B%E7%BB%84%E4%B8%8A%E7%AF%87/","title":"Jmeter-线程组上篇"},{"content":"测试计划 可以将测试计划可视化为用于运行测试的JMeter脚本。测试计划由测试元素组成，例如线程组，逻辑控制器，样本生成控制器，监听器，定时器，断言和配置元素。 每个测试计划中至少应有一个线程组。 我们可以根据要求添加或删除元素。 前言中的快速开始就是一个测试计划。\n当你执行测试时，添加的所有所需组件和元件组成了一个有机整体，即一个完整的测试计划。这个测试计划反映了你对系统性能和功能的验证方式以及测试场景的设计。\n测试计划控制面板中的元素：\n名称和注释\n用户定义的变量\n独立运行每个线程组\n主线程结束后运行tearDown线程组\n函数测试模式\n添加目录或jar包到classpath\n用户定义的变量 当在测试计划的多个部分中存在重复的数值时，可以通过用户定义的变量来提供更灵活的设置。\n测试计划控制面板中的用户定义的变量的作用域覆盖整个测试计划。\n你可以通过${变量名称}的方式来引用这些变量。这种方式允许你在不同的请求或操作中使用相同的数值，从而更加方便地维护和修改。\n示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan1/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan1(): if request.method != \u0026#39;POST\u0026#39;: return \u0026#34;嘿！伙计，你的请求方式错了呀！\u0026#34; data = request.get_json() if \u0026#34;Variables\u0026#34; not in data: return \u0026#34;嘿！伙计，你的请求参数错了呀！\u0026#34; return \u0026#34;本次请求的用户定义的变量值是：\u0026#34; + data[\u0026#39;Variables\u0026#39;] 示例Jmeter脚本\n测试计划面板中添加用户定义的变量\n名称：Variables\n值随意输入：比如：姜\n测试计划下添加线程组\n线程组下添加HTTP请求\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan1/\n请求方式：POST\n消息体数据:{\u0026quot;Variables\u0026quot;:\u0026quot;${Variables}\u0026quot;}\nHTTP请求下添加HTTP信息头管理器（右键HTTP请求-添加-配置元件-HTTP信息头管理器，添加信息头，指定请求体类型）\n名称：Content-Type\n值：application/json\n测试计划下添加查看结果树\n运行结果\n请求体中的数据为：{\u0026ldquo;Variables\u0026rdquo;:\u0026ldquo;姜\u0026rdquo;}。说明成功调用可测试计划中用户定义的变量。\n此外，JMeter提供的配置元件中也包含用户定义的变量元件，通过测试计划/线程组/取样器-添加-配置元件-用户定义的变量进行添加。用法与测试计划面板中的用户定义的变量一致，不同之处在于作用域。\n举例来说，在测试计划下添加的用户定义的变量将在整个测试计划中生效，与测试计划面板中的用户定义的变量作用范围一致。然而，如果用户定义的变量位于取样器中，其作用范围将仅限于该特定取样器内。这种灵活性允许在不同配置元件中使用变量，使其作用范围更具体而有针对性。\n建议使用更自由的配置元件中的用户定义的变量 。\n不勾选独立运行每个线程组 不勾选独立运行每个线程组，测试计划下各线程组随机并行执行。\n示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan2/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan2(): sleep(3) # 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 return \u0026#34;响应时间：\u0026#34; + str(datetime.now()) 示例Jmeter脚本\n测试计划下添加两个线程组\n名称：线程组1、线程组2\n测试计划面板中不勾选独立运行每个线程组\n两个线程组下皆添加取样器\n名称与对应线程组一致：线程组1、线程组2\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan2/\n请求方式：GET\n测试计划下添加查看结果树\n运行结果\n取样器结果中的Sample Start 是请求发出的时间。可以观察到两个线程组内的 HTTP 请求在同一时刻发出，即 2024-04-03 11:27:43。因为两个线程组是并发、随机执行的。\n此外需要多说一下。未勾选 独立运行每个线程组时，线程组是并发执行。但线程组中的多个取样器并不会并发，而是在较短时间内发出全部请求，尤其是在取样器数量较多的情况下。\n因此，在模拟高并发时，如果需要多线程组、所有取样器请求并发，建议在测试计划中添加同步定时器（Synchronizing Timer）。\n同步定时器（Synchronizing Timer）可以确保在并发场景下的同一时间点触发多个线程组中多个取样器的请求，以更真实地模拟多用户同时访问系统的情况。\n勾选独立运行每个线程组 勾选独立运行每个线程组，测试计划下各线程组按照从上到下的顺序依次执行。\n示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan2/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan2(): sleep(3) # 接口设置了休眠三秒，即接口在接收到请求数据三秒后，返回响应数据。 return \u0026#34;响应时间：\u0026#34; + str(datetime.now()) 示例Jmeter脚本\n测试计划下添加两个线程组\n名称：线程组1、线程组2\n测试计划面板中勾选独立运行每个线程组\n两个线程组下皆添加取样器\n名称与对应线程组一致：线程组1、线程组2\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan2/\n请求方式：GET\n测试计划下添加查看结果树\n运行结果\n取样器结果中的Sample Start 是请求发出的时间。可以观察到两个线程组内的 HTTP 请求并非在同一时刻发出，线程组2的请求发出时间是 2024-04-03 11:29:28，线程组1的请求发出时间是 2024-04-03 11:29:31。两者之间的时间差为3秒，正与接口休眠的三秒相符，这表明两个线程组是顺序执行的。\n不勾选主线程结束后运行tearDown线程组 在 JMeter 中，线程组的执行优先级大于tearDown 线程组，因此tearDown 线程组将会等待所有线程组执行完毕后才会执行。\n线程组中的取样器配置为在取样器错误发生后要执行的动作为停止测试或立即停止测试时，如果线程组中的取样器发生错误，tearDown线程组就无法执行。\n如果你对这个场景有需要，可以勾选主线程结束后运行tearDown线程组。它的作用是即使普通线程由于取样器错误而导致线程结束执行时，Jmeter也会继续执行 tearDown 线程。\n这意味着即使在测试中发生了错误，系统仍会在整个测试结束前执行 tearDown 线程，以确保在测试运行结束时执行一些清理或必要的操作。\n示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan3(): return {\u0026#34;code\u0026#34;: 200} 示例Jmeter脚本\n测试计划下添加线程组、tearDown线程组\n在取样器错误后要执行的动作的选项勾选停止测试或立即停止测试\n线程组和tearDown线程组下添加http请求\n名称：线程组，tearDown线程组\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan3/\n请求方式：GET\n线程组请求取样器下添加响应断言（右键取样器-添加-断言-响应断言）\n添加、输入值：1111\n测试计划下添加查看结果树\n响应断言用于匹配实际响应信息，作为验证接口响应的一种手段。例如，示例接口响应的是 {'code': 200}，而添加的断言是 1111，这两者无法匹配，即判断该取样器请求存在错误。\n运行结果\n因为响应体{\u0026quot;code\u0026quot;: 200}与断言1111无法匹配，响应断言判断该取样器请求发生错误。未勾选主线程结束后运行tearDown线程组时，不会执行 tearDown 线程组。\n此时，修改响应断言为：{\u0026quot;code\u0026quot;:200，运行\n这次因为响应体{\u0026quot;code\u0026quot;: 200}与断言{\u0026quot;code\u0026quot;:200匹配，响应断言判断该取样器请求正常，所以线程组被执行完毕后，执行 tearDown 线程组。\n勾选主线程结束后运行tearDown线程组 示例接口代码\n@TestPlan.route(\u0026#39;/api/TestPlan3/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def testplan3(): return {\u0026#34;code\u0026#34;: 200} 示例Jmeter脚本\n测试计划下添加线程组、tearDown线程组\n在取样器错误后要执行的动作的选项勾选停止测试或立即停止测试\n线程组和tearDown线程组下添加http请求\n名称：线程组，tearDown线程组\n请求地址：HTTP://127.0.0.1:5000/api/TestPlan3/\n请求方式：GET\n线程组请求取样器下添加响应断言（右键取样器-添加-断言-响应断言）\n添加、输入值：1111\n测试计划下添加查看结果树\n运行结果\n即使响应断言判断请求发生错误，因为了勾选主线程结束后运行tearDown线程组，tearDown 线程组也会被执行。\n函数测试模式 若选择了此选项，并且监听组件（比如“查看结果树”）配置了将结果保存到文件中，JMeter将每次的请求结果记录到文件中。值得注意的是，这种做法相对消耗资源，在负载测试中并不建议勾选。然而，在平时脚本调试的情况下，可以考虑启用该选项。\n这样的设置主要适用于需要详细记录每次请求结果的情况，以便后续分析或排查问题。在负载测试中，由于可能生成大量的结果数据，将其全部保存到文件可能导致性能和资源开销的增加，因此需要谨慎使用。\n实际应用场景相对有限，因此在本文中不进行详细演示。\n添加目录或jar包到classpath 添加文件或 JAR 包功能主要用于调用外部的 JAR 包。当脚本需要引用外部的 Java 文件或 JAR 包时，可以通过将 JAR 包的路径添加到此功能中。这样，在 Beanshell 脚本中就可以通过 import 语句导入外部 JAR 包，并直接调用其中的方法。\n这个特性提供了一种扩展 JMeter 功能的途径，使得用户可以方便地集成和调用外部 Java 类库，从而实现更复杂和灵活的测试脚本。\n在后续的内容中，当涉及到 Beanshell 时，将详细阐述如何使用这一功能。\n","date":"2024-01-26T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E6%B5%8B%E8%AF%95%E8%AE%A1%E5%88%92/","title":"Jmeter-测试计划"},{"content":"\nJMeter 环境安装及配置 在使用 JMeter 之前，需要配置相应的环境，包括安装JDK和JMeter。\n首先，了解一下JDK，它就是Java的开发工具包。\nJMeter 是使用 Java 编写的。一般来说，只需要安装 JRE（Java 运行时环境）就可以运行 JMeter，因为 JRE 包含了运行 Java 应用程序所需的组件。那么为什么建议安装 JDK 呢？\n如果你想要在 JMeter 中使用一些插件、进行脚本开发、编译测试计划等高级功能，安装 JDK 可能会更有帮助，因为 JDK 包含了 JRE，并且还提供了编译 Java 代码所需的工具，比如 javac。此外，一些场景下，比如进行 HTTPS 压力测试，需要使用 JDK 中的 keytool 工具。\n确保正确配置JDK和JMeter环境，可以让你更灵活地应对不同的测试需求\nJDK 下载JDK 注意一定要下载与Jmeter对应的JDK版本，如jmeter-5.6.3与JDK21对应\nJDK下载地址示例环境为Windows，读者应根据实际环境下载JDK的安装包。推荐下载exe文件，安装方便快捷。\rhttps://www.oracle.com/java/technologies/downloads/#jdk21-windows\r安装JDK 建议在安装之前在D盘或C盘下新建一个下新建一个Tools\\JDK 文件夹。在安装 JDK 时，修改安装目录为Tools\\JDK文件夹。这样做的好处在于方便管理和配置环境变量。\n接下来就是一直下一步就行。\n配置JDK系统变量、环境变量 系统变量和环境变量是计算机系统中的两个重要概念，它们用于存储和管理系统或应用程序运行过程中需要使用的信息。\n系统变量是指在操作系统级别上设置的一些全局信息，用于控制和影响整个计算机系统的行为。 这些变量通常由操作系统或系统管理员配置，用于存储系统范围的配置参数和信息。系统变量可以影响所有用户和应用程序的行为。 如PATH是一个常见的系统变量，它存储了操作系统在哪些目录中查找可执行文件的信息。\n环境变量是在操作系统或应用程序运行过程中设置的一些动态变量，用于影响当前进程的行为。 环境变量提供了一种将信息传递给正在运行的程序的方法，以便程序根据这些变量的值来调整其行为。 如PATH变量中的值就是执行文件的环境变量。\n系统变量是操作系统级别的全局配置，而环境变量是在运行过程中用于传递信息给正在执行的程序的配置。在许多情况下，环境变量的值可以由用户或程序员进行配置，以影响特定应用程序或进程的行为。\n不要随意改动环境变量，否则可能造成系统死机。 新建JDK系统变量\n右键此电脑-属性-高级系统设置-环境变量，系统变量-新建。\n变量名：JDK\n变量值：JDK安装目录(进入JDK目录，复制文件地址栏中的值)或者浏览目录进行选择（Windows11）\nPath中新建JDK的环境环境\n系统变量中找到Path，选中后点击编辑，进入Path系统变量窗口，新建两条环境变量。然后一路确定。\n第一条：%JDK%\\bin;\n第二条：%JDK%\\jre\\bin;\nJmeter JMeter 是一个独立的 Java 应用程序，它不依赖于系统注册表或其他系统级配置。所以它能够在不同操作系统上运行而无需进行安装。只需要下载完成后，将 ZIP 文件解压缩到指定的目录。 在解压缩后的目录中找到 JMeter 启动脚本（例如 windows的jmeter.bat 或 Linux的jmeter.sh），运行该脚本以启动 JMeter。\n下载JmeterZIP包 注意一定要下载与JDK对应的Jmeter版本，如jmeter-5.6.3与JDK21对应\n历史版本Jmeter下载地址示例环境为Windows，读者应根据实际系统环境及JDK版本，下载Jmeter的安装包。下载页面写有JDK版本要求。Windows环境推荐zip包，Linux环境推荐tgz包。\rhttps://archive.apache.org/dist/jmeter/binaries/\r最新版本Jmeter下载地址示例环境为Windows，读者应根据实际系统环境及JDK版本，下载Jmeter的安装包。下载页面写有JDK版本要求。Windows环境推荐zip包，Linux环境推荐tgz包。\rhttps://jmeter.apache.org/download_jmeter.cgi\r解压到目录 建议解压到D:\\Tools目录下，方便管理。\n汉化Jmeter界面 编辑Jmeter/bin/jmeter.properties，40行增加language=zh_CN，然后保存。\n发送启动文件到桌面快捷方式 启动Jmeter 双击桌面上的 JMeter 快捷方式，等待脚本运行，然后 JMeter 界面将会显示出来。\n快速使用 我们可以使用最简单的JMeter脚本来快速进行一次接口请求。这个脚本包括测试计划、线程组、取样器（Sampler）以及查看结果器（View Results Tree）。\n在测试计划中，我们定义了整个测试的基本设置。线程组用于模拟用户，而取样器则代表了具体的请求。查看结果器则用于查看请求的详细结果。\n通过这个简单的脚本，我们能够迅速进行一次接口请求测试。\n示例接口\n@QuickUse.route(\u0026#39;/api/QuickUse/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def quickuse(): # Jmeter教程快速开始api if request.method != \u0026#39;GET\u0026#39;: return \u0026#34;请求方式非 GET\u0026#34; return \u0026#34;请求方式为 GET\u0026#34; 示例Jmeter脚本\n测试计划下添加线程组\n右键测试计划-添加-线程（用户）-线程组\n测试计划下添加查看结果树\n右键测试计划-添加-监听器-查看结果树\n线程组下添加HTTP请求\n右键线程组-添加-取样器-HTTP请求\n请求地址：HTTP://127.0.0.1:5000/api/QuickUse/\n请求方式：GET\n运行结果\n从图中可以清晰的看出，请求成功。请求数据中，包括Request Headers 请求头和Request Body 请求体。响应数据中，包括Response Headers 响应头和Response Body 响应体。\n此次请求的响应体数据为： 请求方式为 GET\n","date":"2024-01-25T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","title":"Jmeter-环境配置"},{"content":"前言 为什么要撰写这样一个教程呢？ 深入学习Jmeter\n温故而知新。尽管我已经使用JMeter很长时间，但还有许多元件我并不十分了解，因此，编写教程的过程成为了我的学习过程，通过反复回顾和整理知识，我能够更全面地掌握JMeter。\n分享知识\n我深信知识具有强大力量，而这种力量应该共享，我愿意将我的所学分享给志同道合的朋友——也就是你们。它不仅能够为他人提供帮助，姜振园还能够在这个过程中体验到一种内在的满足感。\n结识朋友\n这是我的第一个教程，后续也会编辑更多的教程。希望能通过这一行为与各位取得交流，成为朋友，与大家一起讨论更多的事情。\n关于Jmeter JMeter是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。 它可以用于测试静态和动态资源，例如静态文件、Java 小服务程序、CGI 脚本、Java 对象、数据库、FTP 服务器， 等等。\nJMeter 可以用于对服务器、网络或对象模拟巨大的负载，来自不同压力类别下测试它们的强度和分析整体性能。\n另外，JMeter能够对应用程序做功能/回归测试，通过创建带有断言的脚本来验证你的程序返回了你期望的结果。为了最大限度的灵活性，JMeter允许使用正则表达式创建断言。\n我们为什么使用Jmeter 开源免费，基于Java编写，可集成到其他系统可拓展各个功能插件\n支持接口测试，压力测试等多种功能，支持录制回放，入门简单\n相较于自己编写框架活其他开源工具，有较为完善的UI界面，便于接口调试\n多平台支持，可在Linux，Windows，Mac上运行selenium 是一套完整的web应用程序测试系统，包含了测试的录制（selenium IDE）,编写及运行（Selenium Remote Control）和测试的并行处理（Selenium Grid）。Selenium的核心Selenium Core基于JsUnit，完全由JavaScript编写，因此可以用于任何支持JavaScript的浏览器上。\n主要组件介绍 测试计划(Test Plan)\n是使用JMeter进行测试的起点，它是其它JMeter测试元件的容器。\n线程组(Thread Group)\n代表一定数量的并发用户，它可以用来模拟并发用户发送请求。\n取样器(sampler)\n定义实际的请求内容，被线程组包含，我们主要用HTTP请求。\n监听器(Listener)\n负责收集测试结果，同时也被告知了结果显示的方式。我们常用的包括：聚合报告、察看结果树、用表格查看结果，都支持将结果数据写入文件。其他的添加上去看看就行。\n逻辑控制器(Logic Controller)\n可以自定义JMeter发送请求的行为逻辑，它与Sampler结合使用可以模拟复杂的请求序列。\n其分为循环控制器和事务控制器。\n断言(Assertions)\n可以用来判断请求响应的结果是否如用户所期望的。它可以用来隔离问题域，即在确保功能正确的前提下执行压力测试。这个限制对于有效的测试是非常有用的。\n配置元件(Config Element)\n维护Sampler需要的配置信息，并根据实际的需要会修改请求的内容。我们主要在参数化中用到CSV Data Set Config。\n前置处理器(Pre Processors)和后置处理器(Post Processors)\n负责在生成请求之前和之后完成工作。前置处理器常常用来修改请求的设置，后置处理器则常常用来处理响应的数据。我们主要在动态关联中用到后置处理器的正则表达式提取器。\n定时器(Timer)\n负责定义请求之间的延迟间隔。\n执行顺序(Execution sequence)\n配置元件、前置处理器、定时器、取样器、后置处理器、断言、监听器\n工作流程 JMeter通过模拟一组用户将请求发送到目标服务器。 随后，收集数据以通过各种格式计算目标服务器的统计和显示性能度量。\n内容引用 Jmeter测试组件介绍|EMQ本系列教程中部分组件介绍文本引用于此\rhttps://www.emqx.com/zh/blog/introduction-to-jmeter-test-components#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E7%BB%84\r鸟哥教程本系列教程中部分组件介绍文本引用于此\rhttps://www.niaoge.com/jmeter/jmeter-index.html\r示例接口代码 下载示例代码本系列文章中所有示例接口皆由python编写，python版本为3.12.1，如要使用示例接口请安装python3.12.1与pycharm。压缩包内包含源码和使用说明\rhttps://www.jzy-blogs.cn/code/JmeterApi.zip\r说明 对于测试人员来说，JMeter是一款非常强大的接口测试工具，尤其在性能测试方面表现出色。希望读者们通过姜振园编写的系列教程，能够熟练掌握JMeter的使用。\n本文基于JDK21、Jmeter-5.6.3测试编写，可能不适用于历史版本及未来版本。如果Jmeter在后续的新版本中有所变化，或者文中有错漏的地方，请联系姜振园，姜振园感激不尽。\n对姜振园来说，能够帮助到读者是一件莫大的荣幸，期待更多读者通过本系列教程获得成长。\n","date":"2024-01-23T00:00:00Z","image":"https://www.jzy-blogs.cn/img/Jmeter/0.png","permalink":"https://www.jzy-blogs.cn/p/jmeter-%E5%89%8D%E8%A8%80/","title":"Jmeter-前言"}]